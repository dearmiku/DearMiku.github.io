<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DearMiku</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-13T12:58:37.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>杨尚达</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenGL ES on iOS --- 光照进阶</title>
    <link href="http://yoursite.com/2017/12/06/OpenGL%20ES%20on%20iOS%20---%20%E5%85%89%E7%85%A7%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2017/12/06/OpenGL ES on iOS --- 光照进阶/</id>
    <published>2017-12-06T03:05:29.000Z</published>
    <updated>2017-12-13T12:58:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文记录我记录我学习 坐标体系和矩阵转换的过程,加深学习便于后续查询,可能有些描述不够准确,或者内容不够充实,还请多多指正,共同学习.</p><h1 id="光源分类"><a href="#光源分类" class="headerlink" title="光源分类"></a>光源分类</h1><p>在基础光照时,学习了光照对物体的作用,也就相当于物体的材质,这次主要说 现实生活中的光源</p><h2 id="平行光"><a href="#平行光" class="headerlink" title="平行光"></a>平行光</h2><p>当光源无限远时,从其发射过来的的光可以近似的看做平行光(例如太阳);这时 光线的方向都是一致的.<br><img src="/images/OpenGL ES on iOS --- 光照进阶/15125210847433.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">float ambientStrength = 0.3;    //环境因子</span><br><span class="line">   float specularStrength = 2.0;</span><br><span class="line">   float reflectance = 256.0;</span><br><span class="line"></span><br><span class="line">   //平行光方向</span><br><span class="line">   vec3 paraLightDir = normalize(vec3(-0.2,-1.0,-0.3));</span><br><span class="line"></span><br><span class="line">   //环境光</span><br><span class="line">   vec3 ambient = ambientStrength * texture(Texture,outTexCoord).rgb;</span><br><span class="line"></span><br><span class="line">   //漫反射</span><br><span class="line">   vec3 norm = normalize(outNormal);</span><br><span class="line">   vec3 lightDir = normalize(lightPo - FragPo);    //当前顶点 至 光源的的单位向量</span><br><span class="line">   float diff = max(dot(norm,paraLightDir),0.0);</span><br><span class="line">   vec3 diffuse = diff * lightColor*texture(Texture,outTexCoord).rgb;</span><br><span class="line"></span><br><span class="line">   //镜面反射</span><br><span class="line">   vec3 viewDir = normalize(viewPo - FragPo);</span><br><span class="line">   vec3 reflectDir = reflect(-paraLightDir,outNormal);</span><br><span class="line">   float spec = pow(max(dot(viewDir, reflectDir),0.0),reflectance);</span><br><span class="line">   vec3 specular = specularStrength * spec * texture(specularTexture,outTexCoord).rgb;</span><br><span class="line"></span><br><span class="line">   //光线衰弱</span><br><span class="line">   float constantPara = 1.0f;</span><br><span class="line">   float linearPara = 0.09f;</span><br><span class="line">   float quadraticPara = 0.032f;</span><br><span class="line">   float LFDistance = length(lightPo - FragPo);</span><br><span class="line">   float lightWeakPara = 1.0/(constantPara + linearPara * LFDistance + quadraticPara * (LFDistance*LFDistance));</span><br><span class="line"></span><br><span class="line">   vec3 res = ambient + diffuse + specular;</span><br><span class="line"></span><br><span class="line">   FragColor = vec4(res,1.0);</span><br></pre></td></tr></table></figure><h2 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h2><p>点光源就是比较正常的光源,光从光源四散发出,光线的向量就等于光源到物体的向量.<br><img src="/images/OpenGL ES on iOS --- 光照进阶/15125219854634.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">float ambientStrength = 0.3;    //环境因子</span><br><span class="line">float specularStrength = 2.0;</span><br><span class="line">float reflectance = 256.0;</span><br><span class="line"></span><br><span class="line">float constantPara = 1.0f;    //常亮</span><br><span class="line">float linearPara = 0.09f;     //线性部分因数</span><br><span class="line">float quadraticPara = 0.032f; //二次项部分因数</span><br><span class="line"></span><br><span class="line">//环境光</span><br><span class="line">vec3 ambient = ambientStrength * texture(Texture,outTexCoord).rgb;</span><br><span class="line"></span><br><span class="line">//漫反射</span><br><span class="line">vec3 norm = normalize(outNormal);</span><br><span class="line">vec3 lightDir = normalize(lightPo - FragPo);    //当前顶点 至 光源的的单位向量</span><br><span class="line"></span><br><span class="line">//点光源</span><br><span class="line">float diff = max(dot(norm,lightDir),0.0);   //光源与法线夹角</span><br><span class="line">vec3 diffuse = diff * lightColor*texture(Texture,outTexCoord).rgb;</span><br><span class="line"></span><br><span class="line">//镜面反射</span><br><span class="line">vec3 viewDir = normalize(viewPo - FragPo);</span><br><span class="line">vec3 reflectDir = reflect(-lightDir,outNormal);</span><br><span class="line"></span><br><span class="line">float spec = pow(max(dot(viewDir, reflectDir),0.0),reflectance);</span><br><span class="line">vec3 specular = specularStrength * spec * texture(specularTexture,outTexCoord).rgb;</span><br><span class="line"></span><br><span class="line">float LFDistance = length(lightPo - FragPo);</span><br><span class="line">float lightWeakPara = 1.0/(constantPara + linearPara * LFDistance + quadraticPara * (LFDistance*LFDistance));</span><br><span class="line"></span><br><span class="line">vec3 res = (ambient + diffuse + specular)*lightWeakPara;</span><br><span class="line"></span><br><span class="line">FragColor = vec4(res,1.0);</span><br></pre></td></tr></table></figure><h2 id="聚光源"><a href="#聚光源" class="headerlink" title="聚光源"></a>聚光源</h2><p>聚光源的效果就相当于 手电筒,好比朝向指定范围的点光源~<br><img src="/images/OpenGL ES on iOS --- 光照进阶/15125220581520.jpg" alt=""><br>在使用聚光源时,就需要指定 聚光朝向SpotDir,和切光角ϕ. 当光源指向点的向量和SpotDir的夹角大于ϕ时,则无法被光源照射到.</p><p>但是这样的明暗边界十分明显,效果不够真实</p><p><img src="/images/OpenGL ES on iOS --- 光照进阶/screenshot1.png" alt="初始版本"></p><p>这时,我们就需要将过渡边缘平滑,这时 我们就需要引入两个参数, 内锥角和外锥角. 外锥角就是切光角,而内锥角以内不需要平滑效果, 内锥角和外锥角之间需要平滑过度.<br>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/(一些复杂的计算操作 应该让CPU做,提高效率,不变的量也建议外部传输,避免重复计算)</span><br><span class="line">float inCutOff = cos(radians(10.0f));   //内锥角cos值</span><br><span class="line">float outCutOff = cos(radians(15.0f));  //外锥角cos值</span><br><span class="line">vec3 spotDir = vec3(-1.2f,-1.0f,-2.0f); //聚光朝向</span><br><span class="line"></span><br><span class="line">float theta = dot(lightDir,normalize(-spotDir));    //光源指向物体的向量 和 聚光朝向的 cos值</span><br><span class="line">float epsilon  = inCutOff - outCutOff;  //内外锥角cos差值</span><br><span class="line"></span><br><span class="line">//clamp(a,b,c);若b&lt;a&lt;c 则函数返回值为a 若不是,则返回值最小为b 最大为c</span><br><span class="line">// (theta - outCutOff)/epsilon 若theta的角度小于内锥角 则其值&gt;=1 若theta的角度大于外锥角 则其值&lt;=0 这样光线就在内外锥角之间平滑变化.</span><br><span class="line">float intensity = clamp((theta - outCutOff)/epsilon,0.0,1.0);</span><br></pre></td></tr></table></figure><p>结果:<br><img src="/images/OpenGL ES on iOS --- 光照进阶/screenshot.png" alt="结果"></p><h1 id="光线衰弱"><a href="#光线衰弱" class="headerlink" title="光线衰弱"></a>光线衰弱</h1><p>在现实情况中,光源发出的光线是会随着距离的增长而衰减的, 而且也不是线性衰减的,表现为在距离光源近的这段距离衰减的较快, 在距离光源较远的情况下衰减较慢.<br>通常使用这个公式来模拟光线衰减.</p><p><img src="/images/OpenGL ES on iOS --- 光照进阶/screenshot2.png" alt="衰减公式"></p><blockquote><p>常数项通常保持为1.0，它的主要作用是保证分母永远不会比1小，否则的话在某些距离上它反而会增加强度，这肯定不是我们想要的效果<br>一次项会与距离值相乘，以线性的方式减少强度<br>二次项会与距离的平方相乘，让光源以二次递减的方式减少强度。二次项在距离比较小的时候影响会比一次项小很多，但当距离值比较大的时候它就会比一次项更大了</p></blockquote><p><img src="/images/OpenGL ES on iOS --- 光照进阶/15125247574821.jpg" alt="效果展示"><br>在效果图中,在达到距离100时就近似没有光的效果了.</p><p><img src="/images/OpenGL ES on iOS --- 光照进阶/screenshot3.png" alt="参数距离表"><br>距离与参数的关联.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float LFDistance = length(lightPo - FragPo);</span><br><span class="line">float lightWeakPara = 1.0/(constantPara + linearPara * LFDistance + quadraticPara * (LFDistance*LFDistance));</span><br><span class="line"></span><br><span class="line">vec3 res = (ambient + diffuse + specular)*lightWeakPara;</span><br></pre></td></tr></table></figure><h1 id="光照贴图"><a href="#光照贴图" class="headerlink" title="光照贴图"></a>光照贴图</h1><p>在一张纹理图中,由于材质不同,所呈现的效果也会有所不同,如同下面这个箱子,金属边框和木头在相同光源下所呈现的1效果肯定有所不同.<br><img src="/images/OpenGL ES on iOS --- 光照进阶/15125252548879.jpg" alt="-w250"></p><p>这时为了在显示光照效果时将其区分开来,则需要引入光照贴图的概念~ 如下图<br><img src="/images/OpenGL ES on iOS --- 光照进阶/15125254567342.jpg" alt="-w250"><br>在该贴图中,对应木头部分为黑色vec3(0.0); 而在金属边框部分 则对应的为灰色, 这样在计算 漫反射或者镜面时,将其作为参考系数,则可以让其呈现不同的效果.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vec3 spe = texture(specularTexture,outTexCoord).rgb;   //获取镜面光照贴图</span><br><span class="line"> </span><br><span class="line">vec3 viewDir = normalize(viewPo - FragPo);</span><br><span class="line">vec3 reflectDir = reflect(-lightDir,outNormal);</span><br><span class="line"></span><br><span class="line">float spec = pow(max(dot(viewDir, reflectDir),0.0),spL.reflectance);</span><br><span class="line">vec3 specular = point_specularStrength * spec * spe;    //使用光照贴图纹理</span><br></pre></td></tr></table></figure><p><img src="/images/OpenGL ES on iOS --- 光照进阶/screenshot4.png" alt="镜面光照纹理效果"><br>是可以看出箱子铁框的镜面效果 比 木头的效果要强</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;本文记录我记录我学习 坐标体系和矩阵转换的过程,加深学习便于后续查询,可能有些描述不够准确,或者内容不够充实,还请多多指正,共同学习.&lt;/p
      
    
    </summary>
    
    
      <category term="Opengl ES" scheme="http://yoursite.com/tags/Opengl-ES/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES on iOS --- 基础光照</title>
    <link href="http://yoursite.com/2017/12/05/OpenGL%20ES%20on%20iOS%20---%20%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/"/>
    <id>http://yoursite.com/2017/12/05/OpenGL ES on iOS --- 基础光照/</id>
    <published>2017-12-05T01:18:17.000Z</published>
    <updated>2017-12-05T01:18:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文记录我记录我学习 坐标体系和矩阵转换的过程,加深学习便于后续查询,可能有些描述不够准确,或者内容不够充实,还请多多指正,共同学习.</p><h1 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h1><p>一个没有Alpha通道的颜色可以用一个3维向量来表示 例如 glm::vec3(1.0,1.0,1.0); 表示白色.</p><p>在现实世界中,一个物体的颜色是它反射的颜色导致的, 例如我们将纯红光 照射在纯绿物体上, 因为红光都被吸收,所以显示为黑色.</p><p>将吸收反射的过程用向量表示出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 lightColor(0.0f, 1.0f, 0.0f); //绿色光源向量</span><br><span class="line">glm::vec3 objColor(1.0f, 0.5f, 0.31f);  //物体色</span><br><span class="line">glm::vec3 result = lightColor * objColor; // 光源下颜色(0.0f, 0.5f, 0.0f);</span><br></pre></td></tr></table></figure><h1 id="冯氏光照模型"><a href="#冯氏光照模型" class="headerlink" title="冯氏光照模型"></a>冯氏光照模型</h1><p>冯氏光照模型的主要结构由3个分量组成 环境(Ambient) 漫反射(Diffuse) 镜面(Specular)<br><img src="/images/OpenGL ES on iOS --- 基础光照/15123749275555.jpg" alt=""></p><h2 id="环境光照"><a href="#环境光照" class="headerlink" title="环境光照"></a>环境光照</h2><p>在现实环境下 即使在黑暗的情况下,世界上通常也会有一些光亮(如 月光), 而且即使物体不朝光源的,也会因为 其他物体的反射,使阴面有光,这种情况下 就要使用 <strong>全局照明算法</strong> 这种算法开销大而且复杂,以后在研究 先实现简单的 环境光照</p><p>所以给物体一个环境光照量,让物体始终有一点颜色. 在着色器中表现如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    float ambientStrength = 0.1;        //至少有%10的光找到物体所有面</span><br><span class="line">    vec3 ambient = ambientStrength * lightColor;</span><br><span class="line"></span><br><span class="line">    vec3 result = ambient * objectColor;</span><br><span class="line">    FragColor = vec4(result, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漫反射光照"><a href="#漫反射光照" class="headerlink" title="漫反射光照"></a>漫反射光照</h2><p>模拟光源对物体的方向性影响(Directional Impact)。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮. 也就是<strong>光线</strong>和<strong>物体表面法线</strong>的夹角越小,光线对物体的影响就越大.<br><img src="/images/OpenGL ES on iOS --- 基础光照/15123768104392.jpg" alt=""></p><p>这样就可以利用夹角的cos值作为参考,来修改光线对物体的影响.</p><p>片段着色器重相关实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uniform vec3 lightColor;        //光源色</span><br><span class="line">uniform vec3 lightPo;           //光源位置</span><br><span class="line">uniform vec3 objectColor;       //物体色</span><br><span class="line">uniform vec3 viewPo;            //物体位置</span><br><span class="line"></span><br><span class="line">in vec3 outNormal;              //传入当前顶点平面的法向量</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vec3 norm = normalize(outNormal);   //确保法线为单位向量</span><br><span class="line">vec3 lightDir = normalize(lightPo - FragPo);  //顶点指向光源 单位向量  </span><br><span class="line"></span><br><span class="line">float diff = max(dot(norm,lightDir),0.0);   //得到两向量的cos值 小于0则则为0</span><br><span class="line">vec3 diffuse = diff * lightColor;           //得到漫反射收的光源向量</span><br></pre></td></tr></table></figure><h3 id="法向量变换"><a href="#法向量变换" class="headerlink" title="法向量变换"></a>法向量变换</h3><p>对于法向量,它是一个方向向量,不会因为物体的移动而发生变化,所以在对法向量 进行矩阵处理时,要消除矩阵中位移部分对其造成的影响. 因此位移使用3x3矩阵 或者 将 法向量的w分量设置为0.0; </p><p>另外,若矩阵对物体进行里不等比缩放时候,会导致法向量不在垂直于物体表面.<br><img src="/images/OpenGL ES on iOS --- 基础光照/15123784323220.jpg" alt=""></p><p>这种情况 则需要使用<strong>法线矩阵</strong> 来移除对法向量错误缩放的影响. 法线矩阵由<strong>逆矩阵</strong>和<strong>转置矩阵</strong> 组成.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::transpose(glm::inverse(model));    //法线矩阵的计算</span><br><span class="line"></span><br><span class="line">mat3(transpose(inverse(model))) * aNormal;  //着色器语言的使用 使用3x3矩阵 能够与 vec3法向量计算</span><br></pre></td></tr></table></figure><h2 id="镜面光照"><a href="#镜面光照" class="headerlink" title="镜面光照"></a>镜面光照</h2><p> 模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。镜面光照的计算依赖于 观察的视角, 若视线与光源在物体的反射线的夹角越小 则镜面光照效果越好.</p><p> 计算他 我们需要 观察者位置.镜面强度(镜面效果强弱)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float specularStrength = 0.5;   //镜面强度</span><br><span class="line">vec3 viewDir = normalize(viewPo - FragPo);  //顶点指向观察点的单位向量</span><br><span class="line">vec3 reflectDir = reflect(-lightDir,outNormal); //求得光线 在 顶点的反射线(传入光源指向顶点的向量)</span><br><span class="line"></span><br><span class="line">float spec = pow(max(dot(viewDir, reflectDir),0.0),256.0);</span><br><span class="line">// 求得夹角cos值 取256次幂 注意 pow(float,float)函数参数类型</span><br><span class="line"></span><br><span class="line">vec3 specular = specularStrength * spec * lightColor;</span><br></pre></td></tr></table></figure><p>256 表示高光的反光度, 反光度越高,发射光的能力越强,散射越少 高光点越小<br><img src="/images/OpenGL ES on iOS --- 基础光照/15124362663769.jpg" alt=""></p><p>最后综合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec3 res =(ambientStrength + diffuse + specular) * objectColor;</span><br></pre></td></tr></table></figure><p>效果图: 白色方块为白色光源<br><img src="/images/OpenGL ES on iOS --- 基础光照/%E6%95%88%E6%9E%9C%E5%9B%BE.gif" alt="效果图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;本文记录我记录我学习 坐标体系和矩阵转换的过程,加深学习便于后续查询,可能有些描述不够准确,或者内容不够充实,还请多多指正,共同学习.&lt;/p
      
    
    </summary>
    
    
      <category term="Opengl ES" scheme="http://yoursite.com/tags/Opengl-ES/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES on iOS --- 坐标系统与矩阵转换</title>
    <link href="http://yoursite.com/2017/12/01/OpenGL%20ES%20on%20iOS%20---%20%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2017/12/01/OpenGL ES on iOS --- 坐标系统与矩阵转换/</id>
    <published>2017-12-01T09:29:23.000Z</published>
    <updated>2017-12-01T09:33:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文记录我记录我学习 坐标体系和矩阵转换的过程,加深学习便于后续查询,可能有些描述不够准确,或者内容不够充实,还请多多指正,共同学习</p><h1 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h1><p>我们将物体坐标进行一系列变换,达到自己期望的位置,需要使用到矩阵.先说一下矩阵的公式.这里我是本着了解的心态去学习的,因为已经有趁手的数学工具了,把重要的学完~ 我会再来研究这里的.</p><h2 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h2><p>这是一个简单的矩阵相乘例子,<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/screenshot2.png" alt="例子"><br>这是矩阵乘法过程~<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/screenshot3.png" alt="矩阵乘法过程"></p><p>注意:</p><blockquote><p>1, 矩阵相乘不遵守交换律 即 A <em> B ≠ B </em> A<br>2, 只有当左侧矩阵列数 等于 右侧矩阵行数 两矩阵才能相乘.</p></blockquote><p>在我们对坐标进行缩放,位移,旋转 等变换时,我们多用4x4矩阵来进行~</p><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>我们把缩放变量表示为(S1,S2,S3)我们可以为任意向量(x,y,z)定义一个缩放矩阵：<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/screenshot1.png" alt="缩放矩阵"></p><h2 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h2><p>如果我们把位移向量表示为(Tx,Ty,Tz)，我们就能把位移矩阵定义为：<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/screenshot4.png" alt="位移矩阵"></p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>绕X轴旋转<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/screenshot5.png" alt="x轴旋转"><br>绕y轴旋转<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/screenshot6.png" alt="y轴旋转"><br>绕z轴旋转<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/screenshot7.png" alt="z轴旋转"></p><p>将旋转分为绕3个轴进行旋转,以达到自己希望的位置,见下面这个公式，(Rx,Ry,Rz)代表任意旋转轴：<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/screenshot8.png" alt="任意旋转"></p><p>这种处理方式,简单容易理解,但是 会出现一个问题<strong>万向节死锁</strong>.</p><p>举个栗子~ 加入在三维空间中有一个平行于X中的向量,然后将它绕Y轴旋转至它平行于Z轴,这时绕z轴的任何旋转都不会改变 向量的方向了. 在正常情况下,关于3个轴的旋转过程应该是可以任意组合的,最终旋转结果都是一致的,但是当出现了万向节死锁后, 就会导致各个轴旋转顺序 组合不同,而最终旋转结果不同~ 大家可以找根笔试一试~也可以看看这里:<a href="http://blog.csdn.net/andrewfan/article/details/60981437" target="_blank" rel="external">欧拉角与万向节死锁（图文版</a></p><p>那么如何解决呢~ 使用四元数 <a href="http://insaneguy.me/2015/03/25/rotation_matrix_and_quaternions/" target="_blank" rel="external">旋转矩阵与四元数</a> 因为复变函数早已还给老师~ 后续再研究补充~~</p><h2 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h2><p>在上面关于描述3D坐标的向量 是四维向量,多出一个分量w,w分量的用处是来创造3D视觉效果的,根据w分量的大小对物体进行拉伸,最后将w=1的截面进行展示,从而产生物体远近效果. 这篇文章我觉得介绍的比较详细 <a href="http://www.jianshu.com/p/7e701d7bfd79" target="_blank" rel="external">写给大家看的“透视除法” —— 齐次坐标和投影</a></p><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>我将不同变换的矩阵组合起来~ 将一个放大2倍的矩阵 和位移(1,2,3)的矩阵组合起来~,得到新的变换矩阵<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/screenshot9.png" alt="矩阵组合"></p><p>将得到的变换矩阵 进行验证<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/screenshot9.png" alt="矩阵验证"></p><p>因为矩阵相乘是不遵守<em>交换律</em>的,所以在矩阵组合时,顺序就十分重要, 建议 先缩放 –&gt; 再旋转 –&gt; 再位移. 并且矩阵的顺序是从右到左的  所以应该是<br>位移矩阵 <em> 旋转矩阵 </em> 缩放矩阵 = 所需矩阵</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>为什么我们要用矩阵来进行着一系列的变换呢? 据我了解 是因为这样做,将 旋转,位移,缩放加以统一.简化计算流程,提高计算机的计算效率.</p><p>最后总结:像这样利用矩阵进行位移,缩放,旋转 这一系列的变换叫做:<strong>仿射变换</strong></p><h1 id="坐标体系"><a href="#坐标体系" class="headerlink" title="坐标体系"></a>坐标体系</h1><p>OpenGL 顶点着色器 希望接受的的顶点 都是<strong>标准化设备坐标</strong>(Normalized Device Coordinate, NDC)的坐标,也就是(x,y,z)都是在 -1~1之间变换.在此之外的顶点丢弃,并且按照传入的顶点进行绘制.</p><p>将3D的物体坐标转换到理想的绘制效果需要进行一些列的转换过程.<br>局部空间(Local Space)/物体空间(Object Space) —&gt; 世界空间(World Space) —&gt; 观察空间(View Space)/视觉空间(Eye Space) —&gt;裁剪空间(Clip Space) —&gt; 屏幕空间(Screen Space)</p><p>OpenGL是不提供数学工具的~ 我们可以使用 <strong>GLM(OpenGL Mathematics)</strong> <a href="http://glm.g-truc.net/0.9.9/index.html" target="_blank" rel="external">GLM官网</a> 我用的是0.9.9版本~</p><p>示意图:<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/15120025806643.jpg" alt="坐标空间变换"></p><h2 id="局部空间"><a href="#局部空间" class="headerlink" title="局部空间"></a>局部空间</h2><p>局部空间: 就表示物体在自己本身坐标系里的坐标,比较像view的bounds属性.可以理解为建模时模型的坐标. </p><h2 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h2><p>世界空间: 表示物体需要展示世界里的坐标,比较像view的frame属性,好比我们的模型是个房子,将它放到小镇(世界)中, 这时它的坐标就是在世界空间的坐标.</p><p>将局部空间坐标转换为世界空间坐标需要进行一系列转换,就像在象棋棋盘上放棋子,我们需要将棋子旋转,位移…操作才能将棋子放到正确的位置上.</p><h2 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h2><p>在最终展示时,我们展示的是用户观察的界面, 我们需要将世界空间的坐标 转换为 以用户坐标观察视野产生的结果.</p><h2 id="裁剪空间"><a href="#裁剪空间" class="headerlink" title="裁剪空间"></a>裁剪空间</h2><p>在OpenGL 中所期望的坐标是 标准化设备坐标, 所以我们 需要将自己的坐标集进行转换,将需要显示的坐标 落在 -1.0~1.0之间. </p><p>如果只是图元(Primitive)，例如三角形，的一部分超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围,就像三角形的角被切了一刀变成四边形那样~</p><h3 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h3><p>在裁剪时,我们是将3D空间的物体 转换为 2D空间的平面图像, 这样的过程叫做投影, 像投影截取的显示的3D空间 <strong>平截头体</strong>,它就像一个容器,在这里面的所有坐标都不会被裁剪掉~</p><h4 id="正射投影"><a href="#正射投影" class="headerlink" title="正射投影"></a>正射投影</h4><p>在裁剪空间阶段,获得平截头体的方式, 就是通过 正射投影. 使用正射投影矩阵创天平截头体 需要指定 近平面宽高, 远平面宽高.<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/15120115864167.jpg" alt=""><br>通过正射投影矩阵,将3D空间的坐标 映射到2D平面中,但是这样产生的问题是 并没有远近缩放的效果,这时就需要 透视投影.</p><h4 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h4><p>透视投影,就是利用齐次坐标w 来生成远近效果的, 离观察者越远的顶点 w分量越大.在显示时,顶点坐标的每个分量都会除以w分量,进而使 远端的物体小,近端的物体大.</p><p>透视矩阵 会根据平截头体的顶点的远近,对顶点w分量进行修改</p><h2 id="组合-1"><a href="#组合-1" class="headerlink" title="组合"></a>组合</h2><p>若上面每一个步骤都产生一个变换矩阵的话,那么最终的顶点坐标应该是这个样子的<br>目标顶点 = 投影矩阵 <em> 观察矩阵 </em> 模型矩阵 *原始顶点</p><h2 id="标准化设备坐标"><a href="#标准化设备坐标" class="headerlink" title="标准化设备坐标"></a>标准化设备坐标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//此方法创建的窗口就是对应的OpenGL 的标准化设备窗口</span><br><span class="line">glViewport(0, 0, self.frame.size.width, self.frame.size.height);</span><br></pre></td></tr></table></figure><h2 id="模型矩阵"><a href="#模型矩阵" class="headerlink" title="模型矩阵"></a>模型矩阵</h2><p>模型矩阵 包含了 位移,缩放,旋转操作, 它将应用到物体的所有定点上. 该矩阵的目的就是将原来位于 世界空间(0,0,0)点的物体 移动到它应该出现的位置.</p><h2 id="观察矩阵"><a href="#观察矩阵" class="headerlink" title="观察矩阵"></a>观察矩阵</h2><p>观察矩阵就像是 3D世界里的摄像机,最终显示的画面 就是摄影机的位置 和 方向 观察的画面~ 观察矩阵的创建就需要 GLM 提供的LooK AT 函数:</p><p>tmat4x4<t, p=""> lookAt(tvec3<t, p=""> const &amp; eye, tvec3<t, p=""> const &amp; center, tvec3<t, p=""> const &amp; up)</t,></t,></t,></t,></p><p>该函数需要输入 3个 vec3变量,返回观察矩阵:</p><blockquote><p>参数1: 相机在世界坐标系的位置<br>参数2: 相机镜头指向的位置<br>参数3: 世界的上向量,上向量的方向 在显示时 是指向屏幕上方的向量  </p></blockquote><p>通过对这三个变量控制,就可以实现我们希望的效果,我在练习时 实现的是类似 游戏CS里 摄像头移动的方式</p><h2 id="投影矩阵"><a href="#投影矩阵" class="headerlink" title="投影矩阵"></a>投影矩阵</h2><p>glm::mat4 proj = glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f);</p><p>此函数其实是创建了一个 定义了 可视控件的 平头截体,此空间以外的东西都将被抛弃~<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/15120295944189.jpg" alt=""><br>参数:</p><blockquote><p>第一个参数定义了<strong>fov值</strong>,它表示了视野(Field of View),就相当于摄影机的摄影角度~~<br>第二个参数 为宽高比, 由视口的宽/高所得<br>第三和第四个参数 设置了平截头体的近和远平面。我们通常设置近距离为0.1f，而远距离设为100.0f。所有在近平面和远平面内且处于平截头体内的顶点都会被渲染.</p></blockquote><p>最后经过透视矩阵的处理,就产生了 物体 远小近大的效果了~</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>这里就捡与本文相关的说~ </p><h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#version 300 es</span><br><span class="line"></span><br><span class="line">layout(location = 0) in vec3 position;</span><br><span class="line">layout(location = 1) in vec3 color;</span><br><span class="line">layout(location = 2) in vec2 texCoord;  //纹理坐标</span><br><span class="line"></span><br><span class="line">//uniform mat4 transform;</span><br><span class="line"></span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line">out vec3 outColor;</span><br><span class="line">out vec2 outTexCoord;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gl_Position = projection*view*model*vec4(position,1.0);</span><br><span class="line">    outColor = color;</span><br><span class="line">    outTexCoord = texCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开启深度测试"><a href="#开启深度测试" class="headerlink" title="开启深度测试"></a>开启深度测试</h2><p>OpenGL存储它的所有深度信息于一个<strong>Z缓冲(Z-buffer)</strong>中，也被称为深度缓冲(Depth Buffer)。GLFW会自动为你生成这样一个缓冲（就像它也有一个颜色缓冲来存储输出图像的颜色）。深度值存储在每个片段里面（作为片段的z值），当片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为<strong>深度测试(Depth Testing)</strong>，它是由OpenGL自动完成的。</p><p>深度测试还有其他关于 自定以的函数,以后再说~~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int wi,he;</span><br><span class="line">//检索有关绑定缓冲区的对象的信息 ,这里获得了layer的宽高</span><br><span class="line">glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &amp;wi);</span><br><span class="line">glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &amp;he);</span><br><span class="line"></span><br><span class="line">glGenRenderbuffers(1, &amp;depthBuf);</span><br><span class="line">glBindRenderbuffer(GL_RENDERBUFFER, depthBuf);</span><br><span class="line">glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, wi, he);</span><br><span class="line"></span><br><span class="line">//还要记得开启深度测试</span><br><span class="line">  glEnable(GL_DEPTH_TEST);</span><br></pre></td></tr></table></figure><h2 id="模型矩阵-1"><a href="#模型矩阵-1" class="headerlink" title="模型矩阵"></a>模型矩阵</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cubePositions[] = &#123;</span><br><span class="line">      glm::vec3( 0.0f,  0.0f,  0.0f),</span><br><span class="line">      glm::vec3( 2.0f,  5.0f, -15.0f),</span><br><span class="line">      glm::vec3(-1.5f, -2.2f, -2.5f),</span><br><span class="line">      glm::vec3(-3.8f, -2.0f, -12.3f),</span><br><span class="line">      glm::vec3( 2.4f, -0.4f, -3.5f),</span><br><span class="line">      glm::vec3(-1.7f,  3.0f, -7.5f),</span><br><span class="line">      glm::vec3( 1.3f, -2.0f, -2.5f),</span><br><span class="line">      glm::vec3( 1.5f,  2.0f, -2.5f),</span><br><span class="line">      glm::vec3( 1.5f,  0.2f, -1.5f),</span><br><span class="line">      glm::vec3(-1.3f,  1.0f, -1.5f)</span><br><span class="line">  &#125;;</span><br><span class="line">  for(unsigned int i = 0; i &lt; 10; i++)</span><br><span class="line">  &#123;</span><br><span class="line">      //模型矩阵</span><br><span class="line">      glm::mat4 model;</span><br><span class="line">      model = glm::translate(model, cubePositions[i]);</span><br><span class="line">      float angle = 20.0f * i;</span><br><span class="line">      model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f));</span><br><span class="line">      glUniformMatrix4fv(glGetUniformLocation(program, &quot;model&quot;), 1, GL_FALSE, glm::value_ptr(model));</span><br><span class="line"></span><br><span class="line">      glDrawArrays(GL_TRIANGLES, 0, 36);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的模型矩阵 将物体 进行位移,旋转后 放在世界坐标系中合适的位置.</p><h2 id="观察矩阵-1"><a href="#观察矩阵-1" class="headerlink" title="观察矩阵"></a>观察矩阵</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">定义了 相机的初始位置 与 初始方向(这里讲方向保持为单位向量)</span><br><span class="line">glm::vec3 cameraLo = glm::vec3(10.0f,0.0f,0.0f);</span><br><span class="line">glm::vec3 cameraDir = glm::vec3(1.0f,0.0f,0.0f);</span><br><span class="line"></span><br><span class="line">.........其他代码.........</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::lookAt(cameraLo,cameraLo-cameraDir, glm::vec3(0.0, 1.0, 0.0));</span><br><span class="line"></span><br><span class="line">//将镜头观察点 保持为 镜头方向位置  向上方向 设置为y轴.</span><br><span class="line"></span><br><span class="line">glUniformMatrix4fv(glGetUniformLocation(program, &quot;view&quot;), 1, GL_FALSE, glm::value_ptr(view));</span><br></pre></td></tr></table></figure><p>在Display计时器中持续调用该方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-(void)move&#123;</span><br><span class="line">    if (_isAdvance) &#123;</span><br><span class="line">        // 使摄像机 向朝向方向移动~~</span><br><span class="line">        cameraLo -=(cameraDir*(speed/24));</span><br><span class="line">    &#125;</span><br><span class="line">    if (_isback) &#123;</span><br><span class="line">        cameraLo +=(cameraDir*(speed/24));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //改变摄像机朝向</span><br><span class="line">    if (_isLeft) &#123;</span><br><span class="line">        cameraDir = glm::normalize(glm::vec3(cameraDir[0],cameraDir[1],cameraDir[2]-rotateSpeed));</span><br><span class="line">    &#125;</span><br><span class="line">    if (_isRight) &#123;</span><br><span class="line">        cameraDir = glm::normalize(glm::vec3(cameraDir[0],cameraDir[1],cameraDir[2]+rotateSpeed));</span><br><span class="line">    &#125;</span><br><span class="line">    if (_isUp) &#123;</span><br><span class="line">        cameraDir = glm::normalize(glm::vec3(cameraDir[0],cameraDir[1]-rotateSpeed,cameraDir[2]));</span><br><span class="line">    &#125;</span><br><span class="line">    if (_isDown) &#123;</span><br><span class="line">        cameraDir = glm::normalize(glm::vec3(cameraDir[0],cameraDir[1]+rotateSpeed,cameraDir[2]));</span><br><span class="line">    &#125;</span><br><span class="line">    [self render];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/dearmiku/Opengl-" target="_blank" rel="external">demo地址</a></p><p>最终实现效果:<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/Socket1.gif" alt="Socket1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;本文记录我记录我学习 坐标体系和矩阵转换的过程,加深学习便于后续查询,可能有些描述不够准确,或者内容不够充实,还请多多指正,共同学习&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Opengl ES" scheme="http://yoursite.com/tags/Opengl-ES/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES on iOS --- 2D纹理</title>
    <link href="http://yoursite.com/2017/11/29/OpenGL%20ES%20on%20iOS%20---%202D%E7%BA%B9%E7%90%86/"/>
    <id>http://yoursite.com/2017/11/29/OpenGL ES on iOS --- 2D纹理/</id>
    <published>2017-11-29T03:00:43.000Z</published>
    <updated>2017-11-29T03:01:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>纹理是用来丰富我们绘制物体细节的,它可以是一张2D图片(除了图像外,纹理也被用来存储大量数据,传递到着色器上),就像贴图一样贴在绘制的物体上.</p><h1 id="纹理属性"><a href="#纹理属性" class="headerlink" title="纹理属性"></a>纹理属性</h1><h2 id="纹理坐标"><a href="#纹理坐标" class="headerlink" title="纹理坐标"></a>纹理坐标</h2><p>为了将纹理映射到绘制的物体上,我们需要指定 某个顶点对应着 纹理的那个位置. 通过纹理坐标,标明顶点从纹理图像那一部分采样,之后在图形的其它片段进行片段插值.</p><p>纹理坐标系和顶点坐标系有所不同,顶点坐标系 (0,0)点位于窗口中心. 纹理坐标系 (0,0)点位于 纹理左下角.</p><p>顶点坐标系<br><img src="/images/OpenGL ES on iOS --- 2D纹理/15119166430264.jpg" alt="顶点坐标系"></p><p>纹理坐标系<br><img src="/images/OpenGL ES on iOS --- 2D纹理/15119169959085.jpg" alt="纹理坐标系"></p><h2 id="纹理环绕方式"><a href="#纹理环绕方式" class="headerlink" title="纹理环绕方式"></a>纹理环绕方式</h2><p>当我们将顶点位置设置到纹理坐标之外时,则需要设置纹理环绕方式 来显示纹理图案</p><table><thead><tr><th>环绕属性</th><th>效果</th></tr></thead><tbody><tr><td>GL_REPEAT</td><td>重复纹理图案(默认)</td></tr><tr><td>GL_MIRRORED_REPEAT</td><td>镜像重复纹理图案</td></tr><tr><td>GL_CLAMP_TO_EDGE</td><td>将纹理锁定在0~1之间,超出部分重复纹理边缘图案,产生拉伸效果</td></tr><tr><td>GL_CLAMP_TO_BORDER</td><td>超出部分为用户指定边缘颜色</td></tr></tbody></table><p><img src="/images/OpenGL ES on iOS --- 2D纹理/15119175487458.jpg" alt="环绕示意图"></p><h3 id="纹理环绕函数"><a href="#纹理环绕函数" class="headerlink" title="纹理环绕函数"></a>纹理环绕函数</h3><p>glTexParameteri (GLenum target, GLenum pname, GLint param);<br>参数: </p><blockquote><p>target: 指定纹理目标,若为2D纹理 则为 GL_TEXTURE_2D<br>pname: 对应的纹理坐标轴(这里 s,t,r 对应 x,y,z) GL_TEXTURE_WRAP_S ,GL_TEXTURE_WRAP_T<br>param: 环绕方式,填入上面的方式.</p></blockquote><p>对2D纹理时,必须对 s,t坐标轴都进行设置. 若是设置 GL_CLAMP_TO_BORDER 形式,则还需要额外设置 环绕颜色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float borderColor[] = &#123; 1.0f, 1.0f, 0.0f, 1.0f &#125;;</span><br><span class="line">glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br></pre></td></tr></table></figure><h2 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h2><p>纹理坐标是不依赖于 纹理大小和分辨率的, 1就表示纹理的边缘.但是物体和和纹理大小可能不一致,这就造成了对纹理的放大和拉伸.这时如何将纹理像素映射到纹理坐标上,就需要我们设置. 该属性就是 纹理过滤.</p><p>纹理过滤有很多种,下面是最重要的两种</p><h3 id="邻近过滤"><a href="#邻近过滤" class="headerlink" title="邻近过滤"></a>邻近过滤</h3><p>GL_NEAREST 是默认的纹理过滤方式,它会选择距离 纹理坐标最近的像素点作为样本颜色.当纹理被放大时,会有颗粒感<br><img src="/images/OpenGL ES on iOS --- 2D纹理/15119191609889.jpg" alt="临近过滤"></p><h3 id="线性过滤"><a href="#线性过滤" class="headerlink" title="线性过滤"></a>线性过滤</h3><p>GL_LINEAR, 会基于当前纹理坐标附近的像素点计算一个插值,也就是附近纹理的混合色,离得越近的像素点,颜色贡献越大,当纹理被放大时,会比临近过滤更平滑.<br><img src="/images/OpenGL ES on iOS --- 2D纹理/15119194640734.jpg" alt="线性过滤"><img src="/images/OpenGL ES on iOS --- 2D纹理/15119195201570.jpg" alt="临近过滤和线性过滤比较"></p><h3 id="过滤函数"><a href="#过滤函数" class="headerlink" title="过滤函数"></a>过滤函数</h3><p>我们需要对放大(Magnify)和缩小(Minify)的情况设置过滤效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure><h2 id="多级渐远纹理"><a href="#多级渐远纹理" class="headerlink" title="多级渐远纹理"></a>多级渐远纹理</h2><p>在3D世界,根据物体的远近不同,物体也存在缩放的效果,要显示不同的分辨率,若都使用相同的分辨率,一是会使物体产生不真实的效果,二是会造成内存的浪费. 在研究3D纹理时再说.~~</p><h1 id="纹理代码"><a href="#纹理代码" class="headerlink" title="纹理代码"></a>纹理代码</h1><p>首先是设置 上下文,着色器,程序对象…的方法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">context1 = [[EAGLContext alloc] initWithAPI:(kEAGLRenderingAPIOpenGLES3)];</span><br><span class="line">    BOOL isSetCOntextRight = [EAGLContext setCurrentContext:context1];</span><br><span class="line">    if (!isSetCOntextRight) &#123;</span><br><span class="line">        printf(&quot;设置Context失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSString* verStr = [[NSBundle mainBundle] pathForResource:@&quot;Texture2D_Vert.glsl&quot; ofType:nil];</span><br><span class="line">    NSString* fragStr = [[NSBundle mainBundle]pathForResource:@&quot;Texture2D_Frag.glsl&quot; ofType:nil];</span><br><span class="line"></span><br><span class="line">    program1 = createGLProgramFromFile(verStr.UTF8String, fragStr.UTF8String);</span><br><span class="line">    glUseProgram(program1);</span><br><span class="line"></span><br><span class="line">    //创建,绑定渲染缓存 并分配空间</span><br><span class="line">    glGenRenderbuffers(1, &amp;renderBuf1);</span><br><span class="line">    glBindRenderbuffer(GL_RENDERBUFFER, renderBuf1);</span><br><span class="line">    // 为 color renderbuffer 分配存储空间</span><br><span class="line">    [context1 renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer*)self.layer];</span><br><span class="line"></span><br><span class="line">    //创建,绑定帧缓存 并分配空间</span><br><span class="line">    glGenFramebuffers(1, &amp;frameBuf1);</span><br><span class="line">    // 设置为当前 framebuffer</span><br><span class="line">    glBindFramebuffer(GL_FRAMEBUFFER, frameBuf1);</span><br><span class="line">    // 将 _colorRenderBuffer 装配到 GL_COLOR_ATTACHMENT0 这个装配点上</span><br><span class="line">    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class="line">                              GL_RENDERBUFFER, renderBuf1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    glClearColor(1.0, 0.0, 0.0, 1.0);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    glViewport(0, 0, self.frame.size.width, self.frame.size.height);</span><br></pre></td></tr></table></figure><p>然后是 绘制物体的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">float verData[] = &#123;</span><br><span class="line">        // 位置              颜色                 纹理坐标</span><br><span class="line">        0.5f,0.5f,0.0f,     1.0f,0.0f,0.0f,     1.0f,1.0f,</span><br><span class="line">        0.5f,-0.5f,0.0f,    0.0f,1.0f,0.0f,     1.0f,0.0f,</span><br><span class="line">        -0.5f,-0.5f,0.0f,   0.0f,0.0f,1.0f,     0.0f,0.0f,</span><br><span class="line">        -0.5f,0.5f,0.0f,    1.0f,1.0f,0.0f,     0.0f,1.0f,</span><br><span class="line">    &#125;;</span><br><span class="line">    unsigned int indices[] = &#123;</span><br><span class="line">        0,1,3,</span><br><span class="line">        1,2,3</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    glGenVertexArrays(1, &amp;VAO1);</span><br><span class="line">    glGenBuffers(1, &amp;VBO1);</span><br><span class="line">    glGenBuffers(1, &amp;EBO1);</span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAO1);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO1);</span><br><span class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO1);</span><br><span class="line"></span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, sizeof(verData), verData, GL_STATIC_DRAW);</span><br><span class="line">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8*sizeof(float), (void*)0);</span><br><span class="line">    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8*sizeof(float), (void*)(3*sizeof(float)));</span><br><span class="line">    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8*sizeof(float), (void*)(6*sizeof(float)));</span><br><span class="line"></span><br><span class="line">    glEnableVertexAttribArray(0);</span><br><span class="line">    glEnableVertexAttribArray(1);</span><br><span class="line">    glEnableVertexAttribArray(2);</span><br></pre></td></tr></table></figure><h2 id="纹理设置"><a href="#纹理设置" class="headerlink" title="纹理设置~~"></a>纹理设置~~</h2><p>stbi_image 一个非常流行的单头文件图像加载库 <a href="https://github.com/nothings/stb/blob/master/stb_image.h" target="_blank" rel="external">stbi_image</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">//因为使用 stbi 函数导入的图片会颠倒,所以需要将其摆正</span><br><span class="line">stbi_set_flip_vertically_on_load(true);</span><br><span class="line"></span><br><span class="line">NSString* imPath = [[NSBundle mainBundle] pathForResource:@&quot;wall.jpg&quot; ofType:nil];</span><br><span class="line">int width,height,nrChannels;</span><br><span class="line"></span><br><span class="line">//加载图片</span><br><span class="line">unsigned char * imdata = stbi_load(imPath.UTF8String, &amp;width, &amp;height, &amp;nrChannels, 0);</span><br><span class="line"></span><br><span class="line">//创建 纹理</span><br><span class="line">unsigned int texture;</span><br><span class="line">glGenTextures(1, &amp;texture);</span><br><span class="line"></span><br><span class="line">//激活纹理单元0</span><br><span class="line">glActiveTexture(GL_TEXTURE0);</span><br><span class="line">//绑定纹理</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line">//将图像传入纹理</span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, imdata);</span><br><span class="line"></span><br><span class="line">//glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line"></span><br><span class="line">//设置纹理环绕和纹理过滤</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line"></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line">//将不用的图像释放</span><br><span class="line">stbi_image_free(imdata);</span><br><span class="line"></span><br><span class="line">//将纹理作为统一变量传入显存</span><br><span class="line">glUniform1i(glGetUniformLocation(program1, &quot;outTexture&quot;), 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//这里PNG格式 通过stbi_load 拉入时 会导致产生 BGRA格式(我也不大清楚原因,懂的朋友 告告我 先O(∩_∩)O谢谢了) ,这时 图片作为纹理显示时色彩会出错.所以将其转换一蛤~</span><br><span class="line">NSString* imPath1 = [[NSBundle mainBundle] pathForResource:@&quot;face.png&quot; ofType:nil];</span><br><span class="line">int width1,height1,nrChannels1;</span><br><span class="line">unsigned char * imdata1 = stbi_load(imPath1.UTF8String, &amp;width1, &amp;height1, &amp;nrChannels1, STBI_rgb_alpha);</span><br><span class="line">for (int i = 0; i&lt;width1*height1; i++ ) &#123;</span><br><span class="line">    char tR = imdata1[i*4+2];</span><br><span class="line">    imdata1[i*4+2] = imdata1[i*4];</span><br><span class="line">    imdata1[i*4] = tR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned int texture1;</span><br><span class="line"></span><br><span class="line">glGenTextures(1, &amp;texture1);</span><br><span class="line">glActiveTexture(GL_TEXTURE1);       //必须先写这个再绑定</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line"></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line"></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width1, height1, 0, GL_RGBA, GL_UNSIGNED_BYTE, imdata1);</span><br><span class="line">glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">stbi_image_free(imdata1);</span><br><span class="line"></span><br><span class="line">glUniform1i(glGetUniformLocation(program1, &quot;outTexture1&quot;), 1);</span><br><span class="line"></span><br><span class="line">//绘制显示</span><br><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</span><br><span class="line">[context1 presentRenderbuffer:GL_RENDERBUFFER];</span><br></pre></td></tr></table></figure><p>片段着色器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#version 300 es</span><br><span class="line"></span><br><span class="line">precision mediump float;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">in vec2 outTexCoord;</span><br><span class="line"></span><br><span class="line">uniform sampler2D outTexture;</span><br><span class="line">uniform sampler2D outTexture1;</span><br><span class="line"></span><br><span class="line">in vec3 outColor;</span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">FragColor = mix(texture(outTexture,outTexCoord),texture(outTexture1,outTexCoord),0.2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GLSL内建的mix函数需要接受两个值作为参数，并对它们根据第三个参数进行线性插值。如果第三个值是0.0，它会返回第一个输入；如果是1.0，会返回第二个输入值。0.2会返回80%的第一个输入颜色和20%的第二个输入颜色，即返回两个纹理的混合色。</p><h3 id="函数补充说明"><a href="#函数补充说明" class="headerlink" title="函数补充说明"></a>函数补充说明</h3><p>glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid* pixels);</p><blockquote><p>target 纹理目标 设置为GL_TEXTURE_2D意味着会生成与当前绑定的纹理对象在同一个目标上的纹理<br>level 为纹理指定多级渐远纹理的级别,0表示基本级别<br>internalformat 希望将纹理存储为何等格式<br>width height 图像宽高<br>border 设置为0 说是历史遗留问题<br>format 源图格式  type 数据格式<br>pixels 图像数据 </p></blockquote><h3 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h3><p>在代码中 使用 <code>glUniform1i</code>方法进行纹理传递 是因为 纹理单元 这个概念.<br>使用<code>glUniform1i</code>可以为纹理采样器分配一个位置值,通过把纹理单元赋值给采样器,就可以一次绑定多个纹理.</p><p>OpenGL至少保证有16个纹理单元供你使用，也就是说你可以激活从GL_TEXTURE0到GL_TEXTRUE15。它们都是按顺序定义的，所以我们也可以通过GL_TEXTURE0 + 8的方式获得GL_TEXTURE8，这在当我们需要循环一些纹理单元的时候会很有用。</p><p>需要注意的是 在绑定纹理时 <strong>先要激活纹理单元</strong>才可以</p><p>显示结果<br><img src="/images/OpenGL ES on iOS --- 2D纹理/Simulator%20Screen%20Shot%20-%20iPhone%20X%20-%202017-11-29%20at%2010.46.10.png" alt="GitHub" title="GitHub,Social Coding" width="375" height="667"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;纹理是用来丰富我们绘制物体细节的,它可以是一张2D图片(除了图像外,纹理也被用来存储大量数据,传递到着色器上),就像贴图一样贴在绘制的物体上
      
    
    </summary>
    
    
      <category term="Opengl ES" scheme="http://yoursite.com/tags/Opengl-ES/"/>
    
  </entry>
  
  <entry>
    <title>Opengl ES 3.0 on iOS--- 统一变量(Uniform)和统一变量块(UBO)</title>
    <link href="http://yoursite.com/2017/11/28/OpenGL%20ES%20on%20iOS%20---%20%E7%BB%9F%E4%B8%80%E5%8F%98%E9%87%8F(Uniform)%E5%92%8C%E7%BB%9F%E4%B8%80%E5%8F%98%E9%87%8F%E5%9D%97(UBO)/"/>
    <id>http://yoursite.com/2017/11/28/OpenGL ES on iOS --- 统一变量(Uniform)和统一变量块(UBO)/</id>
    <published>2017-11-28T02:46:18.000Z</published>
    <updated>2017-11-28T02:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。</p><blockquote><p>首先，uniform是<strong>全局</strong>的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。<br>第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</p></blockquote><h1 id="单独统一变量"><a href="#单独统一变量" class="headerlink" title="单独统一变量"></a>单独统一变量</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p><code>uniform vec3 color</code></p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//获取指定统一变量的location</span><br><span class="line">int vertexColorLocation = glGetUniformLocation(_program, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">//为vec3 的统一变量 赋值</span><br><span class="line">glUniform3f(vertexColorLocation, 0.0f, 1.0f, 0.0f);</span><br></pre></td></tr></table></figure><p>赋值函数是根据 统一变量类型的不同而调整的.其中函数名中包含数字（1、2、3、4）表示接受这个数字个用于更改uniform变量的值，i表示32位整形，f表示32位浮点型，ub表示8位无符号byte，ui表示32位无符号整形，v表示接受相应的指针类型(或者就是传入的是数组)。</p><blockquote><p><code>glUniform1f(GLint locaation,GLFloat x)</code> 表示 float类型<br><code>glUniform2f(GLint locaation,GLFloat x,GLFloat y)</code> 表示 二位向量 分量类型为float<br><code>glUniform1fv(GLint locaation,GLSize count,const GLfloat* value)</code> float类型指针<br><code>glUniformMatrix4x3(Glint location,GLsizei count,GLboolean transpose,const GLfloat* value)</code> 表示为 4x3矩阵. 参数: transpose 表示是否采用 行优先顺序(GL_TRUE)</p></blockquote><h1 id="UBO"><a href="#UBO" class="headerlink" title="UBO"></a>UBO</h1><p>UBO(Uniform Buffer Object)是用来存储着色语言中Uniform类型变量的<strong>缓冲区对象</strong>，使用UBO可以让uniform变量在不同的着色语言程序中实现共用，也可以在着色语言程序中实现uniform类型变量的设置与更新。</p><p>提到UBO就必须要提到着色语言GLSL中的Uniform Blocks，它将众多的Uniform类型的变量集中在一起进行统一的管理，对于需要大量Uniform类型变量的程序可以显著地提高性能。(有点像全局版的VBO)</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/images/OpenGL ES on iOS --UBO/15118303676115.jpg" alt="UBO示意图"></p><p>在显存中创建缓存对象(Buffer),在buffer中存储统一变量数据, 将Buffer与 指定的point绑定, 将统一变量缓冲区的索引 和 point绑定. 这样通过point 将变量 和 缓存 连接.</p><h2 id="设置UBO"><a href="#设置UBO" class="headerlink" title="设置UBO"></a>设置UBO</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//统一变量块</span><br><span class="line">layout (std140) uniform colorBlock&#123;</span><br><span class="line">    vec4 cc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">GLuint blockid,bufferid;</span><br><span class="line">GLint blocksize;</span><br><span class="line">GLint point = 1;</span><br><span class="line"></span><br><span class="line">// 统一变量数据</span><br><span class="line">GLfloat blockData[] = &#123;</span><br><span class="line">    1.0f,1.0f,1.0f,1.0f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//获取统一变量块索引</span><br><span class="line">blockid = glGetUniformBlockIndex(_program, &quot;colorBlock&quot;);</span><br><span class="line"></span><br><span class="line">//获取统一变量块大小</span><br><span class="line">glGetActiveUniformBlockiv(_program, blockid, GL_UNIFORM_BLOCK_DATA_SIZE, &amp;blocksize);</span><br><span class="line"></span><br><span class="line">//将变量索引 和 point 绑定</span><br><span class="line">glUniformBlockBinding(_program, blockid, point);</span><br><span class="line"></span><br><span class="line">//创建与绑定缓冲区</span><br><span class="line">glGenBuffers(1, &amp;bufferid);</span><br><span class="line">glBindBuffer(GL_UNIFORM_BUFFER, bufferid);</span><br><span class="line"></span><br><span class="line">//向缓冲区中赋值</span><br><span class="line">glBufferData(GL_UNIFORM_BUFFER, blocksize, blockData, GL_DYNAMIC_DRAW);</span><br><span class="line"></span><br><span class="line">//将UBO 和 point 绑定</span><br><span class="line">glBindBufferBase(GL_UNIFORM_BUFFER, point, bufferid);</span><br></pre></td></tr></table></figure><h2 id="修改UBO"><a href="#修改UBO" class="headerlink" title="修改UBO"></a>修改UBO</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GLfloat uploadData[] = &#123;</span><br><span class="line">    0.0f,0.0f,1.0f,1.0f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 绑定当然统一变量块的 buffer</span><br><span class="line">glBindBuffer(GL_UNIFORM_BUFFER, bufferid);</span><br><span class="line"></span><br><span class="line">//获取统一变量块 中 指定变量的 偏移量</span><br><span class="line">const GLchar *names[] = &#123;&quot;cc&quot;&#125;;</span><br><span class="line">GLuint indices[1];</span><br><span class="line">glGetUniformIndices(_program, 1, names, indices);</span><br><span class="line">GLint offset[1];</span><br><span class="line">glGetActiveUniformsiv(_program, 1, indices, GL_UNIFORM_OFFSET, offset);</span><br><span class="line">glBufferSubData(GL_UNIFORM_BUFFER, offset[0], blocksize, uploadData);</span><br></pre></td></tr></table></figure><h3 id="函数补充"><a href="#函数补充" class="headerlink" title="函数补充"></a>函数补充</h3><p>1, <code>glGetUniformIndices (GLuint program, GLsizei uniformCount, const GLchar* const *uniformNames, GLuint* uniformIndices)</code><br>该函数用于获取统一变量块中 变量们的索引 参数:</p><blockquote><p>program 程序对象<br>uniformCount 变量名称数组的元素数量<br>uniformNames 变量名称数组<br>uniformIndices 用于接受变量索引的数组</p></blockquote><p>2,<code>glGetActiveUniformsiv (GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params)</code><br>该函数用于 通过变量索引 查询变量信息. 参数:</p><blockquote><p>program 程序对象<br>uniformCount 变量数量<br>uniformIndices 变量索引数组<br>pname 表示要查询变量的那个属性 GL_UNIFORM_OFFSET(变量偏移量)  GL_UNIFORM_SIZE(变量大小) GL_UNIFORM_NAME_LENGTH(变量名长度) GL_UNIFORM_TYPE(变量类型)….<br>params 接受查询结果的数组</p></blockquote><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><h2 id="着色语言编译优化"><a href="#着色语言编译优化" class="headerlink" title="着色语言编译优化"></a>着色语言编译优化</h2><p>如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，导致最后编译出的版本中并不会包含它.</p><h2 id="UBO限定符"><a href="#UBO限定符" class="headerlink" title="UBO限定符"></a>UBO限定符</h2><p>在UBO中,针对不同的限定符 还存在不同的字节补齐的情况.所以获取偏移量,大小最好还是通过查询进行,避免自己计算出现错误.</p><p>这是 std140(标准统一变量块布局)限定符的内存分配情况:</p><p><img src="/images/OpenGL ES on iOS --UBO/screenshot.png" alt="std140"></p><p>其他的限定符 在我学了之后会补上~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。&lt;/p&gt;
&lt;blockquote&gt;
      
    
    </summary>
    
    
      <category term="Opengl ES" scheme="http://yoursite.com/tags/Opengl-ES/"/>
    
  </entry>
  
  <entry>
    <title>Opengl ES 3.0 on iOS -- EAGLContext</title>
    <link href="http://yoursite.com/2017/11/27/Opengl%20ES%203.0%20on%20iOS%20--%20EAGLContext/"/>
    <id>http://yoursite.com/2017/11/27/Opengl ES 3.0 on iOS -- EAGLContext/</id>
    <published>2017-11-27T06:44:17.000Z</published>
    <updated>2017-11-27T06:44:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>EAGLContext对象是管理OpenGL ES渲染上下文,若想使用OpenGL ES 进行绘制工作,则必须一个上下文对象.</p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (nullable instancetype) initWithAPI:(EAGLRenderingAPI) api;</span><br><span class="line">- (nullable instancetype) initWithAPI:(EAGLRenderingAPI) api sharegroup:(EAGLSharegroup*) sharegroup NS_DESIGNATED_INITIALIZER;</span><br></pre></td></tr></table></figure><p>参数:</p><blockquote><p>api 表示将要使用的OpenGL ES 版本. <code>kEAGLRenderingAPIOpenGLES3</code> 表示使用3.0</p><p>sharegroup 对象管理与一个或多个EAGLContext对象关联的OpenGL ES资源,若不指定或值为NULL则创建新的对象,当资源需要被共享时再使用它.</p></blockquote><h2 id="绑定上下文"><a href="#绑定上下文" class="headerlink" title="绑定上下文"></a>绑定上下文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)setCurrentContext:(nullable EAGLContext*) context;</span><br></pre></td></tr></table></figure><p>绑定一个<strong>全局</strong>的上下文对象. 注意: 1, 需要手动对该对象强引用,否则将会被释放. 2, 该对象线程不安全, 使用时应防止同时从多个线程访问同一个上下文对象</p><h2 id="分配渲染缓冲区"><a href="#分配渲染缓冲区" class="headerlink" title="分配渲染缓冲区"></a>分配渲染缓冲区</h2><p><code>- (BOOL)renderbufferStorage:(NSUInteger)target fromDrawable:(nullable id&lt;EAGLDrawable&gt;)drawable;</code><br>通过调用此方法为缓冲区分配共享的存储空间, 此方法是替代 原<code>glRenderbufferStorage</code>方法的.<br>参数:</p><blockquote><p>target :当前绑定的渲染缓冲区的OpenGL ES绑定点。 此参数的值必须是<strong>GL_RENDERBUFFER</strong>（或OpenGL ES 1.1上下文中的GL_RENDERBUFFER_OES）</p><p>drawable :管理渲染缓冲区的数据存储的对象。 在iOS中，此参数的值必须是<strong>CAEAGLLayer</strong>对象</p></blockquote><h2 id="显示缓冲区内容"><a href="#显示缓冲区内容" class="headerlink" title="显示缓冲区内容"></a>显示缓冲区内容</h2><p><code>- (BOOL)presentRenderbuffer:(NSUInteger)target;</code><br>将渲染缓冲区的内容展示在屏幕上.<br>参数: </p><blockquote><p>target : 当前绑定的渲染缓冲区的OpenGL ES绑定点。 此参数的值必须是<strong>GL_RENDERBUFFER</strong>（或OpenGL ES 1.1上下文中的GL_RENDERBUFFER_OES）。</p></blockquote><p>在典型的显示系统中,物理屏幕以固定的速率从帧缓冲区内存中更新,若我们直接绘制带帧缓冲区,那么用户在部分更新帧缓冲区时会看到伪像. 在OpenGL中采用双缓冲区, 分为 前缓冲区 和 后缓冲区.</p><p>所有的渲染都发生在后台缓冲区,它位于不可见于屏幕的内存区域,当所有渲染完成时,这个渲染将被 交换 到前台缓冲区用于显示, 然后原 前台缓冲区就下一帧的后台缓冲区</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;EAGLContext对象是管理OpenGL ES渲染上下文,若想使用OpenGL ES 进行绘制工作,则必须一个上下文对象.&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="Opengl ES" scheme="http://yoursite.com/tags/Opengl-ES/"/>
    
  </entry>
  
  <entry>
    <title>Opengl ES 3.0 on iOS--- HelloWord(绘制彩色矩形)</title>
    <link href="http://yoursite.com/2017/11/27/Opengl%20ES%203.0%20on%20iOS---%20HelloWord(%E7%BB%98%E5%88%B6%E5%BD%A9%E8%89%B2%E7%9F%A9%E5%BD%A2)/"/>
    <id>http://yoursite.com/2017/11/27/Opengl ES 3.0 on iOS--- HelloWord(绘制彩色矩形)/</id>
    <published>2017-11-27T06:43:38.000Z</published>
    <updated>2017-11-28T03:04:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文记录了我初学Opengl 绘制彩色矩形的过程,可能我对内容的描述不够准确,还请多多指正</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="配置图层"><a href="#配置图层" class="headerlink" title="配置图层"></a>配置图层</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+(Class)layerClass&#123;</span><br><span class="line">    return [CAEAGLLayer class];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将当前View的Layer替换成 <code>CAEAGLLayer</code>类,opengl的绘制内容也是在该View上显示的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置不透明度为YES,因为透明图层性能不好</span><br><span class="line">self.layer.opaque = YES;</span><br><span class="line">self.layer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:</span><br><span class="line">                                         [NSNumber numberWithBool:NO], kEAGLDrawablePropertyRetainedBacking, kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil];</span><br></pre></td></tr></table></figure><p>可以对<code>CAEAGLLayer</code>进行额外属性的配置:</p><blockquote><p>kEAGLDrawablePropertyRetainedBacking 传入布尔值,表示是否保持绘制状态,若设置为NO,则下次将重新绘制.<br>kEAGLDrawablePropertyColorFormat 设置layer的颜色缓冲区格式,EAGLContext对象 使用此格式来创建渲染缓冲区的存储.<br>kEAGLColorFormatRGB565 —&gt; 16bit RGB格式<br>kEAGLColorFormatRGBA8 —&gt; 32-bit RGBA格式</p></blockquote><h2 id="配置上下文"><a href="#配置上下文" class="headerlink" title="配置上下文"></a>配置上下文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];</span><br><span class="line">    if (!_context) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将当前上下文设置为我们创建的上下文</span><br><span class="line">    if (![EAGLContext setCurrentContext:_context]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置缓冲区-渲染缓冲和帧缓冲"><a href="#设置缓冲区-渲染缓冲和帧缓冲" class="headerlink" title="设置缓冲区(渲染缓冲和帧缓冲)"></a>设置缓冲区(渲染缓冲和帧缓冲)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//在缓冲区中返回n个渲染缓冲对象句柄,不保证这些句柄是连续的整数,但是肯定没有被使用.</span><br><span class="line">GLuint renderbuffer[1];</span><br><span class="line">glGenRenderbuffers(ARRAY_SIZE(renderbuffer), renderbuffer);</span><br><span class="line"></span><br><span class="line">//将缓冲区对象和句柄 绑定到指定的缓冲区目标.</span><br><span class="line">glBindRenderbuffer(GL_RENDERBUFFER, renderbuffer[0]);</span><br><span class="line"></span><br><span class="line">//检验是否创建绑定成功</span><br><span class="line">if (glIsRenderbuffer(renderbuffer[0]) == GL_TRUE) &#123;</span><br><span class="line">    NSLog(@&quot;成功生成渲染缓存&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//为缓冲区对象分配存储空间.</span><br><span class="line">[self.context renderbufferStorage:GL_RENDERBUFFER fromDrawable:layer];</span><br><span class="line"></span><br><span class="line">//设置帧缓冲区(Frame Buffer),和渲染缓冲区大致相同</span><br><span class="line">GLuint framebuffer[1];</span><br><span class="line">glGenFramebuffers(ARRAY_SIZE(framebuffer), framebuffer);</span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, framebuffer[0]);</span><br><span class="line">if (glIsFramebuffer(framebuffer[0]) == GL_TRUE) &#123;</span><br><span class="line">    NSLog(@&quot;成功绑定帧缓存&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将相关的buffer依附到 帧缓存上 </span><br><span class="line">glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, renderbuffer[0]);</span><br><span class="line"></span><br><span class="line">    //释放渲染缓存</span><br><span class="line">    //glDeleteRenderbuffers(ARRAY_SIZE(renderbuffer), renderbuffer);</span><br><span class="line">    //释放帧缓存</span><br><span class="line">    //glDeleteFramebuffers(ARRAY_SIZE(framebuffer), framebuffer);</span><br></pre></td></tr></table></figure><p>渲染缓存: 是OpenGL ES管理的一块高效内存区域,渲染缓存的数据只有关联一个帧缓存对象才有意义,并且需要保证图像缓存格式 必须与OpenGL ES要求的渲染格式相符.</p><p>帧缓存：它是屏幕所显示画面的一个直接映象，又称为位映射图(Bit Map)或光栅。帧缓存的每一存储单元对应屏幕上的一个像素，整个帧缓存对应一帧图像。</p><h3 id="函数解释"><a href="#函数解释" class="headerlink" title="函数解释"></a>函数解释</h3><p><code>glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, renderbuffer[0]);</code><br>参数:</p><blockquote><p>target: 指定的帧缓冲区目标 必须是 GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER, 或 GL_FRAMEBUFFER. (GL_FRAMEBUFFER = GL_DRAW_FRAMEBUFFER);<br>attachment: 帧缓存对象依附的目标 GL_COLOR_ATTACHMENT(0~i) —&gt; 第i个颜色缓存 0为默认值, GL_DEPTH_ATTACHMENT —&gt; 深度缓存, GL_STENCIL_ATTACHMENT —&gt; 模板缓存<br>renderbuffertarget :必须为 GL_RENDERBUFFER,指定的渲染缓存区目标<br>renderbuffer: 渲染缓冲区对象句柄.</p></blockquote><h2 id="准备着色器源码"><a href="#准备着色器源码" class="headerlink" title="准备着色器源码"></a>准备着色器源码</h2><p>OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的<strong>图形渲染管线</strong>.OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线</p><p><strong>着色器(Shader)</strong>是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。</p><p>着色器是使用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。</p><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#version 300 es //OpenGL ES 3.0</span><br><span class="line"></span><br><span class="line">//接受的输入变量</span><br><span class="line">layout(location = 0) in vec3 position;</span><br><span class="line">layout(location = 1) in vec3 color;</span><br><span class="line"></span><br><span class="line">//输出变量</span><br><span class="line">out vec3 outColor;</span><br><span class="line"></span><br><span class="line">//相当于C语言的main函数</span><br><span class="line">void main()</span><br><span class="line">&#123;   </span><br><span class="line">    //绘制图形</span><br><span class="line">    gl_Position = vec4(position[0],position[1],position[2], 1.0);</span><br><span class="line">    </span><br><span class="line">    outColor = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图形渲染管线的第一个部分是顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入.一个顶点(Vertex)是一个3D坐标的数据的集合。而顶点数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据.</p><h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#version 300 es</span><br><span class="line"></span><br><span class="line">precision mediump float;    //表示 数据精确度 这里设置的为中级</span><br><span class="line"></span><br><span class="line">in vec3 outColor;</span><br><span class="line"></span><br><span class="line">out vec4 FragColor; //输出的色彩</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = vec4(outColor.x,outColor.y,outColor.z, 1.0);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算<strong>最终像素的颜色</strong>。</p><p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做<strong>Alpha测试</strong>和<strong>混合(Blending)阶段</strong>。这个阶段检测片段的对应的深度（和模板(Stencil)）值，用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p><h2 id="创建着色器对象"><a href="#创建着色器对象" class="headerlink" title="创建着色器对象"></a>创建着色器对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">static GLuint createGLShader(const char *shaderText, GLenum shaderType)</span><br><span class="line">&#123;</span><br><span class="line">    //创建着色器,将根据传入的type参数 创建一个新的 顶点或片段着色器,返回值为新的着色器对象句柄</span><br><span class="line">    //GL_VERTEX_SHADER(顶点着色器)     GL_FRAGMENT_SHADER(片段着色器)</span><br><span class="line">    GLuint shader = glCreateShader(shaderType);</span><br><span class="line"></span><br><span class="line">    //为着色器对象 提供着色器源代码.</span><br><span class="line">    //参数: shader --&gt; 着色器对象句柄</span><br><span class="line">    //      count --&gt; 着色器源字符串数量</span><br><span class="line">    //      string --&gt; 字符串的数组指针</span><br><span class="line">    //      length ---&gt; 指向保存美工着色器字符串大小且元素数量为count的整数数组指针.如果length为NULL 着色器字符串将被认定为空.</span><br><span class="line">    glShaderSource(shader, 1, &amp;shaderText, NULL);</span><br><span class="line"></span><br><span class="line">    //调用该方法,将指定的着色器源代码 进行编译</span><br><span class="line">    //参数shader 为着色器句柄</span><br><span class="line">    glCompileShader(shader);</span><br><span class="line"></span><br><span class="line">    //调用该方法获取 着色器源代码编译是否成功,并获取其他相关信息</span><br><span class="line">    //第二个参数 pname 表示要查询什么信息</span><br><span class="line">    /*</span><br><span class="line">     GL_COMPILE_STATUS ---&gt; 是否编译成功 成功返回 GL_TRUE</span><br><span class="line">     GL_INFO_LOG_LENGTH ---&gt; 查询源码编译后长度</span><br><span class="line">     GL_SHADER_SOURCE_LENGTH ---&gt; 查询源码长度</span><br><span class="line">     GL_SHADER_TYPE ---&gt; 查询着色器类型()</span><br><span class="line">     GL_DELETE_STATUS ---&gt; 着色器是否被标记删除</span><br><span class="line">     */</span><br><span class="line">    int compiled = 0;</span><br><span class="line">    glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;compiled);</span><br><span class="line">    if (!compiled) &#123;</span><br><span class="line">        GLint infoLen = 0;</span><br><span class="line">        glGetShaderiv (shader, GL_INFO_LOG_LENGTH, &amp;infoLen);</span><br><span class="line">        if (infoLen &gt; 1) &#123;</span><br><span class="line">            char *infoLog = (char *)malloc(sizeof(char) * infoLen);</span><br><span class="line">            if (infoLog) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                //检索信息日志</span><br><span class="line">                //参数: shader 着色器对象句柄</span><br><span class="line">                //      maxLength 保存信息日志的缓冲区大小</span><br><span class="line">                //      length 写入信息日志长度 ,不需要知道可传NULL</span><br><span class="line">                //      infoLog 保存日志信息的指针</span><br><span class="line">                glGetShaderInfoLog (shader, infoLen, NULL, infoLog);</span><br><span class="line">                GLlog(&quot;Error compiling shader: %s\n&quot;, infoLog);</span><br><span class="line">                free(infoLog);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //删除着色器对象, 参数shader为要删除的着色器对象的句柄</span><br><span class="line">        //若一个着色器链接到一个程序对象,那么该方法不会立刻删除着色器,而是将着色器标记为删除,当着色器不在连接到任何程序对象时,它的内存将被释放.</span><br><span class="line">        glDeleteShader(shader);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return shader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建程序对象"><a href="#创建程序对象" class="headerlink" title="创建程序对象"></a>创建程序对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个程序对象,返回程序对象的句柄</span><br><span class="line">   GLuint program = glCreateProgram();</span><br><span class="line"></span><br><span class="line">   // 得到需要的着色器</span><br><span class="line">   GLuint vertShader = createGLShader(vertext, GL_VERTEX_SHADER);  //顶点着色器</span><br><span class="line">   GLuint fragShader = createGLShader(frag, GL_FRAGMENT_SHADER);   //片元着色器</span><br><span class="line">   </span><br><span class="line">   if (vertShader == 0 || fragShader == 0) &#123;</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //将程序对象和 着色器对象链接  //在ES 3.0中,每个程序对象 必须连接一个顶点着色器和片段着色器</span><br><span class="line">   //program程序对象句柄 shader着色器句柄</span><br><span class="line">   glAttachShader(program, vertShader);</span><br><span class="line">   glAttachShader(program, fragShader);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   //链接程序对象 生成可执行程序(在着色器已完成编译 且程序对象连接了着色器)</span><br><span class="line">   //链接程序会检查各种对象的数量,和各种条件.</span><br><span class="line">   //在链接阶段就是生成最终硬件指令的时候(和C语言一样)</span><br><span class="line">   glLinkProgram(program);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   //检查链接是否成功</span><br><span class="line">   GLint success;</span><br><span class="line">   glGetProgramiv(program, GL_LINK_STATUS, &amp;success);</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   if (!success) &#123;</span><br><span class="line">       GLint infoLen;</span><br><span class="line">       //使用 GL_INFO_LOG_LENGTH 表示获取信息日志</span><br><span class="line">       glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;infoLen);</span><br><span class="line">       if (infoLen &gt; 1) &#123;</span><br><span class="line">           GLchar *infoText = (GLchar *)malloc(sizeof(GLchar)*infoLen + 1);</span><br><span class="line">           if (infoText) &#123;</span><br><span class="line">               memset(infoText, 0x00, sizeof(GLchar)*infoLen + 1);</span><br><span class="line"></span><br><span class="line">               // 从信息日志中获取信息</span><br><span class="line">               glGetProgramInfoLog(program, infoLen, NULL, infoText);</span><br><span class="line">               GLlog(&quot;%s&quot;, infoText);</span><br><span class="line">               free(infoText);</span><br><span class="line"></span><br><span class="line">               //此函数用于校验当前的程序对象,校验结果可通过 glGetProgramiv函数检查,此函数只用于调试,因为他很慢.</span><br><span class="line">               //glValidateProgram(program);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       glDeleteShader(vertShader);</span><br><span class="line">       glDeleteShader(fragShader);</span><br><span class="line"></span><br><span class="line">       //删除程序对象</span><br><span class="line">       glDeleteProgram(program);</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   /*</span><br><span class="line">* 链接完着色器,生成可执行程序. 将着色器断开删除</span><br><span class="line">*/</span><br><span class="line">   //断开指定程序对象和片段着色器</span><br><span class="line">   glDetachShader(program, vertShader);</span><br><span class="line">   glDetachShader(program, fragShader);</span><br><span class="line"></span><br><span class="line">   //将着色器标记为删除</span><br><span class="line">   glDeleteShader(vertShader);</span><br><span class="line">   glDeleteShader(fragShader);</span><br></pre></td></tr></table></figure><p>程序对象就是一个容器对象,将着色器与之连接,最后链接生成最终的可执行程序.</p><h2 id="输入顶点数据"><a href="#输入顶点数据" class="headerlink" title="输入顶点数据"></a>输入顶点数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//三角形的三点坐标+颜色坐标</span><br><span class="line">static GLfloat vertices[] = &#123;</span><br><span class="line">    //点坐标                     //颜色</span><br><span class="line">    0.5f,  0.5f, 0.0f,          1.0f, 0.0f, 0.0f,</span><br><span class="line">    0.5f, -0.5f, 0.0f,          0.0f, 1.0f, 0.0f,</span><br><span class="line">    -0.5f, -0.5f, 0.0f,         0.0f, 0.0f, 1.0f,</span><br><span class="line">    -0.5f, 0.5f, 0.0f,          1.0f, 0.0f, 1.0f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static unsigned int indices[] = &#123;</span><br><span class="line">    0,1,3,</span><br><span class="line">    1,2,3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unsigned int VAO,VBO,EBO;</span><br><span class="line">//创建VAO对象,VBO对象,EBO对象</span><br><span class="line">glGenVertexArrays(1, &amp;VAO);</span><br><span class="line">glGenBuffers(1, &amp;VBO);</span><br><span class="line">glGenBuffers(1, &amp;EBO);</span><br><span class="line"></span><br><span class="line">//绑定VAO VBO EBO</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line"></span><br><span class="line">将顶点数据 和 索引数据 复制到缓冲区中</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">//设置顶点属性指针 输入数据</span><br><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6*sizeof(float), (void*)0);</span><br><span class="line">//激活 0号变量,为了性能,若不激活着色器无法接受数据</span><br><span class="line">glEnableVertexAttribArray(0);</span><br><span class="line"></span><br><span class="line">glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6*sizeof(float), (void*)(3*sizeof(float)));</span><br><span class="line">glEnableVertexAttribArray(1);</span><br><span class="line">glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6*sizeof(float), (void*)(3*sizeof(float)));</span><br><span class="line">glEnableVertexAttribArray(1);</span><br></pre></td></tr></table></figure><h3 id="VAO-VBO-EBO"><a href="#VAO-VBO-EBO" class="headerlink" title="VAO VBO EBO"></a>VAO VBO EBO</h3><p>不使用VAO VBO绘制代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static GLfloat vertices[] = &#123;</span><br><span class="line">    0.0f,  0.5f, 0.0f,</span><br><span class="line">    -0.5f, -0.5f, 0.0f,</span><br><span class="line">    0.5f, -0.5f, 0.0f</span><br><span class="line">&#125;;</span><br><span class="line">GLint posSlot = glGetAttribLocation(_program, &quot;position&quot;);</span><br><span class="line">glVertexAttribPointer(posSlot, 3, GL_FLOAT, GL_FALSE, 0, vertices);</span><br><span class="line">glEnableVertexAttribArray(posSlot);</span><br><span class="line"></span><br><span class="line">static GLfloat colors[] = &#123;</span><br><span class="line">    0.0f, 1.0f, 1.0f,</span><br><span class="line">    1.0f, 0.0f, 1.0f,</span><br><span class="line">    1.0f, 1.0f, 0.0f</span><br><span class="line">&#125;;</span><br><span class="line">GLint colorSlot = glGetAttribLocation(_program, &quot;color&quot;);</span><br><span class="line">glVertexAttribPointer(colorSlot, 3, GL_FLOAT, GL_FALSE, 0, colors);</span><br><span class="line">glEnableVertexAttribArray(colorSlot);</span><br></pre></td></tr></table></figure><h4 id="VBO"><a href="#VBO" class="headerlink" title="VBO"></a>VBO</h4><p>如上面的例子所示, 普通的顶点数组的传输，需要在绘制的时候频繁地从CPU到GPU传输顶点数据，这种做法效率低下.<br>为了加快显示速度，显卡增加了一个扩展 <strong>VBO</strong> (Vertex Buffer object)，即<strong>顶点缓存</strong>。它直接在 <strong>GPU 中开辟一个缓存区</strong>域来存储顶点数据，因为它是用来缓存储顶点数据，因此被称之为顶点缓存。使用顶点缓存能够大大较少了CPU到GPU 之间的数据拷贝开销，因此显著地提升了程序运行的效率。</p><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>1, 创建顶点缓存对象<br><code>void glGenBuffers (GLsizei n, GLuint* buffers);</code></p><blockquote><p>参数 n ： 表示需要创建顶点缓存对象的个数<br>参数 buffers ：用于存储创建好的顶点缓存对象句柄</p></blockquote><p>2, 将顶点缓存对象设置为当前数组缓存对象<br><code>void glBindBuffer (GLenum target, GLuint buffer);</code></p><blockquote><p>target ：指定绑定的目标，取值为 GL_ARRAY_BUFFER（用于顶点数据） 或 GL_ELEMENT_ARRAY_BUFFER（用于索引数据）<br>buffer ：顶点缓存对象句柄</p></blockquote><p>3, 为顶点缓存对象分配空间(这里就是将数据一次性 拷贝至显存中)<br><code>void glBufferData (GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage);</code></p><blockquote><p>target：指定绑定的目标，取值为 GL_ARRAY_BUFFER（用于顶点数据） 或 GL_ELEMENT_ARRAY_BUFFER（用于索引数据）.<br>size ：指定顶点缓存区的大小，以字节为单位计数；<br>data ：用于初始化顶点缓存区的数据，可以为 NULL，表示只分配空间，之后再由 glBufferSubData 进行初始化；<br>usage ：表示该缓存区域将会被如何使用，它的主要目的是用于对该缓存区域做何种程度的优化，比如经常修改的数据可能就会放在GPU缓存中达到快速操作的目的.</p></blockquote><p>usage:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GL_STATIC_DRAW 表示该缓存区不会被修改</span><br><span class="line">GL_DYNAMIC_DRAW 表示该缓存区会被周期性更改</span><br><span class="line">GL_STREAM_DRAW 表示该缓存区会被频繁更改</span><br></pre></td></tr></table></figure></p><p>4,更新顶点缓冲区数据<br><code>void glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data);</code></p><blockquote><p>offset: 表示需要更新的数据的起始偏移量；<br>size: 表示需要更新的数据的个数，也是以字节为计数单位；<br>data: 用于更新的数据；</p></blockquote><p>5,释放顶点缓存<br><code>void glDeleteBuffers (GLsizei n, const GLuint* buffers);</code></p><blockquote><p>n ： 表示顶点缓存对象的个数<br>buffers ：顶点缓存对象句柄</p></blockquote><h4 id="VAO"><a href="#VAO" class="headerlink" title="VAO"></a>VAO</h4><p>VAO的全名是 Vertex Array Object。它不用作存储数据，但它与顶点绘制相关。<br>它的定位是<strong>状态对象</strong>，记录存储状态信息。VAO记录的是一次绘制中做需要的信息，这包括数据在哪里、数据格式是什么等信息。VAO其实可以看成一个容器，可以包括多个VBO。 由于它进一步将VBO容于其中，所以绘制效率将在VBO的基础上更进一步。目前OpenGL ES3.0及以上才支持顶点数组对象。</p><p><img src="/images/OpenglES--绘制彩色矩形/15117525484339.jpg" alt="VBO和VAO关系"></p><h5 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h5><p>1, 创建顶点数组对象<br><code>glGenVertexArrays (GLsizei n, GLuint* arrays) ;</code></p><blockquote><p>n ： 表示顶点数组对象的个数<br>arrays ：顶点数组对象句柄</p></blockquote><p>2, 将顶点数组对象设置为当前顶点数组对象<br><code>glBindVertexArray (GLuint array) ;</code></p><blockquote><p>arrays ：顶点数组对象句柄</p></blockquote><p>3,释放顶点数组对象<br><code>glDeleteVertexArrays (GLsizei n, const GLuint* arrays);</code></p><blockquote><p>n ： 表示顶点数组对象的个数<br>arrays ：顶点数组对象句柄</p></blockquote><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>如代码中所写,在绑定VAO后,后续的VBO操作都会存储到当前绑定的VAO中.这样就将当前绘制状态记录下来了. 当下次还要绘制当前图形时, 只需再次绑定当前VAO, 进行后面的绘制操作即可.对于OpenGL ES2.0 使用VAO 则需要使用另外提供的API来实现.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GLvoid glGenVertexArraysOES(GLsizei n, GLuint *arrays)</span><br><span class="line">GLvoid glBindVertexArrayOES(GLuint array);</span><br><span class="line">GLvoid glDeleteVertexArraysOES(GLsizei n, const GLuint *arrays);; </span><br><span class="line">GLboolean glIsVertexArrayOES(GLuint array);</span><br></pre></td></tr></table></figure><h4 id="EBO"><a href="#EBO" class="headerlink" title="EBO"></a>EBO</h4><p>索引缓冲对象(Element Buffer Object，EBO，也叫Index Buffer Object，IBO),当绘制现有图形时,存在顶点数据复用时,可以使用EBO. 但是这是需要斟酌的,因为在使用EBO时,在显存中 又存储的索引数据,有可能并不比原来性能更好~</p><h5 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h5><p>1,创建EBO(和VBO类似)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int EBO;</span><br><span class="line">glGenBuffers(1, &amp;EBO);</span><br></pre></td></tr></table></figure><p>2,绑定EBO,将索引复制到缓冲里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>3, 使用<code>glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</code>替代<code>glDrawArrays</code></p><h3 id="函数补充"><a href="#函数补充" class="headerlink" title="函数补充"></a>函数补充</h3><p><code>glVertexAttribPointer (GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* ptr)</code></p><p>该函数用于将顶点属性传入顶点着色器<br>参数:</p><blockquote><p>index: 对应顶你个点着色器中变量的location<br>size :表示该顶点属性对应的分量数量.也就是接收者为几位向量 如写入3 则表示为<code>vec3</code> 接收者为3维向量. 必须是 1~4.<br>type :表明每个分量的类型 可用的符号常量有<code>GL_BYTE</code>, <code>GL_UNSIGNED_BYTE</code>, <code>GL_SHORT</code>,<code>GL_UNSIGNED_SHORT</code>, <code>GL_FIXED</code>, 和 <code>GL_FLOAT</code>，初始值为<code>GL_FLOAT</code>；<br>normalized: 是否对每个分量进行归一化处理, 也就是若type为float类型.<br>stride:指定连续顶点属性之间的偏移量,如果设置0,则表示各个分量是紧密排在一起,中间没有其他多余数据.<br>ptr 顶点数据指针</p></blockquote><p>此函数在有无VBO的情况下,使用有所差异~,在不适用VBO时,ptr确实是顶点数据指针.<br>当使用VBO时,顶点数据都已经拷贝至显存中,这里的ptr 就表示为缓冲区数据的便宜量了.</p><p>无EBO:<br><code>glVertexAttribPointer(colorSlot, 3, GL_FLOAT, GL_FALSE, 0, colors);</code></p><p>有EBO:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static GLfloat vertices[] = &#123;</span><br><span class="line">            //点坐标                     //颜色</span><br><span class="line">            0.5f,  0.5f, 0.0f,          1.0f, 0.0f, 0.0f,</span><br><span class="line">            0.5f, -0.5f, 0.0f,          0.0f, 1.0f, 0.0f,</span><br><span class="line">            -0.5f, -0.5f, 0.0f,         0.0f, 0.0f, 1.0f,</span><br><span class="line">            -0.5f, 0.5f, 0.0f,          1.0f, 0.0f, 1.0f</span><br><span class="line">        &#125;;</span><br><span class="line">.......(VBO与其他代码).......</span><br><span class="line"></span><br><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6*sizeof(float), (void*)0);</span><br><span class="line">glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6*sizeof(float), (void*)(3*sizeof(float)));</span><br></pre></td></tr></table></figure><p>在这里0号属性和1号属性紧密相连,且0号和1号的分量数都为3,以0号属性开头.<br>故: 第一个0号和第二个0号 中间有6个间距 stride = 6<em>sizeof(float).<br>1号在0号后面, 0号ptr为 `(void</em>)0<code>. 1号ptr为</code>(void<em> )(3</em>sizeof(float))`</p><h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><h3 id="使用-EBO"><a href="#使用-EBO" class="headerlink" title="使用 EBO:"></a>使用 EBO:</h3><p><code>glDrawElements(GL_TRIANGLE_STRIP, 6, GL_UNSIGNED_INT, 0);</code><br>参数:<br> model:指定呈现那种图元(将这些点绘制成怎样的形状). 可选项:</p><blockquote><p>GL_POINTS(点),<br>GL_LINE_STRIP(多端线),<br>GL_LINE_LOOP(线圈),<br>GL_LINES(线段),<br>GL_TRIANGLE_FAN, (三角形扇)<br>GL_TRIANGLES, (三角形)<br>count: 传入顶点数据的数量<br>type: 索引数组的元素属性 <code>GL_UNSIGNED_BYTE</code>, <code>GL_UNSIGNED_SHORT</code>, or <code>GL_UNSIGNED_INT</code>.<br>indices: 指向索引数组的指针, 当使用VBO时,则表示为偏移量,若为紧密相连时则传入0.</p></blockquote><h3 id="不使用EBO"><a href="#不使用EBO" class="headerlink" title="不使用EBO"></a>不使用EBO</h3><p><code>glDrawArrays(GL_TRIANGLES, 0, 3);</code><br>参数: model 和上面那个含义一样.<br>     first 表示顶点数据起始索引, 从头开始则为0.<br>     count 表示要传入顶点数据的数量.</p><h3 id="最后显示"><a href="#最后显示" class="headerlink" title="最后显示"></a>最后显示</h3><p><code>[_context presentRenderbuffer:GL_RENDERBUFFER];</code></p><h1 id="学习参考"><a href="#学习参考" class="headerlink" title="学习参考"></a>学习参考</h1><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/" target="_blank" rel="external">你好三角形</a><br><a href="http://www.jianshu.com/c/30e2e76bc140" target="_blank" rel="external">OpenGL 简书专题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;本文记录了我初学Opengl 绘制彩色矩形的过程,可能我对内容的描述不够准确,还请多多指正&lt;/p&gt;
&lt;h1 id=&quot;实现&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="Opengl ES" scheme="http://yoursite.com/tags/Opengl-ES/"/>
    
  </entry>
  
  <entry>
    <title>YYAsyncLayer 学习</title>
    <link href="http://yoursite.com/2017/11/23/YYAsyncLayer%20%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2017/11/23/YYAsyncLayer 学习/</id>
    <published>2017-11-23T05:27:19.000Z</published>
    <updated>2017-12-13T12:59:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="YYAsyncLayer-学习"><a href="#YYAsyncLayer-学习" class="headerlink" title="YYAsyncLayer 学习"></a>YYAsyncLayer 学习</h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>YYAsyncLayer是用于图层异步绘制的一个组件,将耗时操作(如文本布局计算)放在RunLoop空闲时去做,进而减少卡顿.</p><h1 id="组件内容"><a href="#组件内容" class="headerlink" title="组件内容"></a>组件内容</h1><p>YYAsyncLayer主要有3个类.</p><blockquote><p>1, <strong>YYTransaction</strong>,负责将 YYAsyncLayer委托的绘制任务在RunLoop空闲时执行.</p><p>2, <strong>YYSentine</strong>, 是一个线程安全的计数器,在进行队列分配和任务取消时作为参考使用</p><p>3, <strong>YYAsyncLayer</strong>, 将其替换为View的Layer类,实现异步绘制</p></blockquote><h2 id="YYTransaction"><a href="#YYTransaction" class="headerlink" title="YYTransaction"></a>YYTransaction</h2><p><code>+ (YYTransaction *)transactionWithTarget:(id)target selector:(SEL)selector;</code>方法创建委托对象.</p><p><code>- (void)commit;</code>方法将委托对象存储在一个全局Set中,在空闲时回调.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void YYTransactionSetup() &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        transactionSet = [NSMutableSet new];</span><br><span class="line">        CFRunLoopRef runloop = CFRunLoopGetMain();</span><br><span class="line">        CFRunLoopObserverRef observer;</span><br><span class="line"></span><br><span class="line">        observer = CFRunLoopObserverCreate(CFAllocatorGetDefault(),</span><br><span class="line">                                           kCFRunLoopBeforeWaiting | kCFRunLoopExit,</span><br><span class="line">                                           true,      // repeat</span><br><span class="line">                                           0xFFFFFF,  // after CATransaction(2000000)</span><br><span class="line">                                           YYRunLoopObserverCallBack, NULL);</span><br><span class="line">        CFRunLoopAddObserver(runloop, observer, kCFRunLoopCommonModes);</span><br><span class="line">        CFRelease(observer);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空闲回调block</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 因为该对象还要被存放至集合中,当子类实现了isEqual方法时,则同时也要实现 hash方法.</span><br><span class="line"></span><br><span class="line">- (NSUInteger)hash &#123;</span><br><span class="line">    long v1 = (long)((void *)_selector);</span><br><span class="line">    long v2 = (long)_target;</span><br><span class="line">    return v1 ^ v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isEqual:(id)object &#123;</span><br><span class="line">    if (self == object) return YES;</span><br><span class="line">    if (![object isMemberOfClass:self.class]) return NO;</span><br><span class="line">    YYTransaction *other = object;</span><br><span class="line">    return other.selector == _selector &amp;&amp; other.target == _target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里重载 isEqual方法,确保不会将具有相同target和selector的委托对象放入Set中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static NSMutableSet *transactionSet = nil;</span><br><span class="line"></span><br><span class="line">static void YYRunLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123;</span><br><span class="line">    if (transactionSet.count == 0) return;</span><br><span class="line">    NSSet *currentSet = transactionSet;</span><br><span class="line">    transactionSet = [NSMutableSet new];</span><br><span class="line">    [currentSet enumerateObjectsUsingBlock:^(YYTransaction *transaction, BOOL *stop) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line"></span><br><span class="line">        [transaction.target performSelector:transaction.selector];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建唯一的 <strong>主线程 RunLoop观察者</strong>,在RunLoop进入kCFRunLoopBeforeWaiting 或 退出时 将委托方法调用.</p><h2 id="YYSentine"><a href="#YYSentine" class="headerlink" title="YYSentine"></a>YYSentine</h2><p>YYSentine的实现比较简单,主要是对 <code>OSAtomicIncrement32()</code> 函数的封装, 改函数为一个线程安全的计数器, 它会会保证在 数自增后再对其访问, 在这个框架里他是用来 作为绘制任务是否被取消的参照物的~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;YYSentinel.h&quot;</span><br><span class="line">#import &lt;libkern/OSAtomic.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation YYSentinel &#123;</span><br><span class="line">    int32_t _value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int32_t)value &#123;</span><br><span class="line">    return _value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int32_t)increase &#123;</span><br><span class="line">    return OSAtomicIncrement32(&amp;_value);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="YYAsyncLayer"><a href="#YYAsyncLayer" class="headerlink" title="YYAsyncLayer"></a>YYAsyncLayer</h2><h3 id="队列准备"><a href="#队列准备" class="headerlink" title="队列准备"></a>队列准备</h3><figure class="highlight plain"><figcaption><span>dispatch_queue_t YYAsyncLayerGetDisplayQueue() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#ifdef YYDispatchQueuePool_h</span><br><span class="line">    return YYDispatchQueueGetForQOS(NSQualityOfServiceUserInitiated);</span><br><span class="line">#else</span><br><span class="line">#define MAX_QUEUE_COUNT 16</span><br><span class="line">    static int queueCount;</span><br><span class="line">    static dispatch_queue_t queues[MAX_QUEUE_COUNT];</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    static int32_t counter = 0;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">        //queueCount = 运行该进程的系统的处于激活状态的处理器数量,</span><br><span class="line">        queueCount = (int)[NSProcessInfo processInfo].activeProcessorCount;</span><br><span class="line">        //确保 0&lt;queueCount&lt;16</span><br><span class="line">        queueCount = queueCount &lt; 1 ? 1 : queueCount &gt; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount;</span><br><span class="line"></span><br><span class="line">        //创建指定数量的 串行队列 存放在队列数组中</span><br><span class="line">        if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0) &#123;</span><br><span class="line">            for (NSUInteger i = 0; i &lt; queueCount; i++) &#123;</span><br><span class="line">                dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, 0);</span><br><span class="line">                queues[i] = dispatch_queue_create(&quot;com.ibireme.yykit.render&quot;, attr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (NSUInteger i = 0; i &lt; queueCount; i++) &#123;</span><br><span class="line">                queues[i] = dispatch_queue_create(&quot;com.ibireme.yykit.render&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">                dispatch_set_target_queue(queues[i], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 此为线程安全的自增计数,每调用一次,+1</span><br><span class="line">    int32_t cur = OSAtomicIncrement32(&amp;counter);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;cur:%d counter:%d&quot;,cur,counter);</span><br><span class="line"></span><br><span class="line">    //返回合适的队列</span><br><span class="line">    if (cur &lt; 0) cur = -cur;</span><br><span class="line">    return queues[(cur) % queueCount];</span><br><span class="line">#undef MAX_QUEUE_COUNT</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备若干的串行队列~,将绘制任务分给不同的串行队列, 这里之所以 队列数 和 处理器数 匹配. 不创建过多无效队列.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 释放队列</span><br><span class="line">static dispatch_queue_t YYAsyncLayerGetReleaseQueue() &#123;</span><br><span class="line">#ifdef YYDispatchQueuePool_h</span><br><span class="line">    return YYDispatchQueueGetForQOS(NSQualityOfServiceDefault);</span><br><span class="line">#else</span><br><span class="line">    return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>低优先级的全局队列作为 对象的释放队列,</p><h3 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h3><p>YYAsyncLayer的代理方法需要返回一个 DisplayTask对象, 任务对象中包括3个block.分别为willDisplay , display , didDisplay.在绘制的不同阶段执行</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    static CGFloat scale; //global</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        scale = [UIScreen mainScreen].scale;</span><br><span class="line">    &#125;);</span><br><span class="line">    self.contentsScale = scale;</span><br><span class="line">    //默认异步,每个图层都配置一个计数器</span><br><span class="line">    _sentinel = [YYSentinel new];</span><br><span class="line">    _displaysAsynchronously = YES;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//dealloc时 取消绘制</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [_sentinel increase];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在再次绘制时,取消上次绘制任务</span><br><span class="line">- (void)setNeedsDisplay &#123;</span><br><span class="line">    [self _cancelAsyncDisplay];</span><br><span class="line">    [super setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line">- (void)display &#123;</span><br><span class="line">    //这个我看不懂~为啥要再赋值一遍</span><br><span class="line">    super.contents = super.contents;</span><br><span class="line">    [self _displayAsync:_displaysAsynchronously];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制方法"><a href="#绘制方法" class="headerlink" title="绘制方法"></a>绘制方法</h3><h4 id="没有绘制任务"><a href="#没有绘制任务" class="headerlink" title="没有绘制任务"></a>没有绘制任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!task.display) &#123;</span><br><span class="line">    if (task.willDisplay) task.willDisplay(self);</span><br><span class="line">    self.contents = nil;</span><br><span class="line">    if (task.didDisplay) task.didDisplay(self, YES);</span><br><span class="line">    ///执行完其他非空block后 返回</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异步绘制"><a href="#异步绘制" class="headerlink" title="异步绘制"></a>异步绘制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">if (task.willDisplay) task.willDisplay(self);</span><br><span class="line">  YYSentinel *sentinel = _sentinel;</span><br><span class="line"></span><br><span class="line">  int32_t value = sentinel.value;</span><br><span class="line"></span><br><span class="line">  //判断是否要取消的block, 在图层的dealloc方法,取消绘制方法中 和 同步绘制方法中 进行线程安全的自增操作. 在调用该block时 若block截取的变量value与对象中value中的值不一致时,则表明当前任务以被取消</span><br><span class="line">  BOOL (^isCancelled)(void) = ^BOOL() &#123;</span><br><span class="line">      return value != sentinel.value;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  CGSize size = self.bounds.size;</span><br><span class="line">  BOOL opaque = self.opaque;</span><br><span class="line">  CGFloat scale = self.contentsScale;</span><br><span class="line"></span><br><span class="line">  // 当图层宽度 或 高度小于 1时 (此时没有绘制意义)</span><br><span class="line">  if (size.width &lt; 1 || size.height &lt; 1) &#123;</span><br><span class="line">      CGImageRef image = (__bridge_retained CGImageRef)(self.contents);</span><br><span class="line">      self.contents = nil;</span><br><span class="line"></span><br><span class="line">      //当图层内容为图像时,讲释放操作留在 并行释放队列中进行</span><br><span class="line">      if (image) &#123;</span><br><span class="line">          dispatch_async(YYAsyncLayerGetReleaseQueue(), ^&#123;</span><br><span class="line">              CFRelease(image);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (task.didDisplay) task.didDisplay(self, YES);</span><br><span class="line">      return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ///为正常情况</span><br><span class="line">  dispatch_async(YYAsyncLayerGetDisplayQueue(), ^&#123;</span><br><span class="line">      //若发生取消操作,则取消绘制</span><br><span class="line">      if (isCancelled()) return;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      UIGraphicsBeginImageContextWithOptions(size, opaque, scale);</span><br><span class="line">      CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      task.display(context, size, isCancelled);</span><br><span class="line"></span><br><span class="line">      //若取消 则释放资源,取消绘制</span><br><span class="line">      if (isCancelled()) &#123;</span><br><span class="line">          UIGraphicsEndImageContext();</span><br><span class="line">          dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">              if (task.didDisplay) task.didDisplay(self, NO);</span><br><span class="line">          &#125;);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //将上下文转换为图片</span><br><span class="line">      UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">      UIGraphicsEndImageContext();</span><br><span class="line"></span><br><span class="line">      //若取消 则释放资源,取消绘制</span><br><span class="line">      if (isCancelled()) &#123;</span><br><span class="line">          dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">              if (task.didDisplay) task.didDisplay(self, NO);</span><br><span class="line">          &#125;);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ///主线程异步 进行最后的绘制操作</span><br><span class="line">      dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          if (isCancelled()) &#123;</span><br><span class="line">              if (task.didDisplay) task.didDisplay(self, NO);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              self.contents = (__bridge id)(image.CGImage);</span><br><span class="line">              if (task.didDisplay) task.didDisplay(self, YES);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>YYAsyncLayer 是通过创建异步创建图像Context在其绘制,最后再主线程异步添加图像 从而实现的异步绘制.同时,在绘制过程中 进行了多次进行取消判断,以免额外绘制.</p><h4 id="同步绘制"><a href="#同步绘制" class="headerlink" title="同步绘制"></a>同步绘制</h4><p>同步绘制就是直接绘制就好了~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[_sentinel increase];</span><br><span class="line">if (task.willDisplay) task.willDisplay(self);</span><br><span class="line">UIGraphicsBeginImageContextWithOptions(self.bounds.size, self.opaque, self.contentsScale);</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">task.display(context, self.bounds.size, ^&#123;return NO;&#125;);</span><br><span class="line">UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">self.contents = (__bridge id)(image.CGImage);</span><br><span class="line">if (task.didDisplay) task.didDisplay(self, YES);</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="替换当前View的Layer"><a href="#替换当前View的Layer" class="headerlink" title="替换当前View的Layer"></a>替换当前View的Layer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)layerClass &#123;</span><br><span class="line">    return YYAsyncLayer.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改需要属性时-进行重绘制"><a href="#修改需要属性时-进行重绘制" class="headerlink" title="修改需要属性时 进行重绘制"></a>修改需要属性时 进行重绘制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)setText:(NSString *)text &#123;</span><br><span class="line">    _text = text.copy;</span><br><span class="line">    [[YYTransaction transactionWithTarget:self selector:@selector(contentsNeedUpdated)] commit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFont:(UIFont *)font &#123;</span><br><span class="line">    _font = font;</span><br><span class="line">    [[YYTransaction transactionWithTarget:self selector:@selector(contentsNeedUpdated)] commit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)layoutSubviews &#123;</span><br><span class="line">    [super layoutSubviews];</span><br><span class="line">    [[YYTransaction transactionWithTarget:self selector:@selector(contentsNeedUpdated)] commit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)contentsNeedUpdated &#123;</span><br><span class="line">    [self.layer setNeedsDisplay];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现代理方法-完成绘制任务"><a href="#实现代理方法-完成绘制任务" class="headerlink" title="实现代理方法 完成绘制任务"></a>实现代理方法 完成绘制任务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (YYAsyncLayerDisplayTask *)newAsyncDisplayTask &#123;</span><br><span class="line"></span><br><span class="line">    NSString *text = _text;</span><br><span class="line">    UIFont *font = _font;</span><br><span class="line"></span><br><span class="line">    YYAsyncLayerDisplayTask *task = [YYAsyncLayerDisplayTask new];</span><br><span class="line">    task.willDisplay = ^(CALayer *layer) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    task.display = ^(CGContextRef context, CGSize size, BOOL(^isCancelled)(void)) &#123;</span><br><span class="line">        if (isCancelled()) return;</span><br><span class="line">        //在这里由于绘制文字会颠倒</span><br><span class="line">        [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            CGContextTranslateCTM(context, 0, self.bounds.size.height);</span><br><span class="line">            CGContextScaleCTM(context, 1.0, -1.0);</span><br><span class="line">        &#125;];</span><br><span class="line">        NSAttributedString* str = [[NSAttributedString alloc] initWithString:text attributes:@&#123;NSFontAttributeName:_font&#125;];</span><br><span class="line">        CGContextSetTextPosition(context, 0, font.pointSize);</span><br><span class="line">        CTLineRef line = CTLineCreateWithAttributedString((__bridge CFAttributedStringRef)str);</span><br><span class="line">        CTLineDraw(line, context);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    task.didDisplay = ^(CALayer *layer, BOOL finished) &#123;</span><br><span class="line">        if (finished) &#123;</span><br><span class="line">            // finished</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // cancelled</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>作为对照,添加UILabel进行对比试验,重写其 <code>-(void)drawRect:</code>方法打印输出比较.<br><img src="/images/YYAsyncLayer学习/效果.png" alt="运行结果"></p><p>由此可知: 同步绘制任务(la2) 在<code>viewDidAppear</code>前完成绘制, 而AsyncLayer则在这之后再开始绘制任务,切绘制方法在异步执行.</p><h1 id="原生API对比"><a href="#原生API对比" class="headerlink" title="原生API对比."></a>原生API对比.</h1><p>关于异步绘制,iOS6 为CALayer添加了新的API <code>drawsAsynchronously</code> 属性.当你设置 drawsAsynchronously = YES 后，-drawRect: 和 -drawInContext: 函数依然实在主线程调用的。但是所有的Core Graphics函数（包括UIKit的绘制API，最后其实还是Core Graphics的调用）不会做任何事情，而是所有的绘制命令会被在后台线程处理。</p><p>这种方式就是先记录绘制命令，然后在后台线程执行。为了实现这个过程，更多的事情不得不做，更多的内存开销。最后只是把一些工作从主线程移动出来。这个过程是需要权衡，测试的。</p><p>这个可能是代价最昂贵的的提高绘制性能的方法，也不会节省很多资源。</p><p>相比之下,AsyncLaye的性能会好一些, 但麻烦的是 绘制实现要自己写<del>~</del></p><h1 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h1><p>在我使用的版本(1.0)中 异步绘制的bitmap的scale为1.0 因为+(id)defaultValueForKey:(NSString *)key 方法,所以在使用时 注意修改~~~ 不然显示的画面会有模糊感</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;YYAsyncLayer-学习&quot;&gt;&lt;a href=&quot;#YYAsyncLayer-学习&quot; class=&quot;headerlink&quot; title=&quot;YYAsyncLayer 学习&quot;&gt;&lt;/a&gt;YYAsyncLayer 学习&lt;/h1&gt;&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="第三方框架学习" scheme="http://yoursite.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>iOS进程信息 -- NSProgressInfo</title>
    <link href="http://yoursite.com/2017/11/22/iOS%E8%BF%9B%E7%A8%8B%E6%B6%88%E6%81%AF%20--%20NSProgressInfo/"/>
    <id>http://yoursite.com/2017/11/22/iOS进程消息 -- NSProgressInfo/</id>
    <published>2017-11-22T07:26:16.000Z</published>
    <updated>2017-11-23T05:31:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS进程信息-–-NSProgressInfo"><a href="#iOS进程信息-–-NSProgressInfo" class="headerlink" title="iOS进程信息 – NSProgressInfo"></a>iOS进程信息 – NSProgressInfo</h1><p> NSProcessInfo *processInfo = [NSProcessInfo processInfo];  </p><pre><code>//获取运行该进程的参数  NSArray *arr = [processInfo arguments];  NSLog(@&quot;运行该程序的参数为：%@&quot;, arr);  //获取该进程的进程标示符  NSLog(@&quot;该程序的进程标示符(PID)为：%d&quot;, [processInfo processIdentifier]);  //获取该进程的进程名  NSLog(@&quot;该程序的进程名为：%@&quot;, [processInfo processName]);  //设置该进程的新进程名  [processInfo setProcessName:@&quot;test&quot;];  NSLog(@&quot;该程序的新进程名为：%@&quot;, [processInfo processName]);  //获取运行该进程的系统的环境变量  NSLog(@&quot;运行该进程的系统的所有环境变量为：%@&quot;, [processInfo environment]);  //获取运行该进程的主机名  NSLog(@&quot;运行该进程的主机名为：%@&quot;, [processInfo hostName]);  //获取运行该进程的操作系统  NSLog(@&quot;运行该进程所在的操作系统为：%ld&quot;, [processInfo operatingSystem]);  //获取运行该进程的操作系统的版本  NSLog(@&quot;运行该进程所在的操作系统名为：%@&quot;, [processInfo operatingSystemName]);  //获取运行该进程的操作系统的版本  NSLog(@&quot;运行该进程所在的操作系统的版本为：%@&quot;, [processInfo operatingSystemVersionString]);  //获取运行该进程的系统的物理内存  NSLog(@&quot;运行该进程的系统的物理内存为：%lld&quot;, [processInfo physicalMemory]);  //获取运行该进程的系统的处理器数量  NSLog(@&quot;运行该进程的系统的处理器数量为：%ld&quot;, [processInfo processorCount]);  //获取运行该进程的系统的处于激活状态的处理器数量  NSLog(@&quot;运行该进程的系统的处于激活状态的处理器数量为：%ld&quot;, [processInfo activeProcessorCount]);  //获取运行该进程的系统已运行的时间  NSLog(@&quot;运行该进程的系统的已运行时间为：%f&quot;, [processInfo systemUptime]);  </code></pre><p>}  </p><p>转载: <a href="http://justsee.iteye.com/blog/2264764" target="_blank" rel="external">NSProcessInfo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS进程信息-–-NSProgressInfo&quot;&gt;&lt;a href=&quot;#iOS进程信息-–-NSProgressInfo&quot; class=&quot;headerlink&quot; title=&quot;iOS进程信息 – NSProgressInfo&quot;&gt;&lt;/a&gt;iOS进程信息 – NSPr
      
    
    </summary>
    
    
      <category term="iOS基础" scheme="http://yoursite.com/tags/iOS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>iOS对象判等---hash函数</title>
    <link href="http://yoursite.com/2017/11/22/iOS%E5%AF%B9%E8%B1%A1%E5%88%A4%E7%AD%89---hash%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/11/22/iOS对象判等---hash函数/</id>
    <published>2017-11-22T07:03:16.000Z</published>
    <updated>2017-11-23T05:35:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS对象判等—hash函数"><a href="#iOS对象判等—hash函数" class="headerlink" title="iOS对象判等—hash函数"></a>iOS对象判等—hash函数</h1><p>要比较相等，我们需要实现 isEqual: 方法。我们希望 isEqual: 方法仅在所有属性都相等的时候返回真。Mike Ash 的 Implement Equality and Hashing 和 NSHipster 的 Equality 为我们很好地阐述了如何实现。首先，我们需要写一个 isEqual: 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isEqual:(id)obj</span><br><span class="line">&#123;</span><br><span class="line">    if(![obj isKindOfClass:[Person class]]) return NO;</span><br><span class="line"></span><br><span class="line">    Person* other = (Person*)obj;</span><br><span class="line"></span><br><span class="line">    BOOL nameIsEqual = self.name == other.name || [self.name isEqual:other.name];</span><br><span class="line">    BOOL birthDateIsEqual = self.birthDate == other.birthDate || [self.birthDate isEqual:other.birthDate];</span><br><span class="line">    BOOL numberOfKidsIsEqual = self.numberOfKids == other.numberOfKids;</span><br><span class="line">    return nameIsEqual &amp;&amp; birthDateIsEqual &amp;&amp; numberOfKidsIsEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，我们先检查输入和自身是否是同样的类。如果不是的话，那肯定就不相等了。然后对每一个对象属性，判断其指针是否相等。|| 操作符的操作看起来好像是不必要的，但是如果我们需要处理两个属性都是 nil 的情形的话，它能够正确地返回 YES。比较像 NSUInteger 这样的标量是否相等时，则只需要使用 == 就可以了。</p><p>还有一件事情值得一提：这里我们将不同的属性比较的结果分开存储到了它们自己的 BOOL 中。在实践中，可能将它们放到一个大的判断语句中会更好，因为如果这么做的话你就可以避免一些不必要的取值和比较了。比如在上面的例子中，如果 name 已经不相等了的话，我们就没有必要再检查其他的属性了。将所有判断合并到一个 if 语句中我们可以自动地得到这样的优化。</p><p>接下来，按照文档所说，我们还需要实现一个 hash 函数。苹果如是说：</p><blockquote><p>如果两个对象是相等的，那么它们必须有同样的 hash 值。如果你在一个子类里定义了 isEqual: 方法，并且打算将这个子类的实例放到集合类中的话，那么你一定要确保你也在你的子类里定义了 hash 方法，这是非常重要的。</p></blockquote><p>首先，我们来看看如果不实现 hash 方法的话，下面的代码会发生什么；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person* p1 = [[Person alloc] initWithName:name birthDate:start numberOfKids:0];</span><br><span class="line">Person* p2 = [[Person alloc] initWithName:name birthDate:start numberOfKids:0];</span><br><span class="line">NSDictionary* dict = @&#123;p1: @&quot;one&quot;, p2: @&quot;two&quot;&#125;;</span><br><span class="line">NSLog(@&quot;%@&quot;, dict);</span><br></pre></td></tr></table></figure><p>第一次运行上面的代码是，一切都很正常，字典中有两个条目。但是第二次运行的时候却只剩一个了。事情变得不可预测，所以我们还是按照文档说的来做吧。</p><p>作为字典的键,NSSet的元素这种需要判断不重复的情况.</p><p>可能你还记得你在计算机科学课程中学到过，编写一个好的 hash 函数是一件不太容易的事情。好的 hash 函数需要兼备确定性和均布性。确定性需要保证对于同样的输入总是能生成同样的 hash 值。均布性需要保证输出的结果要在输出范围内均匀地对应输入。你的输出分布越均匀，就意味着当你将这些对象用在集合中时，性能会越好。</p><p>首先我们得搞清楚到底发生了什么。让我们来看看没有实现 hash 函数时候的情况下，使用 Person 对象作为字典的键时的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary* dictionary = [NSMutableDictionary dictionary];</span><br><span class="line"></span><br><span class="line">NSDate* start = [NSDate date];</span><br><span class="line">for (int i = 0; i &lt; 50000; i++) &#123;</span><br><span class="line">    NSString* name = randomString();</span><br><span class="line">    Person* p = [[Person alloc] initWithName:name birthDate:[NSDate date] numberOfKids:i++];</span><br><span class="line">    [dictionary setObject:@&quot;value&quot; forKey:p];</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;%f&quot;, [[NSDate date] timeIntervalSinceDate:start]);</span><br></pre></td></tr></table></figure><p>这在我的机子上花了 29 秒时间来执行。作为对比，当我们实现一个基本的 hash 方法的时候，同样的代码只花了 0.4 秒。这并不是精确的性能测试，但是却足以告诉我们实现一个正确的 hash 函数的重要性。对于 Person 这个类来说，我们可以从这样一个 hash 函数开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)hash</span><br><span class="line">&#123;</span><br><span class="line">    return self.name.hash ^ self.birthDate.hash ^ self.numberOfKids;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将从我们的属性中取出三个 hash 值，然后将它们做 XOR (异或) 操作。在这里，这个方法对我们的目标来说已经足够好了，因为对于短字符串 (以前这个上限是 96 个字符，不过现在不是这样了，参见 CFString.c 中 hash 的部分) 来说，NSString 的 hash 函数表现很好。对于更正式的 hash 算法，hash 函数应该依赖于你所拥有的数据。这在 Mike Ash 的文章和其他一些地方有所涉及。</p><p>在 hash 文档中，有下面这样一段话：</p><blockquote><p>如果一个被插入集合类的可变对象是依据其 hash 值来决定其在集合中的位置的话，这个对象的 hash 函数所返回的值在该对象存在于集合中时是不允许改变的。因此，要么使用一个和对象内部 状态无关的 hash 函数，要么确保在对象处于集合中时其内部状态不发生改变。比如说，一个可 变字典可以被放到一个 hash table 中，但是只要这个字典还在 hash table 中时，你就不能 更改它。(注意，要知道一个给定对象是不是存在于某个集合中是一件很困难的事情。)</p></blockquote><p>这也是你需要确保对象的不可变性的另一个重要原因。只要确保了这一点，你就不必再担心这个问题了。</p><p>转载截取 : <a href="https://objccn.io/issue-7-2/" target="_blank" rel="external">值对象</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS对象判等—hash函数&quot;&gt;&lt;a href=&quot;#iOS对象判等—hash函数&quot; class=&quot;headerlink&quot; title=&quot;iOS对象判等—hash函数&quot;&gt;&lt;/a&gt;iOS对象判等—hash函数&lt;/h1&gt;&lt;p&gt;要比较相等，我们需要实现 isEqual: 
      
    
    </summary>
    
    
      <category term="iOS基础" scheme="http://yoursite.com/tags/iOS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 2.0</title>
    <link href="http://yoursite.com/2017/11/22/HTTP%202.0/"/>
    <id>http://yoursite.com/2017/11/22/HTTP 2.0/</id>
    <published>2017-11-22T01:04:12.000Z</published>
    <updated>2017-11-22T01:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h1><h2 id="HTTP-1-0-缺点"><a href="#HTTP-1-0-缺点" class="headerlink" title="HTTP 1.0 缺点"></a>HTTP 1.0 缺点</h2><p>在http 1.0 时,每进行一次请求时,都会建立一次TCP连接,开销很大</p><h2 id="HTTP-1-1-缺点"><a href="#HTTP-1-1-缺点" class="headerlink" title="HTTP 1.1 缺点"></a>HTTP 1.1 缺点</h2><h3 id="HTTP-Pipelining-http管线技术"><a href="#HTTP-Pipelining-http管线技术" class="headerlink" title="HTTP Pipelining(http管线技术)"></a>HTTP Pipelining(http管线技术)</h3><p>在http1.1中默认是启用该技术的,即消息头中:Connection:keep-alive.</p><p>HTTP Pipelining其实是把多个HTTP请求放到<strong>一个TCP连接</strong>中一一发送，而在发送过程中不需要等待服务器对前一个请求的响应；只不过，客户端还是要<strong>按照发送请求的顺序</strong>来接收响应。这样就像在串行队列中执行任务一样,若前一个任务十分耗时,则会导致后续的响应卡顿.这就是所谓的线头卡顿(Head of line blocking).</p><h3 id="请求数量"><a href="#请求数量" class="headerlink" title="请求数量"></a>请求数量</h3><p>浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞</p><h3 id="数据大小"><a href="#数据大小" class="headerlink" title="数据大小"></a>数据大小</h3><p>HTTP1.1的格式为文本格式,难以优化. 大量相似http请求时,会发送大量一样的消息头,导致流量浪费.(跟json 与 protocolBuf)</p><h3 id="服务端无法主动推送资源至服务端"><a href="#服务端无法主动推送资源至服务端" class="headerlink" title="服务端无法主动推送资源至服务端"></a>服务端无法主动推送资源至服务端</h3><h2 id="HTTP-2-0-1"><a href="#HTTP-2-0-1" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>HTTP 2.0 使用新的<strong>二进制格式</strong>：基本的协议单位是帧，每个帧都有不同的类型和用途，规范中定义了10种不同的帧。例如，报头(HEADERS)和数据(DATA)帧组成了基本的HTTP 请求和响应；其他帧例如 设置(SETTINGS),窗口更新(WINDOW_UPDATE), 和推送承诺(PUSH_PROMISE)是用来实现HTTP/2的其他功能。那些请求和响应的帧数据通过流来进行数据交换。新的二进制格式是流量控制、优先级、server push等功能的基础.<br><img src="images/HTTP 2.0/15112529987865.jpg" alt=""></p><h3 id="单一连接-多路复用"><a href="#单一连接-多路复用" class="headerlink" title="单一连接,多路复用"></a>单一连接,多路复用</h3><p>http2.0 允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。可以理解为在单一的TCP链接中,并发请求响应.<br><img src="images/HTTP 2.0/15112560081647.jpg" alt=""></p><p>在TCP链接时,并不是一开始就到达最大传输速度,因为若带宽不足,一开始高速则会导致阻塞.而是随着时间推移逐渐提速,最后达到适合的速度.这叫做TCP的慢启动. 而这对于HTTP这种突发性,短时性的链接会十分低效.</p><h3 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h3><p>http2.0是用了专门为头部压缩而设计的算法,减少冗余数据的传输.</p><h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p>服务端推送是一种在客户端请求之前发送数据的机制,在HTTP 2.0中,服务端可以对客户端的一个请求发送多个响应.这样可以在客户端下次请求时直接返回推送的缓存.</p><h3 id="同类协议"><a href="#同类协议" class="headerlink" title="同类协议"></a>同类协议</h3><p>SPDY的特性基本和Http 2.0相同,因为http2.0就是收spdy的启发设计的. 主要不同在于对传输数据使用gzip进行压缩.</p><h3 id="iOS端使用"><a href="#iOS端使用" class="headerlink" title="iOS端使用"></a>iOS端使用</h3><p>在iOS下,NSURLSession适配了http2.0的,所以我们可以无感的使用他,而不需要做额外的适配,主要是服务器的配置.</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h2><p><a href="http://www.jianshu.com/p/d3959e5acfac" target="_blank" rel="external">iOS HTTP/2 Server Push 探索</a><br><a href="https://ye11ow.gitbooks.io/http2-explained/content/part3.html" target="_blank" rel="external">http2.0讲解</a><br><a href="">关于 iOS HTTP2.0 的一次学习实践</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTP-2-0&quot;&gt;&lt;a href=&quot;#HTTP-2-0&quot; class=&quot;headerlink&quot; title=&quot;HTTP 2.0&quot;&gt;&lt;/a&gt;HTTP 2.0&lt;/h1&gt;&lt;h2 id=&quot;HTTP-1-0-缺点&quot;&gt;&lt;a href=&quot;#HTTP-1-0-缺点&quot; class
      
    
    </summary>
    
    
      <category term="iOS网络" scheme="http://yoursite.com/tags/iOS%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>iOS安全 -- 数据加密</title>
    <link href="http://yoursite.com/2017/11/19/iOS%E5%AE%89%E5%85%A8%20--%20%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"/>
    <id>http://yoursite.com/2017/11/19/iOS安全 -- 数据加密/</id>
    <published>2017-11-19T11:31:29.000Z</published>
    <updated>2017-11-20T08:58:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h1><p>base64是一种基于64个可打印字符来表示二进制数据的表示方法.严格来说它只能算作一种编码方式.<br>Base64编码之所以称为Base64，是因为其使用64个字符来对任意数据进行编码，同理有Base32、Base16编码</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h2><blockquote><p>1, 由于某些系统中只能使用ASCII字符。Base64就是用来将非ASCII字符的数据转换成ASCII字符的一种方法.<br>2, 使用SMTP协议 （Simple Mail Transfer Protocol 简单邮件传输协议）来发送邮件。因为这个协议是基于文本的协议，所以如果邮件中包含一幅图片，我们知道图片的存储格式是二进制数据（binary data），而非文本格式，我们必须将二进制的数据编码成文本格式，这时候Base 64 Encoding就派上用场了.<br>3, 通过base64将ASCII不可见字符转换为可见字符</p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用:"></a>使用:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//编码</span><br><span class="line">- (NSString *)base64EncodedString;&#123;</span><br><span class="line">NSData *data = [self dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">return [data base64EncodedStringWithOptions:0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//解码</span><br><span class="line">- (NSString *)base64DecodedString&#123;</span><br><span class="line">NSData *data = [[NSData alloc]initWithBase64EncodedString:self options:0];</span><br><span class="line">return [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h1><p>MD5(消息摘要算法第五版)为计算机安全领域广泛使用的一种<strong>散列函数</strong>，用以提供消息的完整性保护.</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h2><blockquote><p>1、压缩性：任意长度的数据，算出的MD5值长度都是固定的(32摘要)。<br>2、容易计算：从原数据计算出MD5值很容易。<br>3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。<br>4、强抗碰撞(难逆向)：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</p></blockquote><h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><blockquote><p>1, 数字签名, 当我们传递敏感信息时,可以为利用MD5+时间戳+盐 为消息添加唯一的数字签名,当服务端获得数据后,用相同算法再次签名.进行比较 若不一致 则数据遭到篡改.<br>2, 文件验证, 我们在下载文件时,由于复杂的网络环境,我们下载的文件可能会有内容丢失或篡改的可能性.(例如我们从服务器获取的H5文件遭到了JS注入),利用MD5可以有效防止这些事情的发生.</p></blockquote><h2 id="同类算法"><a href="#同类算法" class="headerlink" title="同类算法"></a>同类算法</h2><p>SHA-1: </p><blockquote><p>会产生一个160位的消息摘要,SHA-1的安全性在2000年以后已经不被大多数的加密场景所接受。2017年荷兰密码学研究小组CWI和Google正式宣布攻破了SHA-1.</p></blockquote><p>SHA-2:</p><blockquote><p>2001年发布，包括SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。虽然至今尚未出现对SHA-2有效的攻击，它的算法跟SHA-1基本上仍然相似；因此有些人开始发展其他替代的散列算法。</p></blockquote><p>SHA-3:</p><blockquote><p>2015年正式发布，SHA-3并不是要取代SHA-2，因为SHA-2目前并没有出现明显的弱点。由于对MD5出现成功的破解，以及对SHA-0和SHA-1出现理论上破解的方法，NIST感觉需要一个与之前算法不同的，可替换的加密散列算法，也就是现在的SHA-3。</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这里是对字符串的散列计算,若对文件则需要先读取文件流再去散列.<br>需要: <code>import &lt;CommonCrypto/CommonDigest.h&gt;</code></p><h3 id="MD5-1"><a href="#MD5-1" class="headerlink" title="MD5"></a>MD5</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)md5String &#123;</span><br><span class="line">    const char *str = self.UTF8String;</span><br><span class="line">    uint8_t buffer[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">    CC_MD5(str, (CC_LONG)strlen(str), buffer);</span><br><span class="line">    return [self stringFromBytes:buffer length:CC_MD5_DIGEST_LENGTH];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1:"></a>SHA-1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)sha1String &#123;</span><br><span class="line">    const char *str = self.UTF8String;</span><br><span class="line">    uint8_t buffer[CC_SHA1_DIGEST_LENGTH];</span><br><span class="line">    </span><br><span class="line">    CC_SHA1(str, (CC_LONG)strlen(str), buffer);</span><br><span class="line">    </span><br><span class="line">    return [self stringFromBytes:buffer length:CC_SHA1_DIGEST_LENGTH];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SHA256"><a href="#SHA256" class="headerlink" title="SHA256:"></a>SHA256:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)sha256String &#123;</span><br><span class="line">    const char *str = self.UTF8String;</span><br><span class="line">    uint8_t buffer[CC_SHA256_DIGEST_LENGTH];</span><br><span class="line">    </span><br><span class="line">    CC_SHA256(str, (CC_LONG)strlen(str), buffer);</span><br><span class="line">    </span><br><span class="line">    return [self stringFromBytes:buffer length:CC_SHA256_DIGEST_LENGTH];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SHA512"><a href="#SHA512" class="headerlink" title="SHA512:"></a>SHA512:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)sha512String &#123;</span><br><span class="line">    const char *str = self.UTF8String;</span><br><span class="line">    uint8_t buffer[CC_SHA512_DIGEST_LENGTH];</span><br><span class="line">    </span><br><span class="line">    CC_SHA512(str, (CC_LONG)strlen(str), buffer);</span><br><span class="line">    </span><br><span class="line">    return [self stringFromBytes:buffer length:CC_SHA512_DIGEST_LENGTH];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SHA3"><a href="#SHA3" class="headerlink" title="SHA3:"></a>SHA3:</h3><blockquote><p>需要在github上下载keccak代码包 :<a href="https://github.com/gvanas/KeccakCodePackage" target="_blank" rel="external">https://github.com/gvanas/KeccakCodePackage</a></p></blockquote><h3 id="大文件的计算"><a href="#大文件的计算" class="headerlink" title="大文件的计算:"></a>大文件的计算:</h3><p>这里以MD5为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#define FileHashDefaultChunkSizeForReadingData 4096</span><br><span class="line"></span><br><span class="line">- (NSString *)fileMD5Hash &#123;</span><br><span class="line">    //打开一个文件准备读取</span><br><span class="line">    NSFileHandle *fp = [NSFileHandle fileHandleForReadingAtPath:self];</span><br><span class="line">    if (fp == nil) &#123;</span><br><span class="line">    //若路径为文件夹这种的(如:.framework)则会返回Null</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //创建MD5变量</span><br><span class="line">    CC_MD5_CTX hashCtx;</span><br><span class="line">    //初始化MD5变量</span><br><span class="line">    CC_MD5_Init(&amp;hashCtx);</span><br><span class="line">    </span><br><span class="line">    while (YES) &#123;</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">        //读取文件指定长度数据,循环读取避免一次加载到内存过大</span><br><span class="line">            NSData *data = [fp readDataOfLength:FileHashDefaultChunkSizeForReadingData];</span><br><span class="line">            //准备MD5加密,将内容上传</span><br><span class="line">            CC_MD5_Update(&amp;hashCtx, data.bytes, (CC_LONG)data.length);</span><br><span class="line">            </span><br><span class="line">            if (data.length == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //关闭文件</span><br><span class="line">    [fp closeFile];</span><br><span class="line">    </span><br><span class="line">    //创建MD5结果缓冲区</span><br><span class="line">    uint8_t buffer[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">    //将MD5结果写进缓冲区</span><br><span class="line">    CC_MD5_Final(buffer, &amp;hashCtx);</span><br><span class="line">    </span><br><span class="line">    //原始数据转换为字符串</span><br><span class="line">    return [self stringFromBytes:buffer length:CC_MD5_DIGEST_LENGTH];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)stringFromBytes:(uint8_t *)bytes length:(int)length &#123;</span><br><span class="line">    NSMutableString *strM = [NSMutableString string];</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        [strM appendFormat:@&quot;%02x&quot;, bytes[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return [strM copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于其他的算法文件加密方式也是这样的,它们都是由CommonCrypto库提供的.</p><h3 id="HMAC散列计算-加盐"><a href="#HMAC散列计算-加盐" class="headerlink" title="HMAC散列计算(加盐)"></a>HMAC散列计算(加盐)</h3><p>HMAC是密钥相关的哈希运算消息认证码，HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。<br>HMAC算法更象是一种加密算法，它引入了密钥，其安全性已经不完全依赖于所使用的HASH算法,有些类似对称加密,但是是不可逆的那种~.<br>以MD5为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)hmacMD5StringWithKey:(NSString *)key &#123;</span><br><span class="line">    const char *keyData = key.UTF8String;</span><br><span class="line">    const char *strData = self.UTF8String;</span><br><span class="line">    //切换其他散列函数替换这里(如:CC_SHA256_DIGEST_LENGTH)</span><br><span class="line">    uint8_t buffer[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">        //切换其他散列函数替换这里(如:kCCHmacAlgSHA256)</span><br><span class="line">    CCHmac(kCCHmacAlgMD5, keyData, strlen(keyData), strData, strlen(strData), buffer);</span><br><span class="line">    </span><br><span class="line">   //切换其他散列函数替换这里(如:CC_SHA256_DIGEST_LENGTH)</span><br><span class="line">    return [self stringFromBytes:buffer length:CC_MD5_DIGEST_LENGTH];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AES-对称加密"><a href="#AES-对称加密" class="headerlink" title="AES(对称加密)"></a>AES(对称加密)</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>美国国家标准技术研究所在2001年发布了高级加密标准（AES）。<br>AES是基于数据块的加密方式，<br>即，每次处理的数据是一块（16字节），当数据不是16字节的倍数时填充，<br>这就是所谓的分组密码（区别于基于比特位的流密码），16字节是分组长度。</p><p>AES在软件及硬件上都能快速地加解密，相对来说较易于实现，</p></blockquote><p><img src="/images/iOS安全 -- 数据加密/media/15110711769529/15110870481411.jpg" alt=""></p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>在使用AES时要配置几个加密参数,只有都一致才能使 客户端与服务端 结果一致.</p><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><h4 id="密钥长度"><a href="#密钥长度" class="headerlink" title="密钥长度"></a>密钥长度</h4><blockquote><p>key常见的长度有三种：128、192和256 bits</p></blockquote><h4 id="加密模式"><a href="#加密模式" class="headerlink" title="加密模式"></a>加密模式</h4><blockquote><p>AES属于块加密（Block Cipher），块加密中有CBC、ECB、CTR、OFB、CFB等几种工作模式.</p></blockquote><h5 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h5><p>是一种基础的加密方式,AES默认没收,密文被分割成分组长度相等的块（不足补齐），然后单独一个个加密,一个个输出组成密文.</p><p><img src="/images/iOS安全 -- 数据加密/media/15110711769529/15110873264632.jpg" alt=""></p><h5 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h5><p>这个模式是链式的,后一块需要前一块做基础，第一块需要一个需要初始化向量IV做基础.<br>相同的输入产生不同的输出.<br>能看到的数据是“明文+IV”或“明文+前一个密文”的乱码，所以能隐藏明文.</p><p>所以加密/解密 需要: 明文/密文 + 秘钥 + 初始向量参数</p><p><img src="/images/iOS安全 -- 数据加密/media/15110711769529/15110876564551.jpg" alt=""></p><h4 id="填充方式"><a href="#填充方式" class="headerlink" title="填充方式"></a>填充方式</h4><p>因为AES的算法是把明文分组再处理的,他要求每个分组(16字节)是“满”的,即明文长度必须被16字节整除.</p><p>所以明文最后不足的16字节的要先进行数据填充,把不足16字节的最后一组补成16字节.</p><p>CFB,OFB和CTR模式由于与key进行加密操作的是上一块加密后的密文,因此不需要对最后一段明文进行填充.<br>在iOS SDK中提供了PKCS7Padding.</p><h4 id="初始向量"><a href="#初始向量" class="headerlink" title="初始向量"></a>初始向量</h4><p>正如在CBC模式哪里介绍的,开始加密时,从哪里开始就是初始向量,如不设置则系统默认为0;</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">NSString *const kInitVector = @&quot;初始向量&quot;;</span><br><span class="line"></span><br><span class="line">size_t const kKeySize = kCCKeySizeAES256;//秘钥长度</span><br><span class="line"></span><br><span class="line">+ (NSData *)encryptAES:(NSData *)content key:(NSString *)key &#123;</span><br><span class="line">    </span><br><span class="line">    NSData *contentData = content;</span><br><span class="line">    NSUInteger dataLength = contentData.length;</span><br><span class="line">    </span><br><span class="line">    //设置加密秘钥,因C字符串结束符为&apos;\0&apos; 所以大小+1</span><br><span class="line">    char keyPtr[kKeySize + 1];</span><br><span class="line">    memset(keyPtr, 0, sizeof(keyPtr));</span><br><span class="line">    //应确保大小小于等于16个字节.</span><br><span class="line">    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];</span><br><span class="line">    </span><br><span class="line">    //密文长度 = 明文长度+秘钥长度</span><br><span class="line">    size_t encryptSize = dataLength + kCCBlockSizeAES128;</span><br><span class="line">    void *encryptedBytes = malloc(encryptSize);</span><br><span class="line">    </span><br><span class="line">    //密文接受指针</span><br><span class="line">    size_t actualOutSize = 0;</span><br><span class="line">    </span><br><span class="line">    //初始向量</span><br><span class="line">    NSData *initVector = [kInitVector dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    </span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,               //是加密还是解密</span><br><span class="line">                                          kCCAlgorithmAES,          //加密/解密方式</span><br><span class="line">                                          kCCOptionPKCS7Padding,    //PKCS7Padding</span><br><span class="line">                                          keyPtr,                   //秘钥</span><br><span class="line">                                          kKeySize,                 //秘钥大小</span><br><span class="line">                                          initVector.bytes,         //初始向量</span><br><span class="line">                                          contentData.bytes,        //明文/密文</span><br><span class="line">                                          dataLength,               //明文/密文大小</span><br><span class="line">                                          encryptedBytes,           //结果: 密文/明文缓冲区</span><br><span class="line">                                          encryptSize,              //结果: 密文/明文大小</span><br><span class="line">                                          &amp;actualOutSize);          //结果指针</span><br><span class="line">    </span><br><span class="line">    if (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        // 成功</span><br><span class="line">        return [NSData dataWithBytesNoCopy:encryptedBytes length:actualOutSize];</span><br><span class="line">    &#125;</span><br><span class="line">    //释放</span><br><span class="line">    free(encryptedBytes);</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h3><p>任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质的数.计算这个值的函数为 欧拉函数: 如: φ(8) = 4. </p><blockquote><p>若n为质数 则: φ(n) = n-1 <strong>原理3</strong><br>若n为质数的n次方 则: φ(p^k) = p^k - p^(k-1)<br>若n为两个互质整数之积 则: φ(p1 <em> p2) = φ(p1)φ(p2) <strong>原理1</strong><br>若正整数 a和n互质 则: a^φ(n) 被n除的余数为1 则: a^φ(n) %n=1 <strong>欧拉定理</strong><br>若正整数a和质数p互质 则: a^p-1 %p=1 //费马小定理<br>若正整数a和n互质,则一定可以找到正整数b 使: ab%n=1, b为a的模反元素. <em>*原理2</em></em></p></blockquote><h3 id="秘钥生成"><a href="#秘钥生成" class="headerlink" title="秘钥生成"></a>秘钥生成</h3><p>1, 随机生成两个不等质数p和q 如 p=61 q=53</p><p>2, 求出pq乘积n n=p <em> q= 61</em>53=3233.</p><blockquote><p>这里n的长度即为,秘钥长度,如3233为二进制12位,RSA秘钥一般为1024位.</p></blockquote><p>3, 计算φ(n)</p><blockquote><p>根据 原理1 φ(n) = φ(p)φ(q) = (p-1)(q-1) = 3120</p></blockquote><p>4, 随机选择一个整数e 条件为 1&lt;e&lt;φ(n) 且 e与φ(n)互质</p><blockquote><p>假如选择 17</p></blockquote><p>5, 获取e对于φ(n)的模反元素d </p><blockquote><p>ed%φ(n)=1 —&gt; ed -1 = kφ(n) —&gt; 17d + 3120k = 1<br>通过扩展欧几里德算法 可得到一组整数解 d=2753 k=-15</p></blockquote><p>6, 这里 n和e 为公钥     n和d 为私钥</p><h3 id="加密-此处为公钥加密-n-e"><a href="#加密-此处为公钥加密-n-e" class="headerlink" title="加密(此处为公钥加密 n e)"></a>加密(此处为公钥加密 n e)</h3><p> 对明文信息m 加密 注意:m为正整数,且m须小于n</p><blockquote><p><code>m^e % n = c</code> 这里的c就是加密后得到的密文<br>65^17 % 3233 = 2790  这里2790就是加密后的密文</p></blockquote><h3 id="解密-n-d"><a href="#解密-n-d" class="headerlink" title="解密(n d)"></a>解密(n d)</h3><h4 id="解密原理"><a href="#解密原理" class="headerlink" title="解密原理"></a>解密原理</h4><p>解密规则为: c^d %n = m</p><p>因为加密过程为: m^e % n = c —&gt;  c = m^e - kn<br>若想证明解密规则成立 则等同于证明  (m^e - kn)^d % n = m 成立</p><blockquote><p>(m^e - kn)^d % n = m —&gt; m^ed % n = m</p></blockquote><p>由于在制作公私钥 的第5步 所以:</p><blockquote><p>ed%φ(n)=1 —&gt; ed = hφ(n)+1</p></blockquote><p>将ed代入须证明公式:</p><blockquote><p>m^ed % n = m —&gt; m^hφ(n)+1 % n = m</p></blockquote><h5 id="若m-n-互质"><a href="#若m-n-互质" class="headerlink" title="若m n 互质"></a>若m n 互质</h5><p>m^hφ(n)+1 % n = m —&gt; ((m^φ(n))^h * m) % n = m</p><p>由于欧拉定理 m^φ(n) %n=1可得<br>((m^φ(n))^h <em> m) % n = m —&gt; (1^h </em> m) % n = m  则解密公式成立</p><h5 id="若m-n-不互质"><a href="#若m-n-不互质" class="headerlink" title="若m n 不互质"></a>若m n 不互质</h5><p>因为制作公私钥 的第1步 n = p * q  </p><p>因为加密方法 m^e % n = c , 且因 m&lt;n(这里是在制作时要求的) 所以 c肯定不为0 由此可得 m 与 n 不为互质关系.</p><p>由于 n = pq 且 pq互质 所以 n有且只有 p q 两个因子. 然而 m n有公因子 所以 m n 的公因子 必定为 q或p的整数倍. 所以 m = kp 或 kq</p><p>以 m=kp为例  因为上面描述的关系 m<n ,="" m="" n不互质,="" n="qp" 所以="" k与q互质="" ---=""> m与q互质</n></p><p>由欧拉定理得:<br><code>m^φ(q) % q = 1</code> —&gt; 由于q为质数 —&gt; <code>m^q-1 % q = 1</code> –&gt; <code>(kp)^q-1 % q = 1</code></p><p>因为 k与q互质 p与q互质 –&gt; <code>((kp)^q-1 * kp)%q = kp</code></p><p>进一步可以确定该式成立: <code>(((kp)^h(p-1)(q-1)) * kp)%q = kp</code> 因为p为质数 h为任一整数</p><p>由<strong>原理1</strong>和<strong>原理3</strong><code>(((kp)^h(p-1)(q-1)) * kp)%q = kp</code> —&gt; (kp)^hφ(n)+1 %q=kp</p><p>由于 ed%φ(n)=1,且m=kp 所以将h匹配为合适的值得 <code>(kp)^ed %q = kp</code> —&gt; <code>(m)^ed = tq +m</code> t为整数.</p><p>两侧同除m得: <code>(m)^ed-1 = tq/m +1</code> 由于ed为整数,m为整数 故tq/m为整数. 因q与m互质 所以t为m的整数倍 –&gt; t = yp —&gt; <code>m^ed = yn+m</code> —&gt; <code>m^ed % n = m</code></p><p>由于加密方式 <code>m^e % n = c</code> —&gt; <code>c^d % n = m</code></p><h3 id="安全性讨论"><a href="#安全性讨论" class="headerlink" title="安全性讨论"></a>安全性讨论</h3><p>若想破解RSA 则需要在已知 n e的情况下 求 d 因为 </p><blockquote><p>因为 ed%φ(n)=1  所以需知道 φ(n)<br>因为 φ(n) = (p-1)(q-1) 所以需求得 qp<br>因为 qp=n 所以得将n因式分解</p></blockquote><p>而因式分解是十分困难的 特别是对于 特大整数的因式分解. 由于 名文m 需小于 秘钥长度n 所以常用来加密 对称加密的秘钥.</p><h2 id="iOS实现"><a href="#iOS实现" class="headerlink" title="iOS实现"></a>iOS实现</h2><p>参考链接:<a href="http://www.jianshu.com/p/74a796ec5038" target="_blank" rel="external">iOS中使用RSA加密</a><br>在iOS中使用RSA加密解密 需要使用到<strong>.der</strong> 和 <strong>.p12</strong> 后缀格式文件.</p><blockquote><p>.p12 格式文件是用来加密的 私钥<br>.der 格式文件用来解密的 公钥</p></blockquote><p>添加动态库 <strong>Security.framework</strong></p><p>具体实现太长,我汇总了一个类 感兴趣可以下下来看看 如果帮到你 点个Star鼓励一蛤~<a href="https://github.com/dearmiku/MK_EncryOp" target="_blank" rel="external">github链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Base64&quot;&gt;&lt;a href=&quot;#Base64&quot; class=&quot;headerlink&quot; title=&quot;Base64&quot;&gt;&lt;/a&gt;Base64&lt;/h1&gt;&lt;p&gt;base64是一种基于64个可打印字符来表示二进制数据的表示方法.严格来说它只能算作一种编码方式.&lt;br&gt;B
      
    
    </summary>
    
    
      <category term="iOS安全" scheme="http://yoursite.com/tags/iOS%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>iOS安全 -- 数据安全</title>
    <link href="http://yoursite.com/2017/11/18/iOS%E5%AE%89%E5%85%A8%20--%20%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2017/11/18/iOS安全 -- 数据安全/</id>
    <published>2017-11-18T11:19:38.000Z</published>
    <updated>2017-11-20T00:32:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在正常的iOS系统下,由于沙盒与随机地址的分配的作用下,应用数据的安全是没有问题的,但是在越狱情况下,应用间的数据是共享的,这就存在安全问题,同时也存在手机失窃,面临取证攻击(主要),所以我们在存储敏感数据时要格外小心.</p><h1 id="防止数据泄露的方法"><a href="#防止数据泄露的方法" class="headerlink" title="防止数据泄露的方法"></a>防止数据泄露的方法</h1><h2 id="正式版禁用NSLog-Print"><a href="#正式版禁用NSLog-Print" class="headerlink" title="正式版禁用NSLog/Print"></a>正式版禁用NSLog/Print</h2><p>NSLog方法本质并非向控制台输出调试信息,而是向苹果系统日志(Apple System Log)中输出错误信息,官方解释为</p><blockquote><p>服务器接收到的消息(被输入规则过滤后)会存放在数据仓库(data store)中,该API允许客户端创建查询并搜索消息数据仓库中满足条件的消息.</p></blockquote><p>换句话说可以把NSLog看做printf和syslog的结合体,在调试时将消息发送到Xcode控制台,在设备上运行时将消息发送到系统全局日志.而且此数据外界很容易获得,只需要从Xocde Window-&gt;Devices and Simulator 中就可以获得,例如我运行如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i&lt;100; i++) &#123;</span><br><span class="line">    NSLog(@&quot;hahhahahahahahahahaha&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看日志:</p><p><img src="images/iOS安全 -- 数据安全/日志.png" alt="日志"></p><p>所以在正式版中一定要禁用NSLog,以免意外.</p><h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p>URL加载系统会存储未加密的缓存数据,这些数据存储在Cache.db文件中.而这就会将一些敏感数据缓存在本地,导致不必要的安全风险.<br>这是一些清除缓存的API:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 只会删除内存中的缓存</span><br><span class="line">[[NSURLCache sharedURLCache] removeAllCachedResponses];</span><br><span class="line"></span><br><span class="line">//限制缓存容量,然而该API并不能限制缓存,</span><br><span class="line">//此配置只能在内存/硬盘空间不够时给系统发挥作用.   </span><br><span class="line">[[NSURLCache sharedURLCache] setDiskCapacity:0];</span><br><span class="line"></span><br><span class="line">//设置Cache的缓存策略,并不能禁用缓存,而是在下次请求中不再使用缓存而已</span><br><span class="line">manager.requestSerializer.cachePolicy = NSURLRequestReloadIgnoringLocalCacheData;</span><br></pre></td></tr></table></figure><p>当我将上面三个方法都实现后,利用AFNetworking访问 <a href="https://www.baidu.com" target="_blank" rel="external">https://www.baidu.com</a> 时在沙盒中仍然有缓存的.</p><p><img src="images/iOS安全 -- 数据安全/缓存.png" alt="缓存"><br>可以看到还是有缓存滴~ 那么该怎么办嘞~</p><h3 id="取消缓存的方法"><a href="#取消缓存的方法" class="headerlink" title="取消缓存的方法"></a>取消缓存的方法</h3><blockquote><p>1,服务器返回响应头禁用缓存,Cache-Control: no-cache,no-store,must-revalidate<br>2,直接在Cache路径中 将缓存文件删除(粗暴有效)</p></blockquote><h2 id="截屏泄露"><a href="#截屏泄露" class="headerlink" title="截屏泄露"></a>截屏泄露</h2><p>用户主动截屏并不是我要讨论的,我们可以在关键界面截屏后提示用户泄密风险(在iOS7后,只能在截屏后获得通知).<br>iOS会在应用进入后台之前对当前应用状态截屏,当重新打开应用时可以生成过度动画,提高用户体验,然而有时这就会泄露关键信息.</p><p>解决方案:</p><blockquote><p>在屏幕被截取前对显示图像进行处理(如加上高斯模糊),在进入应用时将高斯模糊图去掉.</p></blockquote><p>而”截屏”事件发生在应用进入后台之后.所以可以在<code>- (void)applicationDidEnterBackground:(UIApplication *)application</code>方法中实现高斯模糊操作.</p><h2 id="钥匙串的使用"><a href="#钥匙串的使用" class="headerlink" title="钥匙串的使用"></a>钥匙串的使用</h2><p>如果需要存储密码,个人资料等小段敏感数据,使用钥匙串最好不过了.我推荐使用 <strong>SSKeyChain</strong>库,它对钥匙串的操作进行了面向对象的封装.主要有以下几个方法:</p><p>可以将 服务与账号看成不同的文件夹, 服务是行号的上级目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 返回本应用的所有钥匙串信息</span><br><span class="line">[SSKeychain allAccounts];</span><br><span class="line"></span><br><span class="line">//发挥指定服务下的所有钥匙串信息</span><br><span class="line">[SSKeychain accountsForService:&lt;#(NSString *)#&gt;];</span><br><span class="line"></span><br><span class="line">//获取指定服务,账号的密码</span><br><span class="line">[SSKeychain passwordForService:&lt;#(NSString *)#&gt; account:&lt;#(NSString *)#&gt;];</span><br><span class="line"></span><br><span class="line">//删除指定服务,账户的信息</span><br><span class="line">[SSKeychain deletePasswordForService:&lt;#(NSString *)#&gt; account:&lt;#(NSString *)#&gt;];</span><br><span class="line"></span><br><span class="line">//将密码保存到指定服务,账号中</span><br><span class="line">[SSKeychain setPassword:&lt;#(NSString *)#&gt; forService:&lt;#(NSString *)#&gt; account:&lt;#(NSString *)#&gt;];</span><br></pre></td></tr></table></figure><p>除此之外,还要设置钥匙串的保护属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//设置钥匙串的保护属性,有以下几个选项</span><br><span class="line">[SSKeychain setAccessibilityType:&lt;#(CFTypeRef)#&gt;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//只有设备未被锁定时钥匙串就保持可用</span><br><span class="line">extern const CFStringRef kSecAttrAccessibleWhenUnlocked</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_4_0);</span><br><span class="line">    </span><br><span class="line">//开机之后使用者第一次输入密码后钥匙可用(锁屏也可以)</span><br><span class="line">extern const CFStringRef kSecAttrAccessibleAfterFirstUnlock</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_4_0);</span><br><span class="line"></span><br><span class="line">//钥匙串在始终可用</span><br><span class="line">extern const CFStringRef kSecAttrAccessibleAlways</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_4_0);</span><br><span class="line">    </span><br><span class="line">//只有设备设置密码才可用,且不可以移植到其他设备,一旦取消密码则存储信息会从设备中删除,且无备份(iOS8)</span><br><span class="line">extern const CFStringRef kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0);</span><br><span class="line">    </span><br><span class="line">//只有设备未被锁定时钥匙串就保持可用,且不可移植</span><br><span class="line">extern const CFStringRef kSecAttrAccessibleWhenUnlockedThisDeviceOnly</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_4_0);</span><br><span class="line"></span><br><span class="line">//开机之后使用者第一次输入密码后钥匙可用(锁屏也可以),且不可移植</span><br><span class="line">extern const CFStringRef kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_4_0);</span><br><span class="line">    </span><br><span class="line">//钥匙串始终可用,且不可移植</span><br><span class="line">extern const CFStringRef kSecAttrAccessibleAlwaysThisDeviceOnly</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_4_0);</span><br></pre></td></tr></table></figure><p>注意:</p><blockquote><p>即使删除应用,钥匙串中的信息并不会删除,只有恢复出厂设置才会删除.<br>keychain sharing可以进行钥匙串共享 是指同一家公司的同一个开发者账号开发的不同APP之间的钥匙串信息共享</p></blockquote><h2 id="数据保护API"><a href="#数据保护API" class="headerlink" title="数据保护API"></a>数据保护API</h2><p>苹果公司推出数据保护API,它允许开发者指定文件解密秘钥的生命周期.数据保护API使用用户密码和层级秘钥来加密保护文件的秘钥.作用上就像钥匙串那样保护文件.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//对options进行配置,设置文件保护级别</span><br><span class="line">NSData* data = [NSData new];</span><br><span class="line">[data writeToFile:@&quot;&quot; options:(NSDataWritingOptions) error:nil];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef NS_OPTIONS(NSUInteger, NSDataWritingOptions) &#123;</span><br><span class="line">    NSDataWritingAtomic = 1UL &lt;&lt; 0,// Hint to use auxiliary file when saving; equivalent to atomically:YES</span><br><span class="line">    NSDataWritingWithoutOverwriting API_AVAILABLE(macos(10.8), ios(6.0), watchos(2.0), tvos(9.0)) = 1UL &lt;&lt; 1, // Hint to  prevent overwriting an existing file. Cannot be combined with NSDataWritingAtomic.</span><br><span class="line"></span><br><span class="line">    NSDataWritingFileProtectionNone NS_ENUM_AVAILABLE_IOS(4_0)                                  = 0x10000000,</span><br><span class="line">    </span><br><span class="line">    //Comeplete是当前最安全的文件保护等级,锁屏之后文件会不可读.</span><br><span class="line">    NSDataWritingFileProtectionComplete NS_ENUM_AVAILABLE_IOS(4_0)                              = 0x20000000,</span><br><span class="line">    </span><br><span class="line">    //如果文件被当前应用打开,那会暂时禁用该文件的保护,会确保该文件在锁屏时依旧可以写入.若想在锁屏之后再去打开则不可以.</span><br><span class="line">    NSDataWritingFileProtectionCompleteUnlessOpen NS_ENUM_AVAILABLE_IOS(5_0)                    = 0x30000000,</span><br><span class="line">    NSDataWritingFileProtectionCompleteUntilFirstUserAuthentication NS_ENUM_AVAILABLE_IOS(5_0)  = 0x40000000,</span><br><span class="line">    NSDataWritingFileProtectionMask NS_ENUM_AVAILABLE_IOS(4_0)                                  = 0xf0000000,</span><br><span class="line"></span><br><span class="line">    // Options with old names for NSData writing methods. Please stop using these old names.</span><br><span class="line">    NSAtomicWrite = NSDataWritingAtomic    // Deprecated name for NSDataWritingAtomic</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从苹果提供的保护措施来看,它的保护措施几乎完全依赖于<strong>用户密码</strong>这个体系,使用钥匙串和数据保护其实就是在沙盒保护的基础上,又加了一层保护而已.<br> 在越狱的情况,或者锁屏密码遭到暴力破解.那么安全就不保了,因此我感觉意义不是那么大.<br>所以我认为可以将钥匙串理解为一个高级沙盒, 它有删除软件数据保留,和钥匙串分享的功能.</p><p>以我个人见解,对于移动端数据安全这里我认为需要这样做:</p><blockquote><p>1, 避免数据泄露(如HTTP缓存….);<br>2, 自己加密,即便是在钥匙串中的密码也是加密过多.这样想要盗窃用户数据不仅要攻克设备密码 也要攻克我们的软件 这样更加安全.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在正常的iOS系统下,由于沙盒与随机地址的分配的作用下,应用数据的安全是没有问题的,但是在越狱情况下,应用间的数据是共享的,这就存在安全问题
      
    
    </summary>
    
    
      <category term="iOS安全" scheme="http://yoursite.com/tags/iOS%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>iOS安全 -- 越狱检测</title>
    <link href="http://yoursite.com/2017/11/18/iOS%E5%AE%89%E5%85%A8%20--%20%E8%B6%8A%E7%8B%B1%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2017/11/18/iOS安全 -- 越狱检测/</id>
    <published>2017-11-18T06:32:21.000Z</published>
    <updated>2017-11-20T00:32:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS安全-–-越狱检测"><a href="#iOS安全-–-越狱检测" class="headerlink" title="iOS安全 – 越狱检测"></a>iOS安全 – 越狱检测</h1><h2 id="越狱是什么"><a href="#越狱是什么" class="headerlink" title="越狱是什么"></a>越狱是什么</h2><p>越狱是指利用iOS系统的默写漏洞,通过指令取得了iOS的root权限.可以自己优化系统，获得系统权限可以修改系统文件，可以安装更多拥有高系统权限的软件，实现更多高级功能!例如：与其他设备蓝牙发送文件、短信回执、来电归属地、文件管理、浏览器下载插件、flash插件、内容管理等等。</p><p>所以在越狱情况下,难免会有一些恶意应用会危害到我们的应用,所以我们需要检测当前是否为越狱环境,从而禁用或者关闭一些功能(如截获我们的网络请求/响应 进行修改,获取我们沙盒的文件,,,,).</p><h2 id="越狱检测方法"><a href="#越狱检测方法" class="headerlink" title="越狱检测方法"></a>越狱检测方法</h2><h3 id="检测沙盒机制和越狱工具"><a href="#检测沙盒机制和越狱工具" class="headerlink" title="检测沙盒机制和越狱工具"></a>检测沙盒机制和越狱工具</h3><p>在越狱环境下,iOS的沙盒机制将被破坏,所以可以去访问本不能访问的路径.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)checkPath</span><br><span class="line">&#123;</span><br><span class="line">BOOL jailBroken = NO;</span><br><span class="line">NSString * cydiaPath = @&quot;/Applications/Cydia.app&quot;;</span><br><span class="line">NSString * aptPath = @&quot;/private/var/lib/apt&quot;;</span><br><span class="line">if ([[NSFileManager defaultManager] fileExistsAtPath:cydiaPath]) &#123;</span><br><span class="line">     jailBroken = YES;</span><br><span class="line">&#125;</span><br><span class="line">if ([[NSFileManager defaultManager] fileExistsAtPath:aptPath]) &#123;</span><br><span class="line">     jailBroken = YES;</span><br><span class="line">&#125;</span><br><span class="line">return jailBroken;</span><br><span class="line">&#125;</span><br><span class="line">·</span><br><span class="line">上述路径也可替换为以下常见越狱工具路径：</span><br><span class="line">/Library/MobileSubstrate/MobileSubstrate.dylib</span><br><span class="line">/Applications/Cydia.app</span><br><span class="line">/var/lib/cydia/</span><br><span class="line">/var/cache/apt   </span><br><span class="line">/var/lib/apt    </span><br><span class="line">/etc/apt</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/sh</span><br><span class="line">/usr/sbin/sshd   </span><br><span class="line">/usr/libexec/ssh-keysign   </span><br><span class="line">/etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>因为有时NSFileManger函数会被hock掉,所以可以使用C语言stat函数进行路径检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)checkCydia</span><br><span class="line">&#123;</span><br><span class="line">struct stat stat_info;</span><br><span class="line">//路径也可以进行替换</span><br><span class="line">if (0 == stat(&quot;/Applications/Cydia.app&quot;, &amp;stat_info)) &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序运行环境变量检测"><a href="#程序运行环境变量检测" class="headerlink" title="程序运行环境变量检测"></a>程序运行环境变量检测</h3><p>如果设置了 DYLD_INSERT_LIBRARIES 环境变量，那么在程序运行时，动态链接器会先加载该环境变量所指定的动态库；也就是说，这个动态库的加载优先于任何其它的库，包括 libc。</p><p>由于这个环境变量指定的动态库加载的时机实在是太早了，所以对于 app来说，除了代码混淆外，无良策；</p><p>但是我们可以在代码中通过判断环境变量来检测是不是被注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)checkEnv&#123;</span><br><span class="line">char *env = getenv(&quot;DYLD_INSERT_LIBRARIES&quot;);</span><br><span class="line">NSLog(@&quot;%s&quot;, env);</span><br><span class="line">if (env) &#123;</span><br><span class="line">     return YES;</span><br><span class="line">&#125;</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证函数地址"><a href="#验证函数地址" class="headerlink" title="验证函数地址"></a>验证函数地址</h3><p>使用dladdr方法可以获得一个函数所在的模块.从而判断该函数是否被替换掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line">#include &lt;objc/objc.h&gt;</span><br><span class="line">#include &lt;objc/runtime.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">    Dl_info info;</span><br><span class="line">    IMP imp;</span><br><span class="line">    Method orginalMethod = class_getClassMethod([NSArray class], @selector(description));</span><br><span class="line">    imp = method_getImplementation(orginalMethod);</span><br><span class="line">        if (dladdr(imp, &amp;info)) &#123;</span><br><span class="line">            printf(&quot;dli_fname: %s\n&quot;, info.dli_fname);</span><br><span class="line">            printf(&quot;dli_sname: %s\n&quot;, info.dli_sname);</span><br><span class="line">            printf(&quot;dli_fbase: %p\n&quot;, info.dli_fbase);</span><br><span class="line">            printf(&quot;dli_saddr: %p\n&quot;, info.dli_saddr);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;error: can&apos;t find that symbol.\n&quot;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>通过该方法验证指定类的方法是否都来自指定模块(可以根据实际情况自定义修改),建议使用inline方式编译,像这样以内联函数的形式编译,攻击者必须修改每一处调用该函数的的地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line">#include &lt;objc/objc.h&gt;</span><br><span class="line">#include &lt;objc/runtime.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">static inline BOOL validate_methods(const char *cls,const char *fnamePre) __attribute__ ((always_inline));</span><br><span class="line"></span><br><span class="line">BOOL validate_methods(const char *cls,const char *fnamePre)&#123;</span><br><span class="line">    Class aClass = objc_getClass(cls);</span><br><span class="line">    Method *methods;</span><br><span class="line">    unsigned int nMethods;</span><br><span class="line">    Dl_info info;</span><br><span class="line">    IMP imp;</span><br><span class="line">    Method m;</span><br><span class="line">    if(!aClass)</span><br><span class="line">        return NO;</span><br><span class="line">    methods = class_copyMethodList(aClass, &amp;nMethods);</span><br><span class="line">    while (nMethods--) &#123;</span><br><span class="line">        m = methods[nMethods];</span><br><span class="line">        imp = method_getImplementation(m);</span><br><span class="line">        if(!imp)&#123;</span><br><span class="line">            free(methods);</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!dladdr(imp, &amp;info))&#123;</span><br><span class="line">            free(methods);</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">        /*Validate image path*/</span><br><span class="line">        if(!strstr(info.dli_fname, fnamePre))&#123;</span><br><span class="line">            goto FAIL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line"></span><br><span class="line">FAIL:</span><br><span class="line">    printf(&quot;method %s failed integrity test:\n&quot;,</span><br><span class="line">           (const char *)method_getName(m));</span><br><span class="line">    printf(&quot;    dli_fname:%s\n&quot;,info.dli_fname);</span><br><span class="line">    printf(&quot;    dli_sname:%s\n&quot;,info.dli_sname);</span><br><span class="line">    printf(&quot;    dli_fbase:%p\n&quot;,info.dli_fbase);</span><br><span class="line">    printf(&quot;    dli_saddr:%p\n&quot;,info.dli_saddr);</span><br><span class="line">    free(methods);</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后,这种检查方式只能减少被攻击的可能性,不是肯定安全的,也是有可能被绕过的.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS安全-–-越狱检测&quot;&gt;&lt;a href=&quot;#iOS安全-–-越狱检测&quot; class=&quot;headerlink&quot; title=&quot;iOS安全 – 越狱检测&quot;&gt;&lt;/a&gt;iOS安全 – 越狱检测&lt;/h1&gt;&lt;h2 id=&quot;越狱是什么&quot;&gt;&lt;a href=&quot;#越狱是什么&quot; c
      
    
    </summary>
    
    
      <category term="iOS安全" scheme="http://yoursite.com/tags/iOS%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>NTA打洞</title>
    <link href="http://yoursite.com/2017/11/17/NTA%E6%89%93%E6%B4%9E/"/>
    <id>http://yoursite.com/2017/11/17/NTA打洞/</id>
    <published>2017-11-17T12:30:21.000Z</published>
    <updated>2017-11-17T02:31:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NTA打洞"><a href="#NTA打洞" class="headerlink" title="NTA打洞"></a>NTA打洞</h1><h2 id="只有一方处于NAT设备后"><a href="#只有一方处于NAT设备后" class="headerlink" title="只有一方处于NAT设备后"></a>只有一方处于NAT设备后</h2><p>此种情况是所有P2P场景中最简单的，它使用一种被称为“反向链接技术”来解决这个问题。大致的原理如下所述。</p><p>如图所示，客户端A位于NAT之后，它通过TCP端口1234连接到服务器的TCP端口1235上，NAT设备为这个连接重新分配了TCP端口62000。客户端B也通过TCP端口1234连接到服务器端口1235上。A和B从服务器处获知的对方的外网地址二元组{IP地址:端口号}分别为{138.76.29.7:1234}和{155.99.25.11:62000}，它们在各自的本地端口上进行侦听。</p><p>由于B 拥有外网IP地址，所以A要发起与B的通信，可以直接通过TCP连接到B。但如果B尝试通过TCP连接到A进行P2P通信，则会失败，原因是A位于NAT设备后，虽然B发出的TCP SYN请求能够到达NAT设备的端口62000，但NAT设备会拒绝这个连接请求。要想与Client A通信， B不是直接向A发起连接，而是通过服务器给A转发一个连接请求，反过来请求A连接到B（即进行反向链接），A在收到从服务器转发过来的请求以后，会主动向B发起一个TCP的连接请求，这样在NAT设备上就会建立起关于这个连接的相关表项，使A和B之间能够正常通信，从而建立起它们之间的TCP连接。</p><p><img src="/images/NAT打洞/反向链接.jpg" alt="反向链接示意图"></p><h2 id="双方都处于NAT后设备后"><a href="#双方都处于NAT后设备后" class="headerlink" title="双方都处于NAT后设备后"></a>双方都处于NAT后设备后</h2><h3 id="NAT设备部署情况"><a href="#NAT设备部署情况" class="headerlink" title="NAT设备部署情况"></a>NAT设备部署情况</h3><blockquote><p>两客户端都处于NAT设备背后也有很多情况,如:<br>1,都处在同一NAT设备后.<br>2,随直连的不是同一个NAT设备,中间有很多NAT转接,但顶端接入公网ip的NAT(网络服务商的路由)是同一个.</p></blockquote><p>像第一种情况,就是在同一个以太网中,这种可以直接使用内网ip进行直连最优.<br>但是想第二种情况,因为嵌套在不同的内网中,都使用的保留ip地址,或许会存在与客户端本身所在的内网地址重复的可能性,所以还是以外网ip+端口来进行打洞最为稳妥.</p><p>因为有Hairpin技术,它可以让两台位于同一台NAT网关后面的主机,通过对方的公网端口互相访问.</p><h3 id="ICE"><a href="#ICE" class="headerlink" title="ICE"></a>ICE</h3><blockquote><p>ICE的全称Interactive Connectivity Establishment（互动式连接建立），由IETF的MMUSIC工作组开发出来的，它所提供的是一种框架，使各种NAT穿透技术可以实现统一。ICE跟STUN和TURN不一样，ICE不是一种协议，而是一个<strong>框架</strong>（Framework），它整合了STUN和TURN。</p></blockquote><h3 id="TURN"><a href="#TURN" class="headerlink" title="TURN"></a>TURN</h3><p>TURN(Traversal Using Relays around NAT)TURN与STUN的共同点都是通过修改应用层中的私网地址达到NAT穿透的效果，异同点是TURN是通过两方通讯的“中间人”方式实现穿透</p><p>TURN服务器相比较STUN服务器,多了中继的功能,对于无法端对端的服务器,可以进包转发</p><h3 id="STUN"><a href="#STUN" class="headerlink" title="STUN"></a>STUN</h3><p>STUN服务器（Simple Traversal of User Datagram Protocol Through Network Address Translators）是一个轻量级协议,是基于UDP的完整的穿透NAT的解决方案.在进行NAT穿透时我们需要STUN服务器.</p><p>STUN服务器主要做了两件事:</p><blockquote><p>1, 判断客户端的NAT类型(NAT分四种类型)<br>2, 接受客户端的请求,返回其需要连接的外网地址<br>3, 协调客户端间打洞</p></blockquote><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="是否处于NAT后-作为iOS肯定是在NAT后的-不用判断的"><a href="#是否处于NAT后-作为iOS肯定是在NAT后的-不用判断的" class="headerlink" title="是否处于NAT后(作为iOS肯定是在NAT后的,不用判断的)"></a>是否处于NAT后(作为iOS肯定是在NAT后的,不用判断的)</h4><p>客户端向STUN服务器发送UDP包,STUN将收到的包的IP包在UDP包中进行返回,客户端收到包后和自己的IP做比较,不一样则处在NAT后.</p><h4 id="判断NAT类型"><a href="#判断NAT类型" class="headerlink" title="判断NAT类型"></a>判断NAT类型</h4><p>当处在NAT后则要判断NAT类型,为了判断STUN服务器需要两个ip,ip1和ip2.</p><p>客户端当得知自己处在NAT设备后时,再向服务端ip1发送判断请求.</p><p>1, FULL Cone NAT</p><blockquote><p>服务器收到后从ip2向客户端的公网ip发送包,若客户端能收到,则为 完全雏形NAT.</p></blockquote><p>2, 判断是否为 对称NAT</p><blockquote><p> 客户端再从不同的port 想服务端发包,若客户端收到的外网端口(此处的端口号是指NAT表中ip后对应的端口号,而不是主机为外网服务的端口号)不一致,则为对称NAT,一致则不为对称NAT</p></blockquote><p>3, Restrict Cone NAT /Port Restrict NAT</p><blockquote><p>服务端从ip1的不同端口向客户端发包,若客户端收到 则为Restrict Cone NAT,收不到则为 Port RestrictNAT.</p></blockquote><h4 id="协调打洞"><a href="#协调打洞" class="headerlink" title="协调打洞"></a>协调打洞</h4><p>1, Full Cone NAT</p><blockquote><p>此时什么都不需要STUN做,只要知道对方公网ip+端口号 客户端间可以直接通讯</p></blockquote><p>2, Restrict Cone 或 Port Restrict</p><blockquote><p>此时需要TURN服务器协调两客户端互相向对方公网ip发包, 因为在NAT设备看起来,互相发包都是在向公网发包,这时在NAT表上就会开启对指定外网ip+端口号的通道.这样就完成了打洞</p></blockquote><p>3, 对称NAT</p><blockquote><p>对于对称NAT是无法打洞的,因为客户端向STUN服务器发包的外网ip+端口号 与向其他客户端发包的外网ip+端口号是不一样的.所以无法沟通,这时就需要TURN服务器,两个客户端都对其进行长连接,进行包的转发.</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.52im.net/thread-542-1-1.html" target="_blank" rel="external">http://www.52im.net/thread-542-1-1.html</a><br><a href="http://www.52im.net/thread-557-1-1.html" target="_blank" rel="external">http://www.52im.net/thread-557-1-1.html</a><br><a href="http://www.h3c.com.cn/MiniSite/Technology_Circle/Net_Reptile/The_Five/Home/Catalog/201206/747038_97665_0.htm" target="_blank" rel="external">http://www.h3c.com.cn/MiniSite/Technology_Circle/Net_Reptile/The_Five/Home/Catalog/201206/747038_97665_0.htm</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NTA打洞&quot;&gt;&lt;a href=&quot;#NTA打洞&quot; class=&quot;headerlink&quot; title=&quot;NTA打洞&quot;&gt;&lt;/a&gt;NTA打洞&lt;/h1&gt;&lt;h2 id=&quot;只有一方处于NAT设备后&quot;&gt;&lt;a href=&quot;#只有一方处于NAT设备后&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="P2P" scheme="http://yoursite.com/tags/P2P/"/>
    
  </entry>
  
  <entry>
    <title>编译,汇编,反编译,反汇编</title>
    <link href="http://yoursite.com/2017/11/17/%E7%BC%96%E8%AF%91,%E6%B1%87%E7%BC%96,%E5%8F%8D%E7%BC%96%E8%AF%91,%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    <id>http://yoursite.com/2017/11/17/编译,汇编,反编译,反汇编/</id>
    <published>2017-11-17T09:13:19.000Z</published>
    <updated>2017-11-20T09:13:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译-汇编-反编译-反汇编"><a href="#编译-汇编-反编译-反汇编" class="headerlink" title="编译,汇编,反编译,反汇编"></a>编译,汇编,反编译,反汇编</h1><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><p>要理解这个问题，先要看「正」编译的过程是怎样的。你有一个想法，这是一种人类自然语言可以表达出来的东西。你利用编程技能，把它「翻译」成你熟悉的一种编程语言:<br><img src="https://pic1.zhimg.com/50/a8d9a453d077c8039f30841108969158_hd.png" alt="编程"><br>这个过程叫做编程。然后你使用编译器（compiler）将它翻译成机器所能理解的语言:</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><img src="https://pic2.zhimg.com/50/0b63c79d2e20558ddf5c8e56ef39cae5_hd.png" alt="编译"><br>这个过程叫做编译。编程和编译都是「信息丢失」的过程。比如你说，我有一组整数，我要把这些数排个序，然后轻车熟路地写了个冒泡排序。然而一定程度上，你的原始动机其实已经从代码里丢失了——有经验的人可以一眼看出这段代码是在排序，而新手小明看到的只有一些 for 和 if 之类的东西。如果是更复杂的功能，可能过一段时间你自己都看不懂自己当时是想干什么。从程序语言到机器语言的过程其实也是一样的。这两个过程其实都是把「做什么」转换成「怎么做」的过程，转换完成之后，究竟一开始是要做什么，这个信息已经丢失了。所谓「反编译」，其实就是找回这些丢失的信息的过程。从这个角度上来说，你阅读一段代码的过程，其实就是在将它「反编译」成自然语言。如果要完美地反编译，那只存在一种可能，就是信息完全没有丢失——比如说你阅读的这段代码有充分的注释，或者它使用了一种你所知晓的模式（这也是为什么大家一再强调注释和设计模式的重要性）。对于从机器语言到程序语言的反编译过程，也是一样。</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>比如说有比反编译更低级（非贬义）的过程，叫做反汇编:<br><img src="https://pic4.zhimg.com/50/120f4bdad94ab3198a606fe67a81f51b_hd.png" alt=""><br>严格来说汇编语言也是一种编程语言，不过我们在这里把它和我们常说的高级编程语言（包括C语言）区分开。这个步骤里，我在汇编和机器语言里使用的是双向实线箭头，因为它们是可以互相转换的。从汇编语言到机器语言的过程中没有丢失任何信息——因为两者的指令是一一对应的，因此反汇编可以轻松达成。这就是很多程序语言只能反汇编、不能（难以,下同）反编译的原因。一般我们管这种语言叫「编译语言」，又称「原生语言」。代表有C、C++等。</p><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p>那为什么有的语言可以反编译呢？这又要从机器语言说起。就像不同地域的人所用的语言不同一样，不同的机器说的语言也不尽相同。用行话说，叫「指令集不同」。比方说，你的电脑和你的手机，指令集通常是不一样的。一段程序要让不同的机器都能执行，只能分别翻译（编译）成相应的机器语言。这个过程太麻烦了，于是人们想了个办法，搞出了一种叫解释语言的东西（此处未考证解释语言是否就是因此发明的，只是帮助理解）。如下图：<br><img src="https://pic1.zhimg.com/50/f777de7083d68e0cbfe984fdad05651c_hd.png" alt=""><br>解释语言有两种执行方式，这取决于执行端的「解释器」是如何工作的。<br>一种是直接解释执行，中间就没有机器语言什么事情了，但这种方式效率很低。因此现代的解释语言基本上都会采用第二种方式，<br>也就是经由图中上部的路径，先通过JIT编译的方式翻译成机器语言，然后再执行，保证执行效率。JIT编译大致可以理解为「用到什么就编译什么」，这个过程常常是在执行过程中同步进行的。「解释器」的英文interpreter，其实就是名词「翻译」的意思。这好比你国外交部发了封文件到各国大使馆，再由大使馆的工作人员分别翻译成相应的语言，传达给目标国相关部门。代表性的解释语言如Javascript，它要在不同机器的浏览器上都能正确执行，所以采用这种方式。但是这样一来，程序代码就必须提供给每一台执行端机器了。这可是泄密啊。对于防止泄密，最直接的方式自然是加密。<br><img src="https://pic1.zhimg.com/50/922d6b8b311081bdcbc3889d42878594_hd.png" alt=""><br>有锁就有钥匙，同时也有开锁术；有加密解密，也有相应的破解方式。这时候所谓的「反编译」，其实就是破解加密算法。这一点就不展开聊了。</p><h2 id="字节码-中间语言"><a href="#字节码-中间语言" class="headerlink" title="字节码/中间语言"></a>字节码/中间语言</h2><p>后来，人们觉得解释语言执行得实在有点慢，于是又想了一个办法：把一些可以前期做掉的工作先做掉，只留着那些跟目标机器有关的工作，到时候再说。于是程序被处理成了一种叫做「中间语言」，或者叫「字节码」的东西：<br><img src="https://pic1.zhimg.com/50/3a2b234223758011a467be1eed3c4388_hd.png" alt=""><br>这个过程一般也叫做编译。中间语言词汇少，比较精炼，执行起来也更快。这些语言一般也会用上JIT技术，进一步把中间语言编译成机器语言（而非解释执行），执行效率也就跟那些原生的编译语言不相上下了。这种语言代表性的有C#、Java等。程序语言可以编译成中间语言，反过来，中间语言也可以在一定程度上反编译成程序语言。这是因为采用这种编译方式的编程语言为了保证它们的高级特性（比如说反射），在编译的过程中保留了源程序的绝大部分信息，只有很少的信息丢失；也正是因为丢失了这一部分信息，中间语言通常不能完美地反编译——最常见的就是反编译出来的程序中局部变量的名字都丢了，被替换成了由反编译器自动生成的名字。但这样反编译出来的程序，结构和功能都是完备的，可读性也有一定的保障。一般来说，我们所说的可以反编译的程序都是指这样一类语言写就的程序。中间语言可以被反编译；加密又会被破解，而且执行前还要解密，会带来额外的性能开销。有没有办法能让代码既能有效执行，又不被截获代码的人所利用呢?这时候人们从一些职业素养很差的程序员那里得到了启发。实现一个相同的功能，可以有无数种形式的代码。你恪尽职守，认认真真地写注释，准确地命名函数和变量， 严格按照规范进行缩进和换行;小明却相反，完全没有注释，变量全部用abcd乃至故意误导别人（var mySon = laowang.Son），缩进换行邋遢，尤其是在大括号前不换行，让大家很不满。于是老板想，我们先把小明开除掉，然后给你发奖金并要求大家按照你的方式写代码，并且开发一个工具，唤作「混淆器」，在发布时再把代码处理成小明写的那种样子：<img src="https://pic4.zhimg.com/50/3c927bee733da4bda3c01448f7a561f7_hd.png" data-rawwidth="760" data-rawheight="92" class="origin_image zh-lightbox-thumb" width="760" data-original="https://pic4.zhimg.com/3c927bee733da4bda3c01448f7a561f7_r.png">这样代码即使被反编译和解密了，别人看也看不懂，不小心还会被带到坑里去。代码毕竟是写给人看的，只是偶尔让机器跑一跑，所以没有可读性的代码是没有价值的。这种方法一出，广受好评，于是变成了一种非常普遍的做法。注意图中省略了中间代码和JIT的步骤，混淆通常会跟这些技术一起使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;编译-汇编-反编译-反汇编&quot;&gt;&lt;a href=&quot;#编译-汇编-反编译-反汇编&quot; class=&quot;headerlink&quot; title=&quot;编译,汇编,反编译,反汇编&quot;&gt;&lt;/a&gt;编译,汇编,反编译,反汇编&lt;/h1&gt;&lt;h2 id=&quot;编程&quot;&gt;&lt;a href=&quot;#编程&quot; cla
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>NAT与内网穿透</title>
    <link href="http://yoursite.com/2017/11/16/NAT%E4%B8%8E%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>http://yoursite.com/2017/11/16/NAT与内网穿透/</id>
    <published>2017-11-16T07:55:27.000Z</published>
    <updated>2017-11-17T02:30:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><h2 id="NAT是什么"><a href="#NAT是什么" class="headerlink" title="NAT是什么"></a>NAT是什么</h2><blockquote><p>网络地址转换,就是替换IP报文头部的地址信息.由于IPv4地址有限,不可能为每一个上网设备分配一个ip,而NAT就是来解决这个问题的.我们在上网时很有可能处在一个NAT设备之后, NAT设备会在ip包通过时会修改其 源/目标IP地址,有时还会修改TCP/UDP协议的端口号,从而实现多台设备使用同一外网IP进行互联网通讯</p></blockquote><p><img src="/images/NAT与内网穿透/NAT映射表.jpg" alt="NAT映射表.png"></p><p>如上,三台设备都使用<em>120.131.92.21</em>这一公网IP. 而对于这三台设备分别从各自端口发出的TCP/UDP请求,则映射至NAT设备不同的端口上,记录在NAT表上.这样就区分了某个请求试试来自哪个设备的哪个端口上.</p><h2 id="NAT特点"><a href="#NAT特点" class="headerlink" title="NAT特点"></a>NAT特点</h2><blockquote><p>1,网络被分为私网,公网两部分,NAT网关设置私网到公网的路由出口.<br>2,网络只能由私网侧发起,公网无法主动访问私网主机(是这样设计的,但是可以通过打洞)<br>3,NAT网关在两个访问方向上完成两次地址的转换,出口替换源地址,入口替换目的地址<br>4,NAT网关的存在对通信双方保持透明<br>5,NAT网关为了实现双向翻译,需要维持一张关联表,将会话信息保存</p></blockquote><h2 id="NAT的副作用"><a href="#NAT的副作用" class="headerlink" title="NAT的副作用"></a>NAT的副作用</h2><p>1,NAT表的淘汰</p><blockquote><p>当NAT表对应的记录在一段时间内没有通讯时,网络运营商就会将其淘汰掉,若此时外网还通过原来记录的外网IP地址和内网设备进行通讯则会不通.</p></blockquote><p>2,NAT墙</p><blockquote><p>当外界对内网的请求到达NAT设备时,若不符合NAT设备和NAT表的要求,<br>则会被丢弃,这样若想实现ip地址不固定客户端间通讯则需要额外的打洞操作<br>(需要心跳包刷新NAT表重置时间)</p></blockquote><p>3,端对端通信模型的破坏</p><blockquote><p>NAT实现了将多个内部主机发出的链接被复用到一个ip上,这样无法基于ip对主机进行追踪,这样服务器不能简单的将同一ip与主机挂钩.这样再统计信息和防止DDOS攻击时都会变得复杂, 有时,若-个NAT设备拥有多个IP地址时,一组关联的会话可能会被分配到不同公网ip里,总之NAT隐蔽了通讯的另一端.</p></blockquote><h2 id="NAT类型"><a href="#NAT类型" class="headerlink" title="NAT类型"></a>NAT类型</h2><p>1, <em>Full Cone NAT(完全雏形NAT)</em></p><blockquote><p>设备比较少,一旦内部主机端口在NAT网关完成端口映射,则后续外网任一主机都可以通过这映射好的端口进行访问</p></blockquote><p>2, <em>Restricted Cone NAT (限制雏形NAT)</em></p><blockquote><p>相较与全雏形NAT,在完成端口映射后,对IP地址有限制,只有内网对外访问过的ip地址才可以对该端口进行连接</p></blockquote><p>3, <em>Port Restricted Cone NAT(端口限制雏形NAT)</em></p><blockquote><p>相较于限制雏形NAT,在端口上也加以限制,<br>只有内网向该ip与端口发送过信息才能对其访问</p></blockquote><p>4, <em>Symmetric NAT (对称NAT)</em></p><blockquote><p>也就是说,虽然是同一个内网主机,对不同的外网ip+端口访问时,在NAT表上会映射成不同的端口号</p></blockquote><p><em>注意:</em></p><p>事实上，这些术语的引入是很多混淆的起源。现实中的很多NAT设备是将这些转换方式<strong>混合</strong>在一起工作的，而不单单使用一种，所以这些术语只适合描述一种<strong>工作方式</strong>，而不是一个设备。比如，很多NAT设备对内部发出的连接使用对称型NAT方式，而同时支持静态的端口映射，后者可以被看作是全锥型NAT方式。而有些情况下，NAT设备的一个公网地址和端口可以同时映射到内部几个服务器上以实现负载分担，比如一个对外提供WEB服务器的站点可能是有成百上千个服务器在提供HTTP服务，但是对外却表现为一个或少数几个IP地址。</p><h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><h2 id="应用层网管-ALG"><a href="#应用层网管-ALG" class="headerlink" title="应用层网管(ALG)"></a>应用层网管(ALG)</h2><blockquote><p>普通NAT实现了对UDP或TCP报文头中的的IP地址及端口转换功能，但对应用层数据载荷中的字段无能为力，在许多应用层协议中，比如多媒体协议（H.323、SIP等）、FTP、SQLNET等，TCP/UDP载荷中带有地址或者端口信息，这些内容不能被NAT进行有效的转换，就可能导致问题。而NAT ALG（Application Level Gateway，应用层网关）技术能对多通道协议进行应用层报文信息的解析和地址转换，将载荷中需要进行地址转换的IP地址和端口或者需特殊处理的字段进行相应的转换和处理，从而保证应用层通信的正确性。</p></blockquote><p>例如，FTP应用就由数据连接和控制连接共同完成，而且数据连接的建立动态地由控制连接中的载荷字段信息决定，这就需要ALG来完成载荷字段信息的转换，以保证后续数据连接的正确建立。</p><p><img src="/images/NAT与内网穿透/ALG_RTC.jpg" alt="图片.png"></p><p>图中私网侧的主机要访问公网的FTP服务器。NAT设备上配置了私网地址192.168.1.2到公网地址8.8.8.11的映射，实现地址的NAT转换，以支持私网主机对公网的访问。组网中，若没有ALG对报文载荷的处理，私网主机发送的PORT报文到达服务器端后，服务器无法根据私网地址进行寻址，也就无法建立正确的数据连接。整个通信过程包括如下四个阶段：</p><p>(1)    私网主机和公网FTP服务器之间通过TCP三次握手成功建立控制连接。</p><p>(2)    控制连接建立后，私网主机向FTP服务器发送PORT报文，报文中携带私网主机指定的数据连接的目的地址和端口，用于通知服务器使用该地址和端口和自己进行数据连接。</p><p>(3)    PORT报文在经过支持ALG特性的NAT设备时，<strong>报文载荷中的私网地址和端口会被转换成对应的公网地址和端口</strong>。即设备将收到的PORT报文载荷中的私网地址192.168.1.2转换成公网地址8.8.8.11，端口1084转换成12487。</p><p>(4)    公网的FTP服务器收到PORT报文后，解析其内容，并向私网主机发起数据连接，该数据连接的目的地址为8.8.8.11，目的端口为12487（注意：一般情况下，该报文源端口为20，但由于FTP协议没有严格规定，有的服务器发出的数据连接源端口为大于1024的随机端口，如本例采用的是wftpd服务器，采用的源端口为3004）。由于该目的地址是一个公网地址，因此后续的数据连接就能够成功建立，从而实现私网主机对公网服务器的访问。</p><p>总而言之,在ALG中配置的支持的协议,可以实现逆向访问</p><h2 id="中间件技术"><a href="#中间件技术" class="headerlink" title="中间件技术"></a>中间件技术</h2><blockquote><p>这也是一种通过开发通用方法解决NAT穿越问题的努力。与前者不同之处是，NAT网关是这一解决方案的参与者。与ALG的不同在于，客户端会参与网关公网映射信息的维护，此时NAT网关只要理解客户端的请求并按照要求去分配转换表，不需要自己去分析客户端的应用层数据。其中UPnP就是这样一种方法。UPnP中文全称为通用即插即用，是一个通用的网络终端与网关的通信协议，具备信息发布和管理控制的能力。其中，网关映射请求可以为客户动态添加映射表项。此时，NAT不再需要理解应用层携带的信息，只转换IP地址和端口信息。而客户端通过控制消息或信令发到公网侧的信息中，直接携带公网映射的IP地址和端口，接收端可以按照此信息建立数据连接。NAT网关在收到数据或连接请求时，按照UPnP建立的表项只转换地址和端口信息，不关心内容，再将数据转发到内网。这种方案需要网关、内部主机和应用程序都支持UPnP技术，且组网允许内部主机和NAT网关之间可以直接交换UPnP信令才能实施。</p></blockquote><h2 id="中继代理技术"><a href="#中继代理技术" class="headerlink" title="中继代理技术"></a>中继代理技术</h2><blockquote><p>准确说它不是NAT穿越技术，而是NAT旁路技术。简单说，就是在NAT网关所在的位置旁边放置一个应用服务器，这个服务器在内部网络和外部公网分别有自己的网络连接。客户端特定的应用产生网络请求时，将定向发送到应用代理服务器。应用代理服务器根据代理协议解析客户端的请求，再从服务器的公网侧发起一个新的请求，把客户端请求的内容中继到外部网络上，返回的相应反方向中继。这项技术和ALG有很大的相似性，它要求为每个应用类型部署中继代理业务，中间服务器要理解这些请求。</p></blockquote><h2 id="特定协议的自穿越技术"><a href="#特定协议的自穿越技术" class="headerlink" title="特定协议的自穿越技术"></a>特定协议的自穿越技术</h2><blockquote><p>在所有方法中最复杂也最可靠的就是自己解决自己的问题。比如IKE和IPsec技术，在设计时就考虑了到如何穿越NAT的问题。因为这个协议是一个自加密的协议并且具有报文防修改的鉴别能力，其他通用方法爱莫能助。因为实际应用的NAT网关基本都是NAPT方式，所有通过传输层协议承载的报文可以顺利通过NAT。IKE和IPsec采用的方案就是用UDP在报文外面再加一层封装，而内部的报文就不再受到影响。IKE中还专门增加了NAT网关是否存在的检查能力以及绕开NAT网关检测IKE协议的方法。</p></blockquote><h2 id="探针技术STUN和TURN"><a href="#探针技术STUN和TURN" class="headerlink" title="探针技术STUN和TURN"></a>探针技术STUN和TURN</h2><blockquote><p>所谓探针技术，是通过在所有参与通信的实体上安装探测插件，以检测网络中是否存在NAT网关，并对不同NAT模型实施不同穿越方法的一种技术。STUN服务器被部署在公网上，用于接收来自通信实体的探测请求，服务器会记录收到请求的报文地址和端口，并填写到回送的响应报文中。客户端根据接收到的响应消息中记录的地址和端口与本地选择的地址和端口进行比较，就能识别出是否存在NAT网关。如果存在NAT网关，客户端会使用之前的地址和端口向服务器的另外一个IP发起请求，重复前面的探测。然后再比较两次响应返回的结果判断出NAT工作的模式。由前述的一对多转换模型得知，除对称型NAT以外的模型，NAT网关对内部主机地址端口的映射都是相对固定的，所以比较容易实现NAT穿越。而对称型NAT为每个连接提供一个映射，使得转换后的公网地址和端口对不可预测。此时TURN可以与STUN绑定提供穿越NAT的服务，即在公网服务器上提供一个“地址端口对”，所有此“地址端口对”接收到的数据会经由探测建立的连接转发到内网主机上。TURN分配的这个映射“地址端口对”会通过STUN响应发给内部主机，后者将此信息放入建立连接的信令中通知通信的对端。这种探针技术是一种通用方法，不用在NAT设备上为每种应用协议开发功能，相对于ALG方式有一定普遍性。但是TURN中继服务会成为通信瓶颈。而且在客户端中增加探针功能要求每个应用都要增加代码才能支持。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NAT&quot;&gt;&lt;a href=&quot;#NAT&quot; class=&quot;headerlink&quot; title=&quot;NAT&quot;&gt;&lt;/a&gt;NAT&lt;/h1&gt;&lt;h2 id=&quot;NAT是什么&quot;&gt;&lt;a href=&quot;#NAT是什么&quot; class=&quot;headerlink&quot; title=&quot;NAT是什么&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="P2P" scheme="http://yoursite.com/tags/P2P/"/>
    
  </entry>
  
  <entry>
    <title>CocoaAsyncSocket实现局域网内通信</title>
    <link href="http://yoursite.com/2017/11/15/CocoaAsyncSocket%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2017/11/15/CocoaAsyncSocket实现局域网内通信/</id>
    <published>2017-11-15T01:16:26.000Z</published>
    <updated>2017-11-21T05:50:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CocoaAsyncSocket实现局域网内通信"><a href="#CocoaAsyncSocket实现局域网内通信" class="headerlink" title="CocoaAsyncSocket实现局域网内通信"></a>CocoaAsyncSocket实现局域网内通信</h1><h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><p>利用CocoaAsyncSocket实现局域网内 iOS设备间的简单通讯.</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,服务端,用于接受客户端连接.</span><br><span class="line">2,客户端,向服务端发起连接</span><br><span class="line">3,通讯协议,两端都遵守协议格式进行数据收发无误</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h2><p>非常简略的协议只为实现简单的文字通讯功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1,长度包: |内容包长度(8bit)|</span><br><span class="line">2,内容爆: |消息类型(1bit)|传输内容(不定)|</span><br></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>1,创建GCDSocket</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.socket = [[GCDAsyncSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_global_queue(0, 0)];</span><br><span class="line">//设置代理 和 代理队列,代理方法将在代理队列中执行</span><br><span class="line">//其实也可以为其中的socket通讯执行的队列,但是,队列须要为串行队列,保持数据成流</span><br></pre></td></tr></table></figure><p>2, 开始连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">///链接至指定ip</span><br><span class="line">-(BOOL)connectToIP:(NSString*)ip&#123;</span><br><span class="line">    NSError* err;</span><br><span class="line">    //此处端口号为服务端监听端口</span><br><span class="line">   [self.socket connectToHost:ip onPort:8866 error:&amp;err];</span><br><span class="line">    NSLog(@&quot;===%@===&quot;,err);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(uint16_t)port&#123;</span><br><span class="line">    //开始读取操作,因为为阻塞式,会等待直至有数据返回,进行读取</span><br><span class="line">    [self.socket readDataToLength:8 withTimeout:-1 tag:IMDataTag_Length];</span><br><span class="line">    NSLog(@&quot;===服务端接受链接===&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3,写入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//发送模型</span><br><span class="line">-(void)writeStr:(id&lt;IMModelProtocol&gt;)model&#123;</span><br><span class="line">//将要发送的模型转换为原始数据</span><br><span class="line">    NSData* data = [model getSendData];</span><br><span class="line"></span><br><span class="line">//发送数据长度包,表示后续内容包的长度</span><br><span class="line">    [self.socket writeData:[data subdataWithRange:NSMakeRange(0, 8)] withTimeout:-1 tag:0];</span><br><span class="line"></span><br><span class="line">//发送内容包    </span><br><span class="line">    [self.socket writeData:[data subdataWithRange:NSMakeRange(8, data.length-8)] withTimeout:-1 tag:0];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4,读取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-(void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag&#123;</span><br><span class="line">    switch (tag) &#123;</span><br><span class="line">        case IMDataTag_Length:  //获得长度</span><br><span class="line">            self.currentDataLength = [self.analy getDataTotalLength:data];</span><br><span class="line">            //获取长度后,进行内容读取</span><br><span class="line">            [self.socket readDataToLength:self.currentDataLength withTimeout:-1 tag:IMDataTag_Content];</span><br><span class="line">            break;</span><br><span class="line">        case IMDataTag_Content: //获得内容</span><br><span class="line">        &#123;</span><br><span class="line">        </span><br><span class="line">        //将原始数据转换为需要的模型(我讲模型与Data转化的方法为了简介提到了外面)</span><br><span class="line">            id&lt;IMModelProtocol&gt; model = [self.analy getIMDataModelWithTotalLength:self.currentDataLength andData:data];</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:IMGetModelNoti object:model];</span><br><span class="line">            [self.socket readDataToLength:8 withTimeout:-1 tag:IMDataTag_Length];</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>1,创建接口监听的socket</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//此socket用来监听接口,是否有服务端链接</span><br><span class="line">self.socket = [[GCDAsyncSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_global_queue(0, 0)];</span><br><span class="line"></span><br><span class="line">//监听 8886接口</span><br><span class="line">[self.socket acceptOnPort:8866 error:nil];</span><br></pre></td></tr></table></figure><p>2,接受到客户端链接请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//当接受到链接请求时 回调该代理方法</span><br><span class="line">-(void)socket:(GCDAsyncSocket *)sock didAcceptNewSocket:(GCDAsyncSocket *)newSocket&#123;</span><br><span class="line"></span><br><span class="line">// newSocket是对客户端链接的封装,若想保持连接,则将newSocket持有</span><br><span class="line">// 对客户端的 断开,读取,写入都是对newSocket进行的</span><br><span class="line">    self.clientSsocket = newSocket;</span><br><span class="line">    newSocket.delegate = self.clientDelegate;</span><br><span class="line">    [newSocket setDelegateQueue:dispatch_get_global_queue(0, 0)];</span><br><span class="line">    //直接开始读取(因为为阻塞式的)</span><br><span class="line">    [newSocket readDataToLength:8 withTimeout:-1 tag:IMDataTag_Length];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后对newSocket的读写操作就和客户端一样了.<br>效果如下,一个是虚拟机,一个是真机</p><p><img src="/images/CocoaAsyncSocket实现局域网内通信/Socket.gif" alt="效果图"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>应为NAT的存在,所以这里只实现了在局域网下的通讯,若想实现真正的想微信那样的通讯, 还需要自己再路由器下映射的端口号,实现内网穿透, 此外 还有很多细节需要实现~~ 路漫漫其修远兮~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CocoaAsyncSocket实现局域网内通信&quot;&gt;&lt;a href=&quot;#CocoaAsyncSocket实现局域网内通信&quot; class=&quot;headerlink&quot; title=&quot;CocoaAsyncSocket实现局域网内通信&quot;&gt;&lt;/a&gt;CocoaAsyncSock
      
    
    </summary>
    
    
      <category term="iOS网络" scheme="http://yoursite.com/tags/iOS%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>iOS中使用Protocol Buffer</title>
    <link href="http://yoursite.com/2017/11/03/iOS%E4%B8%AD%E4%BD%BF%E7%94%A8Protocol%20Buffer/"/>
    <id>http://yoursite.com/2017/11/03/iOS中使用Protocol Buffer/</id>
    <published>2017-11-03T08:49:15.000Z</published>
    <updated>2017-11-21T05:50:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS中使用Protocol-Buffer"><a href="#iOS中使用Protocol-Buffer" class="headerlink" title="iOS中使用Protocol Buffer"></a>iOS中使用Protocol Buffer</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Protocol Buffer(简称Protobuf或PB)是由Google推出的一种数据交换格式.<br>与传统的XML和JSON不同的是,它是一种二进制格式,免去了文本格式转换的各种困扰,并且转换效率也是非常快,由于它的跨平台、跨编程语言的特点,让它越来越普及,尤其是网络数据交换方面日趋成为一种主流.</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>对于json和xml最终在网络传输时都是以字符串转二进制的进行传输的,使用的是utf8编码格式,而PB在编码与解码上进行了改进,使数据包更小,所以我觉得可以把他当做一种压缩格式.这里有一篇关于原理的博文,感兴趣大家可以去看一看  <a href="http://blog.csdn.net/carson_ho/article/details/70568606" target="_blank" rel="external">Protocol Buffer 序列化原理大揭秘 - 为什么Protocol Buffer性能这么好？</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我们需要安装PB的编译器,将我们用PB语法格式创建的对象转化为OC或Swift的对象,原来PB只支持Python,Java,C++,现在新的版本支持OC,Swift需要我们额外配置一下,期待以后的更新吧.<a href="https://github.com/google/protobuf/releases" target="_blank" rel="external">这是github的链接</a></p><p>解压缩后,cd到其目录下执行下面的终端命令进行安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./autogen.sh</span><br><span class="line">$ ./configure</span><br><span class="line">$ make</span><br><span class="line">$ make check</span><br><span class="line">$ sudo install</span><br></pre></td></tr></table></figure><p>安装结束后,执行 protoc –version ,若有显示版本号,则表明安装成功.若是要试用Swift则需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ brew install protobuf-swift</span><br><span class="line">$ git clone https://github.com/alexeyxo/protobuf-swift.git</span><br><span class="line">//cd到clone后的目录</span><br><span class="line">$ ./scripts/build.sh</span><br></pre></td></tr></table></figure><p>接下来就是创建proto文件,将其翻译为OC或Swift,所以先了解proto的语法</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>接下来我只介绍些常用语法,这里有介绍语法比较详细的博文 <a href="http://www.qingpingshan.com/rjbc/ios/255983.html" target="_blank" rel="external">这是一份很有诚意的Protocol Buffer语法详解</a>    <a href="http://colobu.com/2017/03/16/Protobuf3-language-guide/" target="_blank" rel="external">Protobuf3 语法指南 </a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//表示使用的是PB3的语法</span><br><span class="line">syntax = &quot;proto3&quot;; </span><br><span class="line"></span><br><span class="line">//message代表着一个数据结构,也就相当于一个类, 类名Person </span><br><span class="line">message Person &#123;</span><br><span class="line">  string name = 1;  </span><br><span class="line">  int32 age = 2;</span><br><span class="line">  repeated int32 friends = 3;</span><br><span class="line">  //这里就相当于类中的属性,string表示类型为字符串,name表示属性名,数字1则是用来标识Person中的属性,在编解码时用到,使用从1递增即可,这样效率高些</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是关于PB的数据结构类型,因为要控制数据编码后大小,所以类型比较多</p><p><img src="/images/iOS中使用Protocol Buffer/PB支持的数据类型.png" alt="PB支持的数据类型"></p><p>对应到iOS的OC和Swift中,上面就包含了所需的基本数据类型了,一个message,其实就可以看做一个字典.至于数组就比较特别了,而是要在基本的数据结构前 加上可复用的修饰符 <strong>repeated</strong> 就如上面的friends一样.</p><h2 id="编译转换"><a href="#编译转换" class="headerlink" title="编译转换"></a>编译转换</h2><p>OC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进入proto文件目录 执行下面的命令</span><br><span class="line">$ protoc --objc_out=./ ./test.proto</span><br></pre></td></tr></table></figure><p>Swift</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进入proto文件目录 执行下面的命令</span><br><span class="line">$ mbp$ protoc --swift_out=./ ./test.proto</span><br></pre></td></tr></table></figure><p>这样就得到了,翻译后所需的类文件了,接下来就要到项目中集成了</p><h2 id="项目集成"><a href="#项目集成" class="headerlink" title="项目集成"></a>项目集成</h2><p>在项目中使用PB需要使用第三方库,可以使用CocoaPod集成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OC:</span><br><span class="line">pod &quot;Protobuf&quot;</span><br><span class="line"></span><br><span class="line">Swift:</span><br><span class="line">pod &apos;ProtocolBuffers-Swift&apos;</span><br></pre></td></tr></table></figure><p>对于OC版本,拖进项目后要再做一些额外处理,生成的是MRC环境下的代码,需要设置一下, 其次再编译后会报一些错误,据我所知的处理方案是将其注释掉(我了解到的是该方法在C99后失效了,至于为何这里还有,我也很无奈ㄟ( ▔, ▔ )ㄏ,到Github上反应了).这样就可以使用了. 然后就是PB的序列化与反序列化</p><h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><p>OC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Person* p = [Person new];</span><br><span class="line">p.name = @&quot;南小鸟&quot;;</span><br><span class="line">p.age = 18;</span><br><span class="line">p.friendsArray = [GPBInt32Array array]; //这是里面的数组,其他方法可以点进去看</span><br><span class="line">[p.friendsArray addValue:10];</span><br><span class="line"></span><br><span class="line">NSString* jsonStr = @&quot;&#123;\&quot;name\&quot;:\&quot;南小鸟\&quot;,\&quot;age\&quot;:18,\&quot;friendsArray\&quot;:[10]&#125;&quot;;</span><br><span class="line"></span><br><span class="line">NSData* data = [p data];    //序列化</span><br><span class="line">NSData* strData = [jsonStr dataUsingEncoding:(NSUTF8StringEncoding)];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;PB --&gt; %ld  JSON --&gt; %ld&quot;,data.length,strData.length);</span><br><span class="line"></span><br><span class="line">//反序列化</span><br><span class="line">Person* res = [[Person alloc] initWithData:data error:nil];</span><br><span class="line">NSLog(@&quot;%@,%ld,%@&quot;,res.name,res.age,res.friendsArray);</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PB --&gt; 16  JSON --&gt; 49</span><br><span class="line">南小鸟,18,&lt;GPBInt32Array 0x600000059200&gt; &#123; 10 &#125;</span><br></pre></td></tr></table></figure><p>Swift</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//创建新的对象,通过Builder来进行创建,赋值.</span><br><span class="line">    let p = Person.Builder()</span><br><span class="line">    p.name = &quot;南小鸟&quot;</span><br><span class="line">    p.age = 18</span><br><span class="line">    p.friends = [10]</span><br><span class="line"></span><br><span class="line">//getMessage可以得到该对象,然后将其序列化</span><br><span class="line">    let data = p.getMessage().data()</span><br><span class="line">    </span><br><span class="line">//将其反序列化,可能出错,需要try</span><br><span class="line">    let res = try! Person.parseFrom(data: data)</span><br></pre></td></tr></table></figure><p>最后说一说PB的优缺点</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1,数据压缩效果好,序列化反序列速度快</span><br><span class="line">2,跨平台,生成一次proto文件,多端使用</span><br></pre></td></tr></table></figure><p>缺点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,可读性行差(在代码中)</span><br><span class="line">2,最增加App包体积(生成的类本身就代码很多,而且需要使用第三方库)</span><br><span class="line">3,用的人少(在项目交接时,还需要学习这方面的知识)</span><br></pre></td></tr></table></figure><p>综上:个人觉得该方案适用于大量频繁的数据交流业务中,如IM<br>若有不准确的地方,欢迎大家指正</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS中使用Protocol-Buffer&quot;&gt;&lt;a href=&quot;#iOS中使用Protocol-Buffer&quot; class=&quot;headerlink&quot; title=&quot;iOS中使用Protocol Buffer&quot;&gt;&lt;/a&gt;iOS中使用Protocol Buffer&lt;/
      
    
    </summary>
    
    
      <category term="iOS网络" scheme="http://yoursite.com/tags/iOS%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>iOS自动打包脚本上传至蒲公英</title>
    <link href="http://yoursite.com/2017/09/26/iOS%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E8%84%9A%E6%9C%AC%E4%B8%8A%E4%BC%A0%E8%87%B3%E8%92%B2%E5%85%AC%E8%8B%B1/"/>
    <id>http://yoursite.com/2017/09/26/iOS自动打包脚本上传至蒲公英/</id>
    <published>2017-09-26T14:06:53.000Z</published>
    <updated>2017-11-21T08:25:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS自动打包脚本上传至蒲公英"><a href="#iOS自动打包脚本上传至蒲公英" class="headerlink" title="iOS自动打包脚本上传至蒲公英"></a>iOS自动打包脚本上传至蒲公英</h1><h1 id="自动打包分为两部分"><a href="#自动打包分为两部分" class="headerlink" title="自动打包分为两部分"></a>自动打包分为两部分</h1><blockquote><p>-生成archive文件<br>-从archive文件中导出ipa包</p></blockquote><h2 id="生成archive包"><a href="#生成archive包" class="headerlink" title="生成archive包"></a>生成archive包</h2><p>  在这里就需要使用到xcodebuild命令 </p><p>对于普通的project命令为:</p><blockquote><p>xcodebuild archive -project project的名称.xcodeproj -scheme 应用名称 -configuration 构造配置 -archivePath 期望保存的路径</p><p>对于workspace 则命令为<br>xcodebuild archive -workspace workspace的名称.xcworkspace -scheme 应用名称 -configuration 构造配置 -archivePath 期望保存的路径</p></blockquote><p>关于exportOptionPlist 是打包的配置信息(如是否支持bitecode,证书与描述文件…..)大概如下<br><img src="/images/iOS自动打包脚本上传至蒲公英/OptionPlist.png" alt="OptionPlist.png"></p><p>在我的脚本中并没有对其进行自动生成,我的建议是手动打包一次 然后在打好的包中找到该文件保存起来 一劳永逸</p><h2 id="导出ipa包"><a href="#导出ipa包" class="headerlink" title="导出ipa包"></a>导出ipa包</h2><p>当archive文件生成成功后 则须从中导出ipa包</p><blockquote><p>xcodebuild -exportArchive -archivePath archive文件路径 -exportPath 打包后期望保存的路径 -exportOptionsPlist 导出配置的相关信息的plist文件</p></blockquote><h1 id="上传至蒲公英"><a href="#上传至蒲公英" class="headerlink" title="上传至蒲公英"></a>上传至蒲公英</h1><p>根据蒲公英文档 API2.0 命令行如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -F &apos;file=@ipa包的路径&apos; -F &apos;_api_key=蒲公英提供的AppKey&apos; https://www.pgyer.com/apiv2/app/upload</span><br></pre></td></tr></table></figure><blockquote><p>在了解的步骤之后 只需要脚本将这些命令行组合起来 在其中插入自己需要的操作,如对测试人员的通知,当前状态的输出等等….(我没有这块的需求,就没有写了)</p></blockquote><p>最后附上代码 因为代码不长 我就直接写在这里了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env python3</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">#######################  须用户配置   ##############################</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#将要上新的版本描述</span><br><span class="line">updateDescription = &apos;&apos;</span><br><span class="line"></span><br><span class="line"># 项目路径</span><br><span class="line">projectPath = &apos;&apos;</span><br><span class="line"></span><br><span class="line"># 项目名称</span><br><span class="line">projectName = &apos;</span><br><span class="line"></span><br><span class="line"># 打包路径</span><br><span class="line">IPASavePath = &apos;&apos;</span><br><span class="line"></span><br><span class="line"># exportOptionPlist文件路径</span><br><span class="line">exportOptionPlistPath = &apos;&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#蒲公英App_Key</span><br><span class="line">pgy_appKey = &apos;&apos;</span><br><span class="line"></span><br><span class="line">##################################################################</span><br><span class="line">#生成的Archive文件的路径</span><br><span class="line">archivePath = IPASavePath + &apos;/&apos; +projectName + &apos;Archive&apos;</span><br><span class="line"></span><br><span class="line">#生成的ipa包的路径</span><br><span class="line">IpaPath = IPASavePath + &apos;/Apps/&apos; + projectName + &apos;.ipa&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 清屏</span><br><span class="line">def clearScreen():</span><br><span class="line">    os.system(&apos;clear&apos;)</span><br><span class="line">    os.chdir(projectPath)</span><br><span class="line"></span><br><span class="line"># 生成archive文件</span><br><span class="line">def makeArchive():</span><br><span class="line">    os.system(&apos;xcodebuild archive -workspace %s.xcworkspace -scheme %s -configuration Release -archivePath %s&apos;%(projectName,projectName,archivePath))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 生成iPa包</span><br><span class="line">def makeIpa():</span><br><span class="line">    os.system(&apos;xcodebuild -exportArchive -archivePath %s.xcarchive -exportPath %s -exportOptionsPlist %s&apos;%(archivePath,IPASavePath,exportOptionPlistPath))</span><br><span class="line"></span><br><span class="line"># 上传至蒲公英</span><br><span class="line">def upLoadToPGYer():</span><br><span class="line"></span><br><span class="line">     res = (os.popen(&quot;curl -F &apos;file=@%s&apos; -F &apos;_api_key=%s&apos; -F&apos;updateDescription=%s&apos; https://www.pgyer.com/apiv2/app/upload&quot;%(IpaPath,pgy_appKey,updateDescription))).readlines()</span><br><span class="line"></span><br><span class="line"> #自动打包</span><br><span class="line">def automaticPack():</span><br><span class="line">    clearScreen()</span><br><span class="line">    makeArchive()</span><br><span class="line">    makeIpa()</span><br><span class="line">    upLoadToPGYer()</span><br><span class="line"></span><br><span class="line">automaticPack()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS自动打包脚本上传至蒲公英&quot;&gt;&lt;a href=&quot;#iOS自动打包脚本上传至蒲公英&quot; class=&quot;headerlink&quot; title=&quot;iOS自动打包脚本上传至蒲公英&quot;&gt;&lt;/a&gt;iOS自动打包脚本上传至蒲公英&lt;/h1&gt;&lt;h1 id=&quot;自动打包分为两部分&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="iOS效率" scheme="http://yoursite.com/tags/iOS%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
</feed>
