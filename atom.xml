<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DearMiku</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-19T09:03:26.011Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>杨尚达</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>隐私协议</title>
    <link href="http://yoursite.com/2018/10/19/%E9%9A%90%E7%A7%81%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2018/10/19/隐私协议/</id>
    <published>2018-10-19T09:03:16.000Z</published>
    <updated>2018-10-19T09:03:26.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="隐私协议"><a href="#隐私协议" class="headerlink" title="隐私协议"></a>隐私协议</h1><p> 本应用尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本应用会按照本隐私权政策的规定使用和披露您的个人信息。但本应用将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本应用不会将这些信息对外披露或向第三方提供。本应用会不时更新本隐私权政策。 您在同意本应用服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本应用服务使用协议不可分割的一部分。</p><h2 id="1-适用范围"><a href="#1-适用范围" class="headerlink" title="1. 适用范围"></a>1. 适用范围</h2><p>(a) 在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您的浏览器和计算机上的信息，包括但不限于您的IP地址、浏览器的类型、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据；</p><p>您了解并同意，以下信息不适用本隐私权政策：</p><p>(a) 本应用收集到的您在本应用发布的有关信息数据，包括但不限于参与活动、成交信息及评价详情；</p><p>(b) 违反法律规定或违反本应用规则行为及本应用已对您采取的措施。</p><h2 id="2-信息使用"><a href="#2-信息使用" class="headerlink" title="2. 信息使用"></a>2. 信息使用</h2><p>(a)本应用不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。</p><p>(b) 本应用亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。</p><h2 id="3-信息披露"><a href="#3-信息披露" class="headerlink" title="3. 信息披露"></a>3. 信息披露</h2><p>在如下情况下，本应用将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息：</p><p>(a) 经您事先同意，向第三方披露；</p><p>(b)为提供您所要求的产品和服务，而必须和第三方分享您的个人信息；</p><p>(c) 根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露；</p><p>(d) 如您出现违反中国有关法律、法规或者本应用服务协议或相关规则的情况，需要向第三方披露；</p><p>(e) 如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷；</p><p>(f) 在本应用平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，本应用有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。</p><p>(g) 其它本应用根据法律、法规或者网站政策认为合适的披露。</p><h2 id="4-信息存储和交换"><a href="#4-信息存储和交换" class="headerlink" title="4. 信息存储和交换"></a>4. 信息存储和交换</h2><p>本应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。</p><h2 id="5-Cookie的使用"><a href="#5-Cookie的使用" class="headerlink" title="5. Cookie的使用"></a>5. Cookie的使用</h2><p>(a) 在您未拒绝接受cookies的情况下，本应用会在您的计算机上设定或取用cookies ，以便您能登录或使用依赖于cookies的本应用平台服务或功能。本应用使用cookies可为您提供更加周到的个性化服务，包括推广服务。</p><p>(b) 您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的本应用网络服务或功能。</p><p>(c) 通过本应用所设cookies所取得的有关信息，将适用本政策。</p><h2 id="6-信息安全"><a href="#6-信息安全" class="headerlink" title="6. 信息安全"></a>6. 信息安全</h2><p>(a) 本应用帐号均有安全保护功能，请妥善保管您的用户名及密码信息。本应用将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。</p><p>(b) 在使用本应用网络服务进行网上交易时，您不可避免的要向交易对方或潜在的交易对</p><h2 id="7-本隐私政策的更改"><a href="#7-本隐私政策的更改" class="headerlink" title="7.本隐私政策的更改"></a>7.本隐私政策的更改</h2><p>(a)如果决定更改隐私政策，我们会在本政策中、本公司网站中以及我们认为适当的位置发布这些更改，以便您了解我们如何收集、使用您的个人信息，哪些人可以访问这些信息，以及在什么情况下我们会透露这些信息。</p><p>(b)本公司保留随时修改本政策的权利，因此请经常查看。如对本政策作出重大更改，本公司会通过网站通知的形式告知。</p><p>请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息泄密，尤其是本应用用户名及密码发生泄露，请您立即联络本应用客服，以便本应用采取相应措施。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;隐私协议&quot;&gt;&lt;a href=&quot;#隐私协议&quot; class=&quot;headerlink&quot; title=&quot;隐私协议&quot;&gt;&lt;/a&gt;隐私协议&lt;/h1&gt;&lt;p&gt; 本应用尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本应用会按照本隐私权政策的规定使用和披
      
    
    </summary>
    
    
      <category term="开源" scheme="http://yoursite.com/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>Flask + Gunicorn + Nginx 部署</title>
    <link href="http://yoursite.com/2018/09/19/Flask%20+%20Gunicorn%20+%20Nginx%20%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2018/09/19/Flask + Gunicorn + Nginx 部署/</id>
    <published>2018-09-19T07:01:21.000Z</published>
    <updated>2018-09-19T07:02:06.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flask-Gunicorn-Nginx-部署"><a href="#Flask-Gunicorn-Nginx-部署" class="headerlink" title="Flask + Gunicorn + Nginx 部署"></a>Flask + Gunicorn + Nginx 部署</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记录我<strong>AWS</strong>上部署Flask服务器的过程~ 希望能帮到有需要的人, 由于本人水平有限,难免有错误与遗漏的地方~ 还请大家多多指正~ (๑•ᴗ•๑)</p><h1 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h1><h2 id="Gunicorn"><a href="#Gunicorn" class="headerlink" title="Gunicorn"></a>Gunicorn</h2><p>这里就要先说到<strong>WSGI</strong>,它是一个协议,定义与协调Python程序与请求之间的接口,常用的WSGI容器有Gunicorn和uWSGI,Gunicorn更加快捷,所以选择<strong>Gunicorn</strong></p><h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h2><p>Flask是一个基于Python的Web开发微框架,借助Web框架,我们就不用关心请求,响应这些底层的实现,而专注于业务的实现~ 而Flask相比于其他框架更加轻量,自由度更高,所以这里我选择了<strong>Flask</strong></p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx 是一个异步框架的Web服务器,我将它部署在<strong>Gunicorn</strong>前面,通过反向代理连接. 其实不加Nginx也是可以的,但是加上<strong>Nginx</strong>有更多好处, 例如 静态文件支持,负载均衡等等,以后我会再研究研究,单独写一篇博文的~</p><h2 id="架构预览"><a href="#架构预览" class="headerlink" title="架构预览"></a>架构预览</h2><p>如图~<br><img src="/images/FlaskGunicornNginx部署/15372567633419.jpg" alt=""></p><h1 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h1><p>部署的服务器是 AWS 上的 CentOS 服务器, 使用的是Python3.7.0,而AWS上是默认Python2.7的,所以第一步是 安装Python3 环境</p><h2 id="安装Python3环境"><a href="#安装Python3环境" class="headerlink" title="安装Python3环境"></a>安装Python3环境</h2><h3 id="下载-解压安装包"><a href="#下载-解压安装包" class="headerlink" title="下载,解压安装包"></a>下载,解压安装包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz</span><br><span class="line"></span><br><span class="line">tar -zxvf Python-3.7.0.tgz</span><br></pre></td></tr></table></figure><h3 id="编译-安装Python3"><a href="#编译-安装Python3" class="headerlink" title="编译,安装Python3"></a>编译,安装Python3</h3><p>在Linux上我们需要先安装 <strong>gcc</strong> 编译器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install gcc gcc-c++ </span><br><span class="line">sudo yum -y install zlib zlib-devel</span><br><span class="line">sudo yum -y install libffi-devel</span><br></pre></td></tr></table></figure><p>然后cd当解压目录中进行 编译安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd Python-3.7.0/</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="修改软链接"><a href="#修改软链接" class="headerlink" title="修改软链接"></a>修改软链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#移除原有软链接</span><br><span class="line">rm -f /usr/bin/&#123;python,python3&#125; </span><br><span class="line"></span><br><span class="line">#创建新的软连接</span><br><span class="line">ln -s /usr/local/python3.7.0/bin/python3.7 /usr/bin/python </span><br><span class="line">ln -s /usr/local/python3.7.0/bin/python3.7 /usr/bin/python3</span><br></pre></td></tr></table></figure><h3 id="修改-yum"><a href="#修改-yum" class="headerlink" title="修改 yum"></a>修改 yum</h3><p>将 首行 的配置修改为Python3.7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/bin/yum</span><br><span class="line"></span><br><span class="line">将 &quot;#!/usr/bin/python&quot; 修改为 &quot;#!/usr/bin/python2.7&quot;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>这是我们查看Python版本 就如下~</p><p><img src="/images/FlaskGunicornNginx部署/15372618364668.png" alt=""></p><h2 id="pip3的安装"><a href="#pip3的安装" class="headerlink" title="pip3的安装"></a>pip3的安装</h2><p>使用Python3自然要使用pip3了,下面是pip3的安装方法</p><h3 id="安装解压-pip3"><a href="#安装解压-pip3" class="headerlink" title="安装解压 pip3"></a>安装解压 pip3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ wget --no-check-certificate https://github.com/pypa/pip/archive/9.0.1.tar.gz</span><br><span class="line"></span><br><span class="line">$ tar -zvxf 9.0.1 -C pip-9.0.1   </span><br><span class="line"></span><br><span class="line">$ cd pip-9.0.1</span><br><span class="line"></span><br><span class="line"># 使用 Python 3 安装</span><br><span class="line">$ python3 setup.py install</span><br></pre></td></tr></table></figure><h3 id="创建软连接与更新"><a href="#创建软连接与更新" class="headerlink" title="创建软连接与更新"></a>创建软连接与更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/local/python3/bin/pip /usr/bin/pip3 </span><br><span class="line"></span><br><span class="line">pip install --upgrade pip</span><br></pre></td></tr></table></figure><p>此时,可能会报错误 <strong>/usr/bin/pip: No such file or directory</strong> 此时是因为pip升级后位置更改为<strong>/usr/local/bin/pip</strong>,所以要更新缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash -r</span><br></pre></td></tr></table></figure><h2 id="配置虚拟环境"><a href="#配置虚拟环境" class="headerlink" title="配置虚拟环境"></a>配置虚拟环境</h2><p>接下来就是要配置Python3的虚拟环境,避免相互影响</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade virtualenv</span><br><span class="line"></span><br><span class="line">#在需要的目录下创建</span><br><span class="line">virtualenv -p python3 venv</span><br><span class="line"></span><br><span class="line"># 激活</span><br><span class="line">source venv/bin/activate</span><br></pre></td></tr></table></figure><h2 id="配置Flask-和-Git"><a href="#配置Flask-和-Git" class="headerlink" title="配置Flask 和 Git"></a>配置Flask 和 Git</h2><p>这里就是用pip安装自己需要的Web框架了,这里我就先只安装了一个<strong>Flask</strong>,然后用Git部署代码,因为现阶段代码比较简单,所以没用<strong>fabric</strong>,后续有时间我会研究研究~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask</span><br></pre></td></tr></table></figure><h2 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h2><p><strong>Nginx</strong>的安装很简单,只需要一条命令~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install nginx</span><br></pre></td></tr></table></figure><p>然后修改<strong>Nginx</strong>的配置文件 路径在 <strong>/etc/nginx/nginx.conf</strong>,主要是修改监听端口和root路径,</p><p>我是这样改的~ 监听5000端口,  root指向我存放代码的Git仓库</p><p><img src="/images/FlaskGunicornNginx部署/165f098e3a9b90aa.png" alt="screenshot"></p><p>这样基本就可以了,然后是配置Gunicorn</p><h2 id="Gunicorn-1"><a href="#Gunicorn-1" class="headerlink" title="Gunicorn"></a>Gunicorn</h2><p>这里也很简单,名利如下~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 安装</span><br><span class="line"> pip install gunicorn</span><br><span class="line"> </span><br><span class="line"> #启动</span><br><span class="line"> gunicorn -w4 -b 0.0.0.0:5000 app:app</span><br></pre></td></tr></table></figure><p>若出现无法启动<strong>Gunicorn</strong>服务的情况,有可能设置的端口已经被占用了~ 比如我 上次连接断开前没中止,就出现了 无法启动的情况~</p><p>如果一切正常的,访问ip就能正常展示了~~如果不能访问,建议排除是不是网关设置的问</p><p><img src="/images/FlaskGunicornNginx部署/screenshot.png" alt="screenshot"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flask-Gunicorn-Nginx-部署&quot;&gt;&lt;a href=&quot;#Flask-Gunicorn-Nginx-部署&quot; class=&quot;headerlink&quot; title=&quot;Flask + Gunicorn + Nginx 部署&quot;&gt;&lt;/a&gt;Flask + Gunic
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习--协程--asyncio</title>
    <link href="http://yoursite.com/2018/09/07/Python%E5%AD%A6%E4%B9%A0%E5%8D%8F%E7%A8%8Basyncio/"/>
    <id>http://yoursite.com/2018/09/07/Python学习协程asyncio/</id>
    <published>2018-09-07T05:12:12.000Z</published>
    <updated>2018-09-12T07:23:15.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python学习–协程–asyncio"><a href="#Python学习–协程–asyncio" class="headerlink" title="Python学习–协程–asyncio"></a>Python学习–协程–asyncio</h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>协程是一种用户态的轻量级线程，协程的<strong>调度</strong>完全由用户控制。协程拥有自己的寄存器上下文和栈。</p><p>协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p><p>本人也是刚刚开始学习Python,难免有错误与疏漏还望多多指正~(づ￣3￣)づ╭❤～</p><p><a href="https://www.zhihu.com/question/20511233" target="_blank" rel="external">知乎上关于协程的一个问题~</a></p><p><a href="http://lotabout.me/2017/understand-python-asyncio/" target="_blank" rel="external">关于asyncio理解的博客</a></p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="协程函数"><a href="#协程函数" class="headerlink" title="协程函数"></a>协程函数</h2><p>在函数前加<strong>async</strong>前缀,则表示该函数为协程函数~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">async def coroutine(i): pass</span><br></pre></td></tr></table></figure><p>这样 <strong>coroutine(1)</strong>则不再是调用函数,而是返回一个协程对象</p><p>判断一个对象是否为<strong>协程对象</strong>,返回 布尔值~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asyncio.iscoroutine(coroutine(1))</span><br></pre></td></tr></table></figure><p>确保对象为协程对象,若是协程对象则返回,若不是则抛出错误~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ob = asyncio.ensure_future(coroutine(1))</span><br></pre></td></tr></table></figure><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>我的理解是这样的~ <strong>asyncio</strong>通过运行循环来接受事件,进行统一调度,以实现协程的效果~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop = asyncio.get_event_loop()         #创建循环</span><br><span class="line"></span><br><span class="line">loop.run_until_complete(coroutine(1))   #添加协程</span><br></pre></td></tr></table></figure><p>这样 协程对象就进行执行了~</p><h2 id="协程效果实现"><a href="#协程效果实现" class="headerlink" title="协程效果实现"></a>协程效果实现</h2><p>协程要实现的效果之一,就是要实现函数的有序执行~ 当一个函数执行完后,再去执行下面的函数~ 通过<strong>await</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">#协程1</span><br><span class="line">async def coroutine(i):</span><br><span class="line">    print(&quot;协程执行 %s&quot; % i)</span><br><span class="line">    res = await someFunction()</span><br><span class="line">    print(&quot;协程%s 返回功能为 %s&quot; % (i,res))</span><br><span class="line"></span><br><span class="line">#协程2</span><br><span class="line">async def someFunction():</span><br><span class="line">    print(&quot;运行部分功能&quot;)</span><br><span class="line">    await asyncio.sleep(1) #休息1s 模拟耗时操作</span><br><span class="line">    return &quot;功能结果&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()         #创建循环</span><br><span class="line"></span><br><span class="line">loop.run_until_complete(coroutine(1))   #执行任务</span><br></pre></td></tr></table></figure><p>执行结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">协程执行 1</span><br><span class="line">运行部分功能</span><br><span class="line">返回功能为 功能结果</span><br></pre></td></tr></table></figure><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>当协程方法执行完毕后进行回调~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">#协程1</span><br><span class="line">async def coroutine(i):</span><br><span class="line">    print(&quot;协程执行 %s&quot; % i)</span><br><span class="line">    </span><br><span class="line">#回调</span><br><span class="line">def callbackFunc(po):</span><br><span class="line">    print(&apos;执行回调~ &apos;)</span><br><span class="line">    </span><br><span class="line">loop = asyncio.get_event_loop()         #创建循环</span><br><span class="line"></span><br><span class="line">ob = asyncio.ensure_future(coroutine(1))</span><br><span class="line"></span><br><span class="line">ob.add_done_callback(callbackFunc)</span><br><span class="line"></span><br><span class="line">loop.run_until_complete(ob)</span><br></pre></td></tr></table></figure><p>运行结果如下,作为回调的函数,需要接受一个传入参数(回调该函数的协程对象~),</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">协程执行 1</span><br><span class="line">执行回调~</span><br></pre></td></tr></table></figure><h2 id="多协程对象并发执行"><a href="#多协程对象并发执行" class="headerlink" title="多协程对象并发执行~"></a>多协程对象并发执行~</h2><p>效果就和多线程并发执行一样~ 下面是示例代码~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">#协程1</span><br><span class="line">async def coroutine(i):</span><br><span class="line">    print(&quot;协程执行 %s&quot; % i)</span><br><span class="line">    res = await someFunction()</span><br><span class="line">    print(&quot;协程%s 返回功能为 %s&quot; % (i,res))</span><br><span class="line"></span><br><span class="line">#协程2</span><br><span class="line">async def someFunction():</span><br><span class="line">    print(&quot;运行部分功能&quot;)</span><br><span class="line">    await asyncio.sleep(1) #休息1s 模拟耗时操作</span><br><span class="line">    return &quot;功能结果&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()         #创建循环</span><br><span class="line"></span><br><span class="line">coArr = [coroutine(1),coroutine(2),coroutine(3)]</span><br><span class="line"></span><br><span class="line">ob = asyncio.gather(*coArr)</span><br><span class="line"></span><br><span class="line">loop.run_until_complete(ob)   #执行任务</span><br></pre></td></tr></table></figure><p>运行效果如下~~~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">协程执行 3</span><br><span class="line">运行部分功能</span><br><span class="line">协程执行 2</span><br><span class="line">运行部分功能</span><br><span class="line">协程执行 1</span><br><span class="line">运行部分功能</span><br><span class="line">协程3 返回功能为 功能结果</span><br><span class="line">协程2 返回功能为 功能结果</span><br><span class="line">协程1 返回功能为 功能结果</span><br><span class="line"></span><br><span class="line">结束</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python学习–协程–asyncio&quot;&gt;&lt;a href=&quot;#Python学习–协程–asyncio&quot; class=&quot;headerlink&quot; title=&quot;Python学习–协程–asyncio&quot;&gt;&lt;/a&gt;Python学习–协程–asyncio&lt;/h1&gt;&lt;h1 i
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>HandyJSON实现方案浅析</title>
    <link href="http://yoursite.com/2018/04/10/HandyJSON%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2018/04/10/HandyJSON实现方案浅析/</id>
    <published>2018-04-10T09:09:26.000Z</published>
    <updated>2018-09-12T07:23:15.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HandyJSON实现方案浅析"><a href="#HandyJSON实现方案浅析" class="headerlink" title="HandyJSON实现方案浅析"></a>HandyJSON实现方案浅析</h1><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>近日,由于Swift升级,导致一段时间<strong>HandyJSON</strong>无法使用,借这个机会将<strong>HandyJSON</strong>好好学习了一下~ 然后从另一种方式实现了类似OC的<strong>KVC</strong>效果的一个小Demo,通过本文记录一些自己的收获,旨在抛砖引玉,有错误的地方还请多多指正 ~ (๑•ᴗ•๑)</p><p>好了,下面先从Swift的类型结构开始谈起吧~</p><h1 id="MetaDate"><a href="#MetaDate" class="headerlink" title="MetaDate"></a>MetaDate</h1><p>Swift在运行时为程序中的每个类型都保留了元数据用于记录(类比OC的元类),包括每个泛型类型的实例.这些数据都是由编译器静态生成,且每种类型都有唯一的元数据记录.元数据在运行时根据需要进行延迟创建~ <strong>MetaData</strong>的信息 就存储在<strong>类别指针</strong>的第一个字节中.</p><p>Swift将<strong>MetaData</strong>做以下分类~ </p><p><img src="/images/HandyJSON实现方案浅析/screenshot2.png" alt="screenshot"></p><p>现在主要关注 <strong>Class</strong>和<strong>Struct</strong>中, 先说<strong>Class</strong> 从上面文档中的描述 我们可知 所有Apple平台的Swift的类都要与OC的类交互,也就是说 Swift的<strong>类别指针</strong>就是<strong>isa</strong>指针.</p><p>所以<strong>Swift</strong>和<strong>OC</strong>Class 在本质上是一样,只不过Swift剔除其中的动态特性~ 这也是<strong>Swift</strong>和<strong>OC</strong>间可以无缝交互的原因之一 ~</p><p> 上面的内容是Swift Github的文档,大家感兴趣可以看看~ <a href="https://github.com/apple/swift/blob/master/docs/ABI/TypeMetadata.rst#common-metadata-layout" target="_blank" rel="external">Type MetaData文档</a>接下来 我先分析下<strong>HandyJSON</strong>的实现方式,然后再说说我自己的实现方式.</p><h1 id="HandyJSON"><a href="#HandyJSON" class="headerlink" title="HandyJSON"></a>HandyJSON</h1><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p><strong>HandyJSON</strong>的实现的内容大概是这样的:JSON转字典,同时处理自定义映射的内容 –&gt; 获取<strong>对象/结构体</strong> 属性的内存位置,然后将值写入~  而其中最核心的内容就是 获取<strong>对象/结构体</strong>的属性列表与偏移量.</p><p><strong>HandyJSON</strong>是通过元数据的<strong>Nominal Type Descriptor</strong>来获取的~ 这是定义的结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct _NominalTypeDescriptor &#123;</span><br><span class="line">    var mangledName: Int32</span><br><span class="line">    var numberOfFields: Int32</span><br><span class="line">    var fieldOffsetVector: Int32</span><br><span class="line">    var fieldNames: Int32</span><br><span class="line">    var fieldTypesAccessor: Int32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个结构体中就包含了全部需要的内容,只要得到它,接下来就是将内容写入和封装的事了~ 下面就是获取<strong>_NominalTypeDescriptor</strong>的代码,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    var nominalTypeDescriptor: NominalTypeDescriptor? &#123;</span><br><span class="line">        let pointer = UnsafePointer&lt;Int&gt;(self.pointer)</span><br><span class="line">        let base = pointer.advanced(by: nominalTypeDescriptorOffsetLocation)</span><br><span class="line">        if base.pointee == 0 &#123;</span><br><span class="line">            // swift class created dynamically in objc-runtime didn&apos;t have valid nominalTypeDescriptor</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        #if swift(&gt;=4.1) || (swift(&gt;=3.3) &amp;&amp; !swift(&gt;=4.0))</span><br><span class="line">        return NominalTypeDescriptor(pointer: relativePointer(base: base, offset: base.pointee - base.hashValue))</span><br><span class="line">        #else</span><br><span class="line">        return NominalTypeDescriptor(pointer: relativePointer(base: base, offset: base.pointee))</span><br><span class="line">        #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分内容也是在Swift更新后出问题的地方.在文档中关于这里的部分表示<strong>Warning: this is all out of date!</strong>,可能作者是通过Swift源码分享确定<strong>_NominalTypeDescriptor</strong>的位置的吧~</p><p>我这里就是简单介绍一下,详细的内容 大家还是去看<a href="https://github.com/alibaba/HandyJSON" target="_blank" rel="external">HandyJSON</a>源码吧~ 接下来是我的实现思路</p><h1 id="我的实现方式"><a href="#我的实现方式" class="headerlink" title="我的实现方式"></a>我的实现方式</h1><p>我实现的效果大概如下,还有不少瑕疵需要改进,但基本做到<strong>KVC</strong>的效果了~<br><img src="/images/HandyJSON实现方案浅析/screenshot.png" alt="screenshot"></p><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>对于<strong>Class</strong>我的思路是这样的,由文档可知,我们能获得<strong>isa</strong>指针,接下来要做的就是根据OC runtime源码,实现其中需要的类型,然后通过指针进行类型强制转换,这样就得到 我们需要的内容了~</p><p>但是 我在实现这块的时候 出现了一些问题 对于<strong>ivar</strong>结构体时,获取的内容与<strong>runtime</strong>中的有差异,而且只能获取 属性名称和偏移量(主要这里有些困惑,若有懂的老铁 还请指点一下~)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct MK_ivar &#123;</span><br><span class="line">    </span><br><span class="line">    var mask1:Int32</span><br><span class="line">    </span><br><span class="line">    var off:UnsafePointer&lt;CChar&gt;</span><br><span class="line">    </span><br><span class="line">    var name:UnsafePointer&lt;CChar&gt;</span><br><span class="line">    </span><br><span class="line">    var mask2:UInt32</span><br><span class="line">    var mask3:UInt32</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于属性类型 我则是通过<strong>Mirror</strong>来获取的,这样就得到需要的全部信息了.</p><h2 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h2><p><strong>Struct</strong>则很简单了,在<strong>Mirror</strong>中获取属性的顺序和结构体中分部的属性是一样的,通<strong>Mirror</strong>获取属性类型,然后推断出它在结构体中填充的大小,这样各个属性的偏移量就得到了,接下来只要将<strong>Value</strong>写入就好了~</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是我写的<a href="https://github.com/dearmiku/MK_Swift_ORM" target="_blank" rel="external">小Demo</a>,简单实现了<strong>KVC</strong>的效果,还有一些瑕疵~后续我可能会将它封装成库玩一玩,若感觉对你有帮助的话 可以点个Star (๑•ᴗ•๑)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HandyJSON实现方案浅析&quot;&gt;&lt;a href=&quot;#HandyJSON实现方案浅析&quot; class=&quot;headerlink&quot; title=&quot;HandyJSON实现方案浅析&quot;&gt;&lt;/a&gt;HandyJSON实现方案浅析&lt;/h1&gt;&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="第三方框架学习" scheme="http://yoursite.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MK_Text富文本处理Lable 兼容iOS和OSX</title>
    <link href="http://yoursite.com/2018/02/22/%E5%85%BC%E5%AE%B9iOS%E4%B8%8EOSX%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%AF%8C%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86Label%20(%E8%87%AA%E5%B7%B1%E9%80%A0%E7%9A%84%E5%B0%8F%E8%BD%AE%E5%AD%90)/"/>
    <id>http://yoursite.com/2018/02/22/兼容iOS与OSX的轻量级富文本处理Label (自己造的小轮子)/</id>
    <published>2018-02-22T02:16:26.000Z</published>
    <updated>2018-09-12T07:23:15.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>最近开发的OSX应用时,一些地方需要用到图文混排,与可点击文字的地方,这时我就特别怀念在iOS用的<strong>YYText</strong>,然后转念一想,反正快过年了时间比较富裕就自己造一个轮子吧,所以就写了<strong>MK_Text</strong></p><p>目前就完成了<strong>YYLabel</strong>的大部分功能,但基本够用了,后续我也会去丰富里面的功能,大家有什么想法也可以提,如果我觉得比较实用我也会尽力去实现的~  接下来我就介绍下<strong>MK_Text</strong>吧~</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>github链接:<a href="https://github.com/dearmiku/MK_Text" target="_blank" rel="external">MK_Text</a><br><a href="https://raw.githubusercontent.com/dearmiku/MK_Text/master/LICENSE" target="_blank" rel="external"><img src="https://img.shields.io/badge/license-MIT-green.svg?style=flat" alt="License MIT"></a> <a href="https://www.apple.com/nl/ios/" target="_blank" rel="external"><img src="https://img.shields.io/badge/support-iOS%208%2B%20-blue.svg?style=flat" alt="Support"></a> <a href="https://www.apple.com/nl/macos" target="_blank" rel="external"><img src="https://img.shields.io/badge/support-OSX%2010.10%2B%20-blue.svg?style=flat" alt="Support"></a> <a href=""><img src="https://img.shields.io/cocoapods/p/MK_Text.svg?style=flat" alt="CocoaPods"></a></p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><blockquote><p>支持图文混排,支持富文本与View混排</p><p>支持异步排版渲染</p><p>支持高亮文字设置</p><p>支持OSX 与 iOS</p><p>支持自动布局</p></blockquote><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="图文混排"><a href="#图文混排" class="headerlink" title="图文混排"></a>图文混排</h2><p>可自定义图片显示大小,默认显示图片原始大小~</p><p>可是设置图片与其所在子行的对其方式,默认为与字行中线一致~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let imStr = NSMutableAttributedString.mk_image(im: MK_Image.init(named: NSImage.Name.init(&quot;face&quot;))!, size: CGSize.init(width: 30, height: 30), alignType: NSMutableAttributedString.AlignType.top)</span><br><span class="line"></span><br><span class="line">//控件的用法与图片基本一致</span><br><span class="line"></span><br><span class="line">let v = UISwitch.init()</span><br><span class="line">let viewStr = NSMutableAttributedString.mk_view(view: v, superView: ml, size: v.bounds.size)</span><br></pre></td></tr></table></figure><h2 id="高亮文字"><a href="#高亮文字" class="headerlink" title="高亮文字"></a>高亮文字</h2><p>使用高亮属性时需先创建<strong>MK_TapResponse</strong>结构体,可选返回两个闭包: 1,高亮时的富文本属性~ 2,完成点击时回调的闭包~</p><p>这里判断点击是否完成的逻辑与Button一致~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let tap = NSMutableAttributedString.init(string: &quot;可点击字符&quot;)</span><br><span class="line">let response = MK_TapResponse.init(highlitedBlock: &#123; (str) -&gt; [NSAttributedStringKey : Any]? in</span><br><span class="line">    return [NSAttributedStringKey.foregroundColor : UIColor.red]</span><br><span class="line">&#125;) &#123; (str, range) in</span><br><span class="line">    print(&quot;点击字符串~&quot;)</span><br><span class="line">&#125;</span><br><span class="line">tap.addTapAttr(response: response, range: nil)</span><br></pre></td></tr></table></figure><h2 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h2><p>通过<strong>MK_Label</strong>的 alignment属性 进行设置(默认为左对齐),此处以居中对此为例子</p><p><img src="https://github.com/dearmiku/MK_Text/blob/master/Image/%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90.png?raw=true" alt="居中对齐效果图"></p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>目前只实现了上述的功能,其他功能会在后续丰富~</p><p><img src="https://raw.githubusercontent.com/dearmiku/MK_Text/master/Image/iOS%E6%95%88%E6%9E%9C%E5%9B%BE.gif" alt="iOS效果图"></p><p><img src="https://raw.githubusercontent.com/dearmiku/MK_Text/master/Image/OSX%E6%95%88%E6%9E%9C%E5%9B%BE.gif" alt="OSX效果图"></p><h2 id="异步渲染"><a href="#异步渲染" class="headerlink" title="异步渲染"></a>异步渲染</h2><p>通过设置 Label的<strong>isAsync</strong>属性来确定~ 默认为false</p><h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><h3 id="中途修改富文本属性"><a href="#中途修改富文本属性" class="headerlink" title="中途修改富文本属性"></a>中途修改富文本属性</h3><p>若需要在修改富文本属性的同时刷新UI界面,请使用下面这个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public func mk_setAttrtbute(dic:[NSAttributedStringKey : Any], range: NSRange)-&gt;Void</span><br></pre></td></tr></table></figure><h3 id="自动布局"><a href="#自动布局" class="headerlink" title="自动布局"></a>自动布局</h3><p><strong>MK_Text</strong>对于自动约束的支持是参照<strong>UILabel</strong>来做的, 当View的<strong>translatesAutoresizingMaskIntoConstraints</strong>为true时, 则按照View的frame进行渲染. </p><p>若为false,则会判断约束是否约束到宽高, 若约束到 则按约束的宽高进行渲染,若未约束到,则会根据渲染内容来补充宽高约束~</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h2><p>在 Podfile 中添加 pod ‘MK_Text’</p><h1 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h1><p>OSX 10.10 或 iOS 8.0</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本框架测试的不多(就我一个人测),若大家发现Bug或有什么好想法 欢迎提Issues,感觉还不错的话可以点个Star (๑•ᴗ•๑)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;最近开发的OSX应用时,一些地方需要用到图文混排,与可点击文字的地方,这时我就特别怀念在iOS用的&lt;strong&gt;YYText&lt;/stron
      
    
    </summary>
    
    
      <category term="开源" scheme="http://yoursite.com/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>Mac开发---NSDocument</title>
    <link href="http://yoursite.com/2017/12/29/Mac%E5%BC%80%E5%8F%91---NSDocument/"/>
    <id>http://yoursite.com/2017/12/29/Mac开发---NSDocument/</id>
    <published>2017-12-29T03:06:29.000Z</published>
    <updated>2018-09-12T07:23:15.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac开发—NSDocument"><a href="#Mac开发—NSDocument" class="headerlink" title="Mac开发—NSDocument"></a>Mac开发—NSDocument</h1><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>最近在写的App是这种这种类型的,总结了总结,写了这篇博文,本文旨在介绍如何实现 基于文档的Mac App 若有描述不准确或错误的地方 还望多多指正,共同学习(๑•ᴗ•๑)</p><p>实现的效果也就是 在文档的打开方式中有自己的App可选,将文件拖拽至Dock栏中可以打开~</p><h1 id="NSDocument"><a href="#NSDocument" class="headerlink" title="NSDocument"></a>NSDocument</h1><p><code>NSDocument</code>类相当于一层封装~ ,类似于<code>UIImage</code>,无论是jpg格式还是png格式都以<code>UIImage</code>对象进行调用~</p><p><code>NSDocument</code>则不仅可以对外持有 文档数据, 对内可以绑定 窗口控制器~.当打开文档时自动创建并展示与其绑定的窗口控制器~</p><p>Xcode提供的Document模板大概就是下面这个样子~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import Cocoa</span><br><span class="line"></span><br><span class="line">class Document: NSDocument &#123;</span><br><span class="line">    var saveData:Data!</span><br><span class="line"></span><br><span class="line">    //是否自动保存(出用户选择外的所有保存方式 都是非自动保存,像按钮..点击的方法中可以保存,其他的不能)</span><br><span class="line">    override class var autosavesInPlace: Bool &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //用于为Document绑定WindowController,当打开新的Document时,对应的WindowController就会被打开~(不绑定也是可以的)</span><br><span class="line">    override func makeWindowControllers() &#123;</span><br><span class="line">        let storyboard = NSStoryboard(name: NSStoryboard.Name(&quot;Main&quot;), bundle: nil)</span><br><span class="line">        let windowController = storyboard.instantiateController(withIdentifier: NSStoryboard.SceneIdentifier(&quot;Document Window Controller&quot;)) as! NSWindowController</span><br><span class="line">        self.addWindowController(windowController)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将当前文档保存时调用</span><br><span class="line">    override func data(ofType typeName: String) throws -&gt; Data &#123;</span><br><span class="line">        Swift.print(&quot;保存文件&quot;)</span><br><span class="line">        return saveData</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //当读取新的数据时调用</span><br><span class="line">    override func read(from data: Data, ofType typeName: String) throws &#123;</span><br><span class="line">        saveData = data</span><br><span class="line">        Swift.print(&quot;读取内容 来自\(self.fileURL)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //自动保存时调用的方法~ 当前是否能判断是否</span><br><span class="line">    override func autosave(withImplicitCancellability autosavingIsImplicitlyCancellable: Bool, completionHandler: @escaping (Error?) -&gt; Void) &#123;</span><br><span class="line">        Swift.print(&quot;调用自动保存&quot;)</span><br><span class="line"></span><br><span class="line">        //completionHandler(nil)</span><br><span class="line">        completionHandler(NSError.init(domain: &quot;错误提示&quot;, code: 0, userInfo: nil))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="NSDocumentController"><a href="#NSDocumentController" class="headerlink" title="NSDocumentController"></a>NSDocumentController</h1><p>顾名思义是负责对<code>Document</code>进行管理,是一个单例~ 方法也就主要是下面这些~</p><h2 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSDocumentController.shared.newDocument(nil)</span><br><span class="line">//也可以直接init一个Document,然后加进去</span><br></pre></td></tr></table></figure><h2 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//用户通过面板打开一个新的Document </span><br><span class="line">NSDocumentController.shared.openDocument(nil)</span><br><span class="line"></span><br><span class="line">//这里也可以使用NSDocument的init方法创建(使用的重载方法不同),但是这样创建的对象不再NSDocumentController的管理内~ 可以手动加入其中</span><br></pre></td></tr></table></figure><h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//保存所有文档</span><br><span class="line">NSDocumentController.shared.saveAllDocuments(nil)</span><br><span class="line"></span><br><span class="line">//也可以调用NSDocument的save方法</span><br></pre></td></tr></table></figure><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里应该调用的是 Document的 saveAs()/saveTo() 方法, 为了工整一些 我就放在这里了~</span><br></pre></td></tr></table></figure><h1 id="info-plist配置"><a href="#info-plist配置" class="headerlink" title="info.plist配置"></a>info.plist配置</h1><p>对<code>NSDocument</code>类支持的文档类型和导出的文档类型是在 <code>info.plist</code>中存储的~ 我们可以在Targets-&gt;info中进行设置~ 需要对<strong>Document Type</strong>和<strong>Export UTIs</strong>进行设置~~</p><p><img src="/images/Mac开发---NSDocument/screenshot1.png" alt="screenshot"></p><p>这里就引入了一个概念<strong>UTI</strong>,它是Apple系统处理文档文件等数据的统一类型标识符,也可以把它理解为苹果爸爸对其他各类文档数据的别名,大家叫<code>jpg</code>,苹果爸爸叫它<code>public.jpeg</code>.除去UTI中约定好的部分,对于 我们自创的类型,则可以设置自创的别名~ 在这里我就使用已有类型了<code>jpg</code> 其他的<strong>UTI</strong>看这里<a href="https://developer.apple.com/library/content/documentation/Miscellaneous/Reference/UTIRef/Articles/System-DeclaredUniformTypeIdentifiers.html#//apple_ref/doc/uid/TP40009259-SW1" target="_blank" rel="external">Uniform Type Identifies</a></p><h2 id="Document-Types"><a href="#Document-Types" class="headerlink" title="Document Types"></a>Document Types</h2><p><strong>Name</strong>: 文档的类型名称,可为空~</p><p><strong>identifer</strong>: 文档标识,若是用自定义的类型,这里可以写自定义的类型.若是针对已有类型可以在UTI中找~</p><p><strong>Class</strong>: 标识该类型对应在项目中的Document类,我使用的继承<code>NSDocument</code>的子类 MK_Document,所以这里填 <code>$(PRODUCT_MODULE_NAME).MK_Document</code></p><p><strong>Roler</strong>: 这里表示应用对文档的处理权限, Editor(读写),Viewer(只读). </p><p><strong>Extensions</strong>: 文档后缀,不区别大小写~</p><p><strong>Icon</strong>: 自定义类型在Finder中显示的样子(有时候可以,有时候不行,就和我用Movist看<code>mkv</code>视频,有时候可以带上Movist图标,有时候不行~ 要有懂这个图片设置的老铁 分享一蛤~)</p><p>至于其他的一些选项,我没用到</p><p>至于下面那个<code>additional document type properties</code>是设置额外的文档属性,在旧版Xcode中Document Types在这里的选项并没有这么多,那个时候需要用它设置额外的一些属性,我用的Xcode9上面提供的选项已经够用了~~</p><p>当我们设置多个Document Type且绑定至同一个Document上时,在新建的文档保存/导出时,会让我们选择格式~<br><img src="/images/Mac开发---NSDocument/screenshot3.png" alt="screenshot"></p><h2 id="Export-UTLs"><a href="#Export-UTLs" class="headerlink" title="Export UTLs"></a>Export UTLs</h2><p>若是App只是使用已有的文档类型如<code>jpg</code>,则是在Document Types中设置就已经足够了,但是若要试用自定义类型的话,则需要用到</p><p><img src="/images/Mac开发---NSDocument/screenshot2.png" alt="screenshot"></p><p>这里就简单展示了一下自定义类型,需要注意的是 上面除了<code>Description</code>外都是必填的~</p><p><strong>identifer</strong>和<strong>Extension</strong>这里是自定以的~怎么写都好~ 但是上下要一致</p><p><strong>Conforms To</strong>这里我填写的是<code>public.data</code>,这里到底写什么,可以在UTIs中按需选择~</p><p>效果如下~~<br><img src="/images/Mac开发---NSDocument/miku.png" alt="miku"></p><h1 id="FileWrapper"><a href="#FileWrapper" class="headerlink" title="FileWrapper"></a>FileWrapper</h1><p>有些时候,我们的文档并非只是一个文档,还有类似于<code>bundle</code>这种类型的文档包,(在这里吐槽一句,其实MarkDown也应该做成文档包这种样式就好了~) 效果如下<br><img src="/images/Mac开发---NSDocument/wrap.png" alt="wrap"></p><p>配置FileWrapper和上面略有不同~ </p><h2 id="infor配置"><a href="#infor配置" class="headerlink" title="infor配置"></a>infor配置</h2><p><img src="/images/Mac开发---NSDocument/screenshot4.png" alt="screenshot"></p><p>主要就是将<strong>Conforms To</strong>改一下~ 然后在<strong>Document</strong>中实现对应的<code>NSFileWrape</code>方法 其他地方也就是换汤不换药</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//保存时调用</span><br><span class="line">override func fileWrapper(ofType typeName: String) throws -&gt; FileWrapper &#123;</span><br><span class="line">    let  fileWrappers  = FileWrapper(directoryWithFileWrappers: [:])</span><br><span class="line"></span><br><span class="line">    return fileWrappers</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//读取时调用~ 包中的数据可以通过 filleWraper</span><br><span class="line">override func read(from fileWrapper: FileWrapper, ofType typeName: String) throws &#123;</span><br><span class="line">    for item in fileWrapper.fileWrappers! &#123;</span><br><span class="line">        Swift.print(&quot;获得\(item.key)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>NSDocument</code>是 对文档的封装,无论面对什么样的文档 都是NSDocument对象,和 NSData一样~ 这种设计方案是是值得我们借鉴的 尤其是在写SDK时~ </p><p>若上文有不准确的地方 还望多多指正 共同学习 (๑•ᴗ•๑)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mac开发—NSDocument&quot;&gt;&lt;a href=&quot;#Mac开发—NSDocument&quot; class=&quot;headerlink&quot; title=&quot;Mac开发—NSDocument&quot;&gt;&lt;/a&gt;Mac开发—NSDocument&lt;/h1&gt;&lt;h1 id=&quot;简述&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Mac开发" scheme="http://yoursite.com/tags/Mac%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES on iOS --- Assimp</title>
    <link href="http://yoursite.com/2017/12/25/OpenGL%20ES%20on%20iOS%20---%20Assimp/"/>
    <id>http://yoursite.com/2017/12/25/OpenGL ES on iOS --- Assimp/</id>
    <published>2017-12-25T05:27:28.000Z</published>
    <updated>2018-09-12T07:23:15.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenGL-ES-on-iOS-—-Assimp"><a href="#OpenGL-ES-on-iOS-—-Assimp" class="headerlink" title="OpenGL ES on iOS — Assimp"></a>OpenGL ES on iOS — Assimp</h1><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文主要记录 Assimp库的编译和使用,可能会有不准确的地方,还望多多指正共同学习~</p><p>Assimp是Open Asset Import Library（开放的资产导入库）的缩写。Assimp能够导入很多种不同的模型文件格式（并也能够导出部分的格式），它会将所有的模型数据加载至Assimp的通用数据结构中</p><h1 id="Assimp编译"><a href="#Assimp编译" class="headerlink" title="Assimp编译"></a>Assimp编译</h1><p>这里是库的github地址<a href="https://github.com/assimp/assimp" target="_blank" rel="external">Assimp</a>,下载下来 我们还要编译成iOS可用的库(这里踩坑不少/(ㄒoㄒ)/~~)</p><h2 id="配置CMAKE环境"><a href="#配置CMAKE环境" class="headerlink" title="配置CMAKE环境"></a>配置CMAKE环境</h2><p>CMake是个开源的跨平台自动化建构系统,想要编译Assimp 先要配置好它~ <a href="https://cmake.org/" target="_blank" rel="external">CMake官网</a></p><p>然后将Cmake链接至终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo &quot;/Applications/CMake.app/Contents/bin/cmake-gui&quot; --install</span><br></pre></td></tr></table></figure><h2 id="编译-Assimp-a"><a href="#编译-Assimp-a" class="headerlink" title="编译 Assimp.a"></a>编译 Assimp.a</h2><p>切换至目标路径<br><img src="/images/OpenGL ES on iOS --- Assimp/screenshot1.png" alt="screenshot"></p><p>执行下面命令~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将你需要支持的架构输入 一般就是X86 和 arm64 </span><br><span class="line">./build.sh --stdlib=libc++ --archs=&quot;arm64 x86_64&quot;</span><br></pre></td></tr></table></figure><p>这是你的 lib文件夹下就是这个样子的~<br><img src="/images/OpenGL ES on iOS --- Assimp/screenshot2.png" alt="screenshot"><br>但是这样子 还是不能在iOS上用的哦~ 因为 <code>XML.a</code>只支持 X86架构~ 我们还需要额外编译它</p><h2 id="XML-a"><a href="#XML-a" class="headerlink" title="XML.a"></a>XML.a</h2><p>这时就要使用CMake客户端了~ 创建一个空的build文件夹~,使用Xcode 默认配置生成~<br><img src="/images/OpenGL ES on iOS --- Assimp/screenshot3.png" alt="screenshot"><br><img src="/images/OpenGL ES on iOS --- Assimp/screenshot4.png" alt="screenshot"><br>这时就根据需要编译出自己需要的静态库即可了~~</p><p><img src="/images/OpenGL ES on iOS --- Assimp/screenshot5.png" alt="screenshot"></p><h1 id="Assimp使用"><a href="#Assimp使用" class="headerlink" title="Assimp使用"></a>Assimp使用</h1><h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><p><img src="/images/OpenGL ES on iOS --- Assimp/15141653578382.jpg" alt=""></p><p>当Assimp加载模型时,会将模型数据加载到Scene(场景)对象中. </p><p>Scene中会有一个Mesh(网格)对象,在Mesh中包含着渲染所需的所有数据,如顶点,法向量,纹理坐标…<br>在Mesh中包含一个Material对象,其中是关于材质的数据(镜面贴图,漫反射贴图,法向量贴图….)<br>在Mesh中还包含了许多Face,Face其实是指物体的渲染图元,一个面包含了组成图元的顶点索引(这里其实就相当于之前讲到的EBO)</p><p>Scene中会包含一个根节点,在根节点之下会有很多子节点~节点中有指向Mesh中数据的索引</p><p>所以我们需要做的就是将Scene中的节点遍历,然后将节点中的数据提取出来,以适合的格式输入到着色器中~~(๑•ᴗ•๑)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>定义 Mesh类 和 Model类<br>Mesh类对应每个节点的网格数据,Model则对应Scene对象~</p><p>我展示的代码主要是和Assimp相关的内容~</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;assimp/Importer.hpp&quot;</span><br><span class="line">#include &quot;assimp/scene.h&quot;</span><br><span class="line">#include &quot;assimp/postprocess.h&quot;</span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//顶点</span><br><span class="line">struct Vertex &#123;</span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">    glm::vec3 Normal;</span><br><span class="line">    glm::vec2 TexCoords;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Vertex &#123;</span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">    glm::vec3 Normal;</span><br><span class="line">    glm::vec2 TexCoords;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Mesh &#123;</span><br><span class="line">    std::vector&lt;Vertex&gt; vertices;       //顶点</span><br><span class="line">    std::vector&lt;unsigned int&gt; indices;  //索引</span><br><span class="line">    std::vector&lt;Texture&gt; textures;      //纹理</span><br><span class="line">    </span><br><span class="line">    unsigned int VAO, VBO, EBO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">class Model&#123;</span><br><span class="line">    std::vector&lt;Texture&gt; textures_loaded;   //缓冲纹理,避免多次加载</span><br><span class="line">    std::vector&lt;Mesh&gt; meshes;               //节点数据数组</span><br><span class="line">    std::string directory;                  //加载路径</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="加载Scene"><a href="#加载Scene" class="headerlink" title="加载Scene"></a>加载Scene</h3><h4 id="遍历根节点及其下属所有子节点"><a href="#遍历根节点及其下属所有子节点" class="headerlink" title="遍历根节点及其下属所有子节点"></a>遍历根节点及其下属所有子节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Assimp::Importer import;</span><br><span class="line"></span><br><span class="line">//获取Scene</span><br><span class="line">const aiScene *scene = import.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs);</span><br><span class="line"></span><br><span class="line">if(!scene || scene-&gt;mFlags &amp; AI_SCENE_FLAGS_INCOMPLETE || !scene-&gt;mRootNode)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;ERROR::ASSIMP:: %s&quot;,import.GetErrorString());</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">directory = path.substr(0, path.find_last_of(&apos;/&apos;));</span><br><span class="line"></span><br><span class="line">processNode(scene-&gt;mRootNode, scene);</span><br></pre></td></tr></table></figure><p><code>ReadFile</code>将指定路径的模型加载,Path为路径,后面的是加载时的额外处理 </p><blockquote><p><code>aiProcess_Triangulate</code>将加载的图元变换为三角形<br><code>aiProcess_FlipUVs</code>翻转纹理坐标Y轴(OpenGL的纹理Y轴是翻的~)<br><code>aiProcess_GenNormals</code> 若模型不包含法向量的话，就为每个顶点创建法线<br><code>aiProcess_SplitLargeMeshes</code>将较大的网格分割为较小的网格(当渲染有最大顶点数量要求时)<br><code>aiProcess_OptimizeMeshes</code>将较小的网格们拼接为较大的一个网格(减少绘制调用)<br><a href="http://assimp.sourceforge.net/lib_html/postprocess_8h.html" target="_blank" rel="external">指令大全~~</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void processNode(aiNode *node, const aiScene *scene)&#123;</span><br><span class="line">    //提取节点数据~</span><br><span class="line">    for(unsigned int i = 0; i &lt; node-&gt;mNumMeshes; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        aiMesh *mesh = scene-&gt;mMeshes[node-&gt;mMeshes[i]];</span><br><span class="line">        meshes.push_back(processMesh(mesh, scene));</span><br><span class="line">    &#125;</span><br><span class="line">    //递归遍历</span><br><span class="line">    for(unsigned int i = 0; i &lt; node-&gt;mNumChildren; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        processNode(node-&gt;mChildren[i], scene);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提取节点网格数据"><a href="#提取节点网格数据" class="headerlink" title="提取节点网格数据"></a>提取节点网格数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Mesh processMesh(aiMesh *mesh, const aiScene *scene) &#123;</span><br><span class="line">    </span><br><span class="line">    //需要提取的数据~</span><br><span class="line">    std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">    std::vector&lt;unsigned int&gt; indices;</span><br><span class="line">    std::vector&lt;Texture&gt; textures;</span><br><span class="line"></span><br><span class="line">    //将顶点数据提取</span><br><span class="line">    for(unsigned int i = 0; i &lt; mesh-&gt;mNumVertices; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vertex vertex;</span><br><span class="line">        glm::vec3 vector; </span><br><span class="line">        // positions</span><br><span class="line">        vector.x = mesh-&gt;mVertices[i].x;</span><br><span class="line">        vector.y = mesh-&gt;mVertices[i].y;</span><br><span class="line">        vector.z = mesh-&gt;mVertices[i].z;</span><br><span class="line">        vertex.Position = vector;       </span><br><span class="line">        // normals</span><br><span class="line">        vector.x = mesh-&gt;mNormals[i].x;</span><br><span class="line">        vector.y = mesh-&gt;mNormals[i].y;</span><br><span class="line">        vector.z = mesh-&gt;mNormals[i].z;</span><br><span class="line">        vertex.Normal = vector;         </span><br><span class="line">   </span><br><span class="line">        if(mesh-&gt;mTextureCoords[0])             &#123;</span><br><span class="line">            glm::vec2 vec;</span><br><span class="line">   </span><br><span class="line">            vec.x = mesh-&gt;mTextureCoords[0][i].x;</span><br><span class="line">            vec.y = mesh-&gt;mTextureCoords[0][i].y;</span><br><span class="line">            vertex.TexCoords = vec;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            vertex.TexCoords = glm::vec2(0.0f, 0.0f);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        vertices.push_back(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //将索引数据提取</span><br><span class="line">    for(unsigned int i = 0; i &lt; mesh-&gt;mNumFaces; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        aiFace face = mesh-&gt;mFaces[i];</span><br><span class="line">       </span><br><span class="line">        for(unsigned int j = 0; j &lt; face.mNumIndices; j++)</span><br><span class="line">            indices.push_back(face.mIndices[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    //将纹理数据提取(漫反射纹理,镜面纹理...)</span><br><span class="line">    aiMaterial* material = scene-&gt;mMaterials[mesh-&gt;mMaterialIndex];</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Texture&gt; diffuseMaps = loadMaterialTextures(material, aiTextureType_DIFFUSE, &quot;texture_diffuse&quot;);</span><br><span class="line">    textures.insert(textures.end(), diffuseMaps.begin(), diffuseMaps.end());</span><br><span class="line">  </span><br><span class="line">    std::vector&lt;Texture&gt; specularMaps = loadMaterialTextures(material, aiTextureType_SPECULAR, &quot;texture_specular&quot;);</span><br><span class="line">    textures.insert(textures.end(), specularMaps.begin(), specularMaps.end());</span><br><span class="line">   </span><br><span class="line">    std::vector&lt;Texture&gt; normalMaps = loadMaterialTextures(material, aiTextureType_HEIGHT, &quot;texture_normal&quot;);</span><br><span class="line">    textures.insert(textures.end(), normalMaps.begin(), normalMaps.end());</span><br><span class="line">   </span><br><span class="line">    std::vector&lt;Texture&gt; heightMaps = loadMaterialTextures(material, aiTextureType_AMBIENT, &quot;texture_height&quot;);</span><br><span class="line">    textures.insert(textures.end(), heightMaps.begin(), heightMaps.end());</span><br><span class="line"></span><br><span class="line">    return Mesh(vertices, indices, textures);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">    std::vector&lt;Texture&gt; loadMaterialTextures(aiMaterial *mat, aiTextureType type,std::string typeName)  &#123;</span><br><span class="line">        std::vector&lt;Texture&gt; textures;</span><br><span class="line">        for(unsigned int i = 0; i &lt; mat-&gt;GetTextureCount(type); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            aiString str;</span><br><span class="line">            mat-&gt;GetTexture(type, i, &amp;str);</span><br><span class="line">            //检查纹理是否之前已经加载过,</span><br><span class="line">            bool skip = false;</span><br><span class="line">            for(unsigned int j = 0; j &lt; textures_loaded.size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(std::strcmp(textures_loaded[j].path.data(), str.C_Str()) == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    textures.push_back(textures_loaded[j]);</span><br><span class="line">                    skip = true; // a texture with the same filepath has already been loaded, continue to next one. (optimization)</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!skip)</span><br><span class="line">            &#123;   // if texture hasn&apos;t been loaded already, load it</span><br><span class="line">                //若纹理未加载,则加载</span><br><span class="line">                Texture texture;</span><br><span class="line">                texture.id = TextureFromFile(str.C_Str(), this-&gt;directory);</span><br><span class="line">                texture.type = typeName;</span><br><span class="line">                texture.path = str.C_Str();</span><br><span class="line">                textures.push_back(texture);</span><br><span class="line">                textures_loaded.push_back(texture);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return textures;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //将纹理加载,输入到着色器</span><br><span class="line">    unsigned int TextureFromFile(const char *path, const std::string &amp;directory, bool gamma)</span><br><span class="line">&#123;</span><br><span class="line">    std::string filename = std::string(path);</span><br><span class="line">    filename = directory + &apos;/&apos; + filename;</span><br><span class="line"></span><br><span class="line">    unsigned int textureID;</span><br><span class="line">    glGenTextures(1, &amp;textureID);</span><br><span class="line"></span><br><span class="line">    int width, height, nrComponents;</span><br><span class="line">    unsigned char *data = stbi_load(filename.c_str(), &amp;width, &amp;height, &amp;nrComponents, 0);</span><br><span class="line">    if (data)</span><br><span class="line">    &#123;</span><br><span class="line">        GLenum format;</span><br><span class="line">        if (nrComponents == 1)</span><br><span class="line">            format = GL_RED;</span><br><span class="line">        else if (nrComponents == 3)</span><br><span class="line">            format = GL_RGB;</span><br><span class="line">        else if (nrComponents == 4)&#123;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i&lt;width*height; i++ ) &#123;</span><br><span class="line">                char tR = data[i*4+2];</span><br><span class="line">                data[i*4+2] = data[i*4];</span><br><span class="line">                data[i*4] = tR;</span><br><span class="line">            &#125;</span><br><span class="line">            format = GL_RGBA;</span><br><span class="line">        &#125;</span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, textureID);</span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line"></span><br><span class="line">        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line">        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line">        stbi_image_free(data);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //std::cout &lt;&lt; &quot;Texture failed to load at path: &quot; &lt;&lt; path &lt;&lt; std::endl;</span><br><span class="line">        printf(&quot;Texture failed to load at path: %s&quot;,path);</span><br><span class="line">        stbi_image_free(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return textureID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>在加载模型数据时,需要注意的是 模型并不一定会提供完整的贴图,例如 有的简单模型,建模师有可能不会为其添加贴图,而是给模型设置一种高光材质,以节约资源.这时 材质信息存储在mtl文件中,而且还有可能连mtl文件也没有, 这时 则需要我们添加默认材质~</p><blockquote><p>.mtl文件（Material Library File）是材质库文件，描述的是物体的材质信息，ASCII存储，任何文本编辑器可以将其打开和编辑。一个.mtl文件可以包含一个或多个材质定义，对于每个材质都有其颜色，纹理和反射贴图的描述，应用于物体的表面和顶点。想详细了解的朋友们可以看这里<a href="http://blog.csdn.net/u013467442/article/details/46792495" target="_blank" rel="external">.obj文件格式与.mtl文件格式</a></p></blockquote><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>绘制就很简单了,将提取出来的每个网格的数据 传入着色器就好~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void Draw(GLuint program)&#123;</span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    unsigned int diffuseNr = 1;</span><br><span class="line">    unsigned int specularNr = 1;</span><br><span class="line">    for(unsigned int i = 0; i &lt; textures.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        glActiveTexture(GL_TEXTURE0 + i); </span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        std::string number;</span><br><span class="line">        std::string name = textures[i].type;</span><br><span class="line">        if(name == &quot;texture_diffuse&quot;)</span><br><span class="line">            ss &lt;&lt; diffuseNr++; </span><br><span class="line">        else if(name == &quot;texture_specular&quot;)</span><br><span class="line">            ss &lt;&lt; specularNr++;</span><br><span class="line">        number = ss.str();</span><br><span class="line"></span><br><span class="line">        glUniform1i(glGetUniformLocation(program, (&quot;material.&quot; + name + number).c_str()), i);</span><br><span class="line"></span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, textures[i].id);</span><br><span class="line">    &#125;</span><br><span class="line">    glActiveTexture(GL_TEXTURE0);</span><br><span class="line">    glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在着色器中,也就是将获取的顶点数据 和 纹理 按照需要进行输出就好了~ 和 绘制木箱子无异~</p><p><img src="/images/OpenGL ES on iOS --- Assimp/Simulator%20Screen%20Shot%20-%20iPhone%20X%20-%202017-12-25%20at%2013.20.14.png" alt="结果-w300"></p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>我对这一块的内容也并不是十分熟练,所以Assimp使用这里有些粗略,以后有啥新的收获也会补上~ 倒是Assimp库编译那里 我是踩了好多坑~ </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OpenGL-ES-on-iOS-—-Assimp&quot;&gt;&lt;a href=&quot;#OpenGL-ES-on-iOS-—-Assimp&quot; class=&quot;headerlink&quot; title=&quot;OpenGL ES on iOS — Assimp&quot;&gt;&lt;/a&gt;OpenGL ES o
      
    
    </summary>
    
    
      <category term="Opengl ES" scheme="http://yoursite.com/tags/Opengl-ES/"/>
    
  </entry>
  
  <entry>
    <title>RXSwift源码浅析(二)</title>
    <link href="http://yoursite.com/2017/12/19/RXSwift%20%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2017/12/19/RXSwift 源码浅析(二)/</id>
    <published>2017-12-19T08:46:12.000Z</published>
    <updated>2018-09-12T07:23:15.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RXSwift-源码浅析-二"><a href="#RXSwift-源码浅析-二" class="headerlink" title="RXSwift 源码浅析(二)"></a>RXSwift 源码浅析(二)</h1><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文是对上一篇文章的补充,加上对KVO实现的简要分析 和 自己的一些思考,可能会有不够准确的地方还望多多指正,共同学习~~</p><h1 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h1><p>在上篇文章中是从具体实现的角度分析<strong>Observable</strong>的使用实现,接下来从一个高一点的角度来分析RXSwift.</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>无论是Observable,还是KVO,通知,按钮点击….,在本质上我认为可将这一切看为这样一个过程~</p><p><img src="/images/RXSwift源码浅析二/screenshot1.png" alt="screenshot"><br>以通知为例子, 在程序中某个地方发出了事件(例如键盘弹出),这就是<strong>事件源</strong>. 然后这个<strong>事件传递</strong>(系统发出键盘弹出的通知). 最后程序的某处<strong>响应</strong>了这个事件(比如我们监听到这个通知,然后将控件上移). 我认为RXSwift就是为了让大家更方便的实现这样的过程~</p><p>而RXSwift的结构就大概是这样的</p><h2 id="结构简图"><a href="#结构简图" class="headerlink" title="结构简图"></a>结构简图</h2><p>1,事件源<br><img src="/images/RXSwift源码浅析二/screenshot2.png" alt="screenshot"><br>例如<code>create</code>函数~</p><p>2,响应<br><img src="/images/RXSwift源码浅析二/screenshot3.png" alt="screenshot"><br>为了简洁,我并没有加入资源释放那部分, 具体的可以参照<a href="https://juejin.im/post/5a355ab15188252bca04f0fd" target="_blank" rel="external">上篇</a>进行对比的来看, 中介在事件源中接受事件,在响应中输出事件.</p><p>接下啦我再以KVO的实现细节 再来展示一下这个结构~~</p><h1 id="KVO实现细节"><a href="#KVO实现细节" class="headerlink" title="KVO实现细节"></a>KVO实现细节</h1><p>下面是一段日常使用RXSwift的代码~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Test: NSObject &#123;</span><br><span class="line">    @objc var name:String!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">    @objc var obj:Test!</span><br><span class="line">    var disposeBag = DisposeBag()</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        obj = Test()</span><br><span class="line">        obj.rx.observe(String.self, #keyPath(Test.name)).subscribe &#123; (eve) in</span><br><span class="line">            print(eve)</span><br><span class="line">        &#125;.disposed(by: self.disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件源"><a href="#事件源" class="headerlink" title="事件源"></a>事件源</h2><h3 id="rx"><a href="#rx" class="headerlink" title="rx"></a>rx</h3><p>首先第一步是调用对象的rx属性, rx来源于 对NSObject的扩展协议~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import class Foundation.NSObject</span><br><span class="line">extension NSObject: ReactiveCompatible &#123; &#125;</span><br></pre></td></tr></table></figure><p>协议实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public protocol ReactiveCompatible &#123;</span><br><span class="line">    </span><br><span class="line">    associatedtype CompatibleType   </span><br><span class="line"></span><br><span class="line">    // 类属性 和 对象属性~</span><br><span class="line">    static var rx: Reactive&lt;CompatibleType&gt;.Type &#123; get set &#125;    </span><br><span class="line">    var rx: Reactive&lt;CompatibleType&gt; &#123; get set &#125;               </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension ReactiveCompatible &#123;</span><br><span class="line">    public static var rx: Reactive&lt;Self&gt;.Type &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return Reactive&lt;Self&gt;.self</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public var rx: Reactive&lt;Self&gt; &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return Reactive(self)</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实是为了将当前对象封装为一个<strong>Reactive<base></strong>结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public struct Reactive&lt;Base&gt; &#123;          </span><br><span class="line">    public let base: Base</span><br><span class="line"></span><br><span class="line">    public init(_ base: Base) &#123;</span><br><span class="line">        self.base = base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h3><p>一般我们调用的是这个扩展方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension Reactive where Base: NSObject &#123;</span><br><span class="line"></span><br><span class="line">    public func observe&lt;E&gt;(_ type: E.Type, _ keyPath: String, options: KeyValueObservingOptions = [.new, .initial], retainSelf: Bool = true) -&gt; Observable&lt;E?&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        return KVOObservable(object: base, keyPath: keyPath, options: options, retainTarget: retainSelf).asObservable()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>observe</code>方法首先创建一个<code>KVOObservable</code>对象~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//YSD--产生KVO的可观察者</span><br><span class="line">fileprivate final class KVOObservable&lt;Element&gt;: ObservableType</span><br><span class="line">, KVOObservableProtocol &#123;</span><br><span class="line"></span><br><span class="line">    typealias E = Element?</span><br><span class="line"></span><br><span class="line">    unowned var target: AnyObject</span><br><span class="line">    var strongTarget: AnyObject?</span><br><span class="line"></span><br><span class="line">    var keyPath: String</span><br><span class="line">    var options: KeyValueObservingOptions</span><br><span class="line">    var retainTarget: Bool</span><br><span class="line"></span><br><span class="line">    //初始化方法</span><br><span class="line">    init(object: AnyObject, keyPath: String, options: KeyValueObservingOptions, retainTarget: Bool) &#123;</span><br><span class="line">        self.target = object</span><br><span class="line">        self.keyPath = keyPath</span><br><span class="line">        self.options = options</span><br><span class="line">        self.retainTarget = retainTarget</span><br><span class="line">        if retainTarget &#123;</span><br><span class="line">            self.strongTarget = object</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //订阅方法~~~</span><br><span class="line">    func subscribe&lt;O : ObserverType&gt;(_ observer: O) -&gt; Disposable where O.E == Element? &#123;</span><br><span class="line">        let observer = KVOObserver(parent: self) &#123; (value) in</span><br><span class="line">            if value as? NSNull != nil &#123;</span><br><span class="line">                observer.on(.next(nil))</span><br><span class="line">                return</span><br><span class="line">            &#125;                   </span><br><span class="line">            observer.on(.next(value as? Element))</span><br><span class="line">        &#125;</span><br><span class="line">        return Disposables.create(with: observer.dispose)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">..............</span><br><span class="line"></span><br><span class="line">fileprivate protocol KVOObservableProtocol &#123;</span><br><span class="line">    var target: AnyObject &#123; get &#125;</span><br><span class="line">    var keyPath: String &#123; get &#125;</span><br><span class="line">    var retainTarget: Bool &#123; get &#125;</span><br><span class="line">    var options: KeyValueObservingOptions &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>KVOObservable</code>对象遵守<code>ObservableType</code>协议,所以可以调用<code>asObsevable()</code>方法, <code>KVOObservableProtocol</code>协议限定它持有这些KVO 必须的属性~,因为在本质上,还是调用OC的KVO实现~</p><p>动态语言还是爽呀~</p><h2 id="订阅方法"><a href="#订阅方法" class="headerlink" title="订阅方法"></a>订阅方法</h2><p>订阅时也就是上面重载的方法~ 首先还是创建一个观察者,来持有 事件响应的闭包~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let observer = KVOObserver(parent: self) &#123; (value) in</span><br><span class="line">    if value as? NSNull != nil &#123;</span><br><span class="line">        observer.on(.next(nil))</span><br><span class="line">        return</span><br><span class="line">    &#125;           </span><br><span class="line">    observer.on(.next(value as? Element))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而事件是从哪里发出的呢~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">fileprivate final class KVOObserver</span><br><span class="line">    : _RXKVOObserver</span><br><span class="line">    , Disposable &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    typealias Callback = (Any?) -&gt; Void</span><br><span class="line"></span><br><span class="line">    var retainSelf: KVOObserver? = nil</span><br><span class="line"></span><br><span class="line">    init(parent: KVOObservableProtocol, callback: @escaping Callback) &#123;</span><br><span class="line">        #if TRACE_RESOURCES</span><br><span class="line">            _ = Resources.incrementTotal()</span><br><span class="line">        #endif</span><br><span class="line"></span><br><span class="line">        super.init(target: parent.target, retainTarget: parent.retainTarget, keyPath: parent.keyPath, options: parent.options.nsOptions, callback: callback)</span><br><span class="line"></span><br><span class="line">        //因为 可观察者并不强引用它,所以通过循环引用 保持自己不被回收</span><br><span class="line">        self.retainSelf = self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//只用调用dispose后才会回收,所以大家注意 不要因为偷懒不好好使用disposeBag(๑•ᴗ•๑)</span><br><span class="line">    override func dispose() &#123;</span><br><span class="line">        super.dispose()     </span><br><span class="line">        self.retainSelf = nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deinit &#123;</span><br><span class="line">        #if TRACE_RESOURCES</span><br><span class="line">            _ = Resources.decrementTotal()</span><br><span class="line">        #endif</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对应它的父类就是OC实现的~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@interface _RXKVOObserver ()</span><br><span class="line">                    //和weak差不多, 但是weak释放了为变为nil 它不会 会因为野指针的使用而崩溃</span><br><span class="line">@property (nonatomic, unsafe_unretained) id            target;</span><br><span class="line">@property (nonatomic, strong           ) id            retainedTarget;</span><br><span class="line">@property (nonatomic, copy             ) NSString     *keyPath;</span><br><span class="line">@property (nonatomic, copy             ) void (^callback)(id);</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation _RXKVOObserver</span><br><span class="line"></span><br><span class="line">-(instancetype)initWithTarget:(id)target</span><br><span class="line">                 retainTarget:(BOOL)retainTarget</span><br><span class="line">                      keyPath:(NSString*)keyPath</span><br><span class="line">                      options:(NSKeyValueObservingOptions)options</span><br><span class="line">                     callback:(void (^)(id))callback &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) return nil;</span><br><span class="line">    </span><br><span class="line">    self.target = target;</span><br><span class="line">    if (retainTarget) &#123;</span><br><span class="line">        self.retainedTarget = target;</span><br><span class="line">    &#125;</span><br><span class="line">    self.keyPath = keyPath;</span><br><span class="line">    self.callback = callback;</span><br><span class="line">    </span><br><span class="line">    [self.target addObserver:self forKeyPath:self.keyPath options:options context:nil];</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//常规的操作,将监听到的新值作为block参数返回</span><br><span class="line">-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        self.callback(change[NSKeyValueChangeNewKey]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)dispose &#123;</span><br><span class="line">    [self.target removeObserver:self forKeyPath:self.keyPath context:nil];</span><br><span class="line">    self.target = nil;</span><br><span class="line">    self.retainedTarget = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将KVO的newValue作为参数传入 callBack闭包中~ </p><p>所以RXSwift对于 KVO的实现就比较简单了,观察者既是事件源 也是 中介 总的来说是将 普通的KVO写法 进行封装,纳入自己的体系之下</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思~"></a>反思~</h1><p>学而不思则罔,思而不学则殆. 所以看完大神的源码一定要反思~ 不然除了框架用的更熟练 跟没看一样~</p><h2 id="面向协议"><a href="#面向协议" class="headerlink" title="面向协议"></a>面向协议</h2><p>我认为RXSwift就是一个我们学习<strong>面向协议编程</strong>(Protocol-oriented programming)的好例子~, 通过<strong>协议</strong> 我们可以很好的解决<strong>继承</strong>带来的种种弊端~</p><blockquote><p>1, 可以实现在OC和Swift不允许的 多继承~<br>2, 避免基类受制于子类, 实现依赖倒转, 让子类受制于协议~</p></blockquote><p>在RXSwift中有一些重要的协议<strong>ObservableType</strong>,<strong>ObserverType</strong>,<strong>Disposable</strong></p><p>ObservableType<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public protocol ObservableType : ObservableConvertibleType &#123;</span><br><span class="line"></span><br><span class="line">    func subscribe&lt;O: ObserverType&gt;(_ observer: O) -&gt; Disposable where O.E == E</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ObserverType<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public protocol ObserverType &#123;</span><br><span class="line">    associatedtype E</span><br><span class="line"></span><br><span class="line">    func on(_ event: Event&lt;E&gt;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension ObserverType &#123;</span><br><span class="line"></span><br><span class="line">    public func onNext(_ element: E) &#123;</span><br><span class="line">        on(.next(element))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public func onCompleted() &#123;</span><br><span class="line">        on(.completed)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public func onError(_ error: Swift.Error) &#123;</span><br><span class="line">        on(.error(error))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Disposable<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public protocol Disposable &#123;</span><br><span class="line">    public func dispose()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过这些协议 将各个角色类的行为加以限制, 而各个协议之间是互相对接的,这样即使各个类不相同,只要大家遵守相同的协议,就可以在这个体系下畅通无阻~ . 打个简单的例子就是 弹幕功能 </p><p>从服务器发来的需要展示的消息是各种各样的(普通弹幕,礼物弹幕,贵族弹幕,管理信息弹幕~~~~),当其实在显示的时候,只需要显示文字和图片而已~ 这样让 消息都遵守可以获取文字图片的<strong>协议</strong>,这样不管发过来什么消息 都可以正常显示~<br>当然使用<strong>继承</strong>也可以实现,但是若我们要加新的消息类型(礼物火箭),这时继承要改<strong>基类</strong>,乱改基类很有可能会影响到其他子类导致Bug,而协议只需要扩展,或者限定类型的扩展~</p><p>当然这不是说让大家不要用<strong>继承</strong>,在RXSwift中也是有继承的~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final class AnonymousObserver&lt;ElementType&gt; : ObserverBase&lt;ElementType&gt; &#123;......&#125;</span><br></pre></td></tr></table></figure><p>所以我个人是这样认为的,POP这是纲领,不是方案~ 使用的时候要灵活,小范围,少变动的用<strong>继承</strong>,大范围,多变化的用<strong>协议</strong></p><h2 id="单一责任原则"><a href="#单一责任原则" class="headerlink" title="单一责任原则"></a>单一责任原则</h2><p>在搭架子的时候就将 角色责任 区分好~ 就像最上面的图示一样,,避免类兼数值. 这样无论是对Bug的定位,还是对项目架构的贯彻 都是有好处的~(๑•ᴗ•๑)</p><h2 id="最少知道原则"><a href="#最少知道原则" class="headerlink" title="最少知道原则"></a>最少知道原则</h2><p>也就是耦合度的问题,我觉得大家都知道写代码要 高内聚,低耦合. 但是怎么做呢~ 在RXSwift中是这样做的,也就是POP 各个角色间通过协议沟通(我到目前为止展示出来的方法,基本上都是协议上的方法),而类通过遵守协议对协议内容进行实现. 这样 耦合的就只有协议,而类只专注对协议的实现</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>暂时就反思了这么多~然后有内容再补充吧,下篇就写 <strong>flatMap</strong>的分析~ 如果老大的需求没下来 应该很快吧~. 文中要有不准确的地方,请多多指正呀(๑•ᴗ•๑)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RXSwift-源码浅析-二&quot;&gt;&lt;a href=&quot;#RXSwift-源码浅析-二&quot; class=&quot;headerlink&quot; title=&quot;RXSwift 源码浅析(二)&quot;&gt;&lt;/a&gt;RXSwift 源码浅析(二)&lt;/h1&gt;&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简
      
    
    </summary>
    
    
      <category term="第三方框架学习" scheme="http://yoursite.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>RXSwift源码浅析(一)</title>
    <link href="http://yoursite.com/2017/12/17/RXSwift%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90(%E4%B8%80)/"/>
    <id>http://yoursite.com/2017/12/17/RXSwift源码浅析(一)/</id>
    <published>2017-12-16T17:37:19.000Z</published>
    <updated>2017-12-16T17:39:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RXSwift源码浅析-一"><a href="#RXSwift源码浅析-一" class="headerlink" title="RXSwift源码浅析(一)"></a>RXSwift源码浅析(一)</h1><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>最近老大给了个新项目,我打算用Swift写.原来OC用的RAC,换到Swift自然框架也想试试新的,就用了RXSwift,对于这两个框架,我都是会用,但不解其中的原理,正好最近需求没下来,就研究了研究RXSwif,把自己的收获分享一下,文中要有不准确的地方还望大家多多指正~</p><p>关于RXSwift是什么和怎么用我就不废话了,网上资源很多,本文先从<strong>Observable</strong>实现原理入手,旨在以小见大,后面的<code>Single</code>什么的自然举一反三~</p><h1 id="使用Demo"><a href="#使用Demo" class="headerlink" title="使用Demo"></a>使用Demo</h1><p>下面是一段简单使用<strong>Observable</strong>的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let numbers: Observable&lt;Int&gt; = Observable.create &#123; observer -&gt; Disposable in</span><br><span class="line">    observer.onNext(0)</span><br><span class="line">    observer.onNext(1)</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">    </span><br><span class="line">    return Disposables.create &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">numbers.subscribe&#123;</span><br><span class="line">    print($0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo实现的效果其实就是 将上一段闭包中输入的 产生的事件(0,1,Completed),在下一段闭包中提取出来.<br>这样就将 事件的产生 和 事件的处理 分开. 本文也就是分析这个效果怎么实现的</p><h1 id="主要类"><a href="#主要类" class="headerlink" title="主要类"></a>主要类</h1><h2 id="AnonymousObservable"><a href="#AnonymousObservable" class="headerlink" title="AnonymousObservable"></a>AnonymousObservable</h2><p>匿名<strong>可</strong>观察者,存储产生事件的闭包 和激活处理事件闭包的入口</p><h2 id="AnyObserver"><a href="#AnyObserver" class="headerlink" title="AnyObserver"></a>AnyObserver</h2><p>任意观察者,用于存储事件 和 输出事件</p><h2 id="AnonyObserver"><a href="#AnonyObserver" class="headerlink" title="AnonyObserver"></a>AnonyObserver</h2><p>匿名观察者,用于存储 处理事件的闭包</p><h2 id="AnonymousObservableSink"><a href="#AnonymousObservableSink" class="headerlink" title="AnonymousObservableSink"></a>AnonymousObservableSink</h2><p>将可观察者 和 观察者 链接,实现事件的传递</p><h2 id="ObserverType"><a href="#ObserverType" class="headerlink" title="ObserverType"></a>ObserverType</h2><p>协议,将上面所有内容都包裹起来,将它们加以限制,便于有效的沟通~</p><h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><p>事件本身,是枚举,有 Error,Complete,Element(元素)</p><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>首先要说的是 ObserverType 定义的一些内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">associatedtype E</span><br><span class="line"></span><br><span class="line">func subscribe&lt;O: ObserverType&gt;(_ observer: O) -&gt; Disposable where O.E == E</span><br></pre></td></tr></table></figure><p>E:为本次事件流中定义一个确定的<strong>类型</strong>,保证 产生的和处理的元素类型相同,否则无法传递</p><h3 id="create方法"><a href="#create方法" class="headerlink" title="create方法"></a>create方法</h3><p><code>Observable&lt;Int&gt;.create { observer -&gt; Disposable in ....}</code><br>对于<code>Observable</code>,它是一个抽象类,我们在实际使用中并不能使用它,在协议中有默认的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension ObservableType &#123;</span><br><span class="line">    public static func create(_ subscribe: @escaping (AnyObserver&lt;E&gt;) -&gt; Disposable) -&gt; Observable&lt;E&gt; &#123;</span><br><span class="line">        return AnonymousObservable(subscribe)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以此处创建的是 <code>AnonymousObservable</code> 对象,我先称其为<strong>A1</strong>,<strong>A1</strong>将事件产生的闭包持有, 闭包中产生的事件 输入到<code>AnyObserver</code>结构体中.闭包我们成为<strong>A2</strong> 这样 存储部分就好了~~</p><h1 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h1><p>激活 我们通过调用<strong>A1</strong>的订阅方法<code>subscribe</code>(也是协议中限定的方法),接下来看方法中的实现~<br>因为<code>Observable</code>是抽象类,所以这里也是协议默认的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public func subscribe(_ on: @escaping (Event&lt;E&gt;) -&gt; Void)</span><br><span class="line">    -&gt; Disposable &#123;</span><br><span class="line">        let observer = AnonymousObserver &#123; e in</span><br><span class="line">            on(e)       </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return self.asObservable().subscribe(observer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里就分两步了,一是观察者的实现,而是事件的传递</p><h2 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h2><p>在这里很简单,也就是创建<code>AnonymousObserver</code>匿名观察者对象<strong>B1</strong>,<strong>B1</strong>将事件处理闭包持有,闭包我们成为<strong>B2</strong></p><h2 id="传递"><a href="#传递" class="headerlink" title="传递"></a>传递</h2><p>首先是<code>asObservable()</code>方法,因为 B1间接继承自<code>Observable</code>,所以也就是<code>return self</code>,应该是在处理其他类型的可观察物用到,在后续 如果碰到我会补充~</p><p>然后就是对<strong>A1</strong>的 另一个订阅方法(重载),将<strong>B1</strong>作为参数传入<br>细枝末节先不说,先把握主干~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">override func subscribe&lt;O : ObserverType&gt;(_ observer: O) -&gt; Disposable where O.E == Element &#123;</span><br><span class="line">    </span><br><span class="line">    if !CurrentThreadScheduler.isScheduleRequired &#123;</span><br><span class="line">        //第一步</span><br><span class="line">        let disposer = SinkDisposer()</span><br><span class="line">        //第二步</span><br><span class="line">        let sinkAndSubscription = run(observer, cancel: disposer)</span><br><span class="line">        //第三步</span><br><span class="line">        disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)</span><br><span class="line">        return disposer</span><br><span class="line">    &#125;</span><br><span class="line">    //else先不说~</span><br><span class="line">    else &#123;</span><br><span class="line">        return CurrentThreadScheduler.instance.schedule(()) &#123; _ in</span><br><span class="line">            let disposer = SinkDisposer()</span><br><span class="line">            let sinkAndSubscription = self.run(observer, cancel: disposer)</span><br><span class="line">            disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)</span><br><span class="line"></span><br><span class="line">            return disposer</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p><code>SinkDisposer</code>对象是关于 传递结束后,处理资源回收的对象,叫它<strong>C1</strong>,用来处理 <strong>A1</strong>create闭包返回的disposer闭包的~</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>调用了<code>run</code>方法,将<strong>B1</strong>对象传入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override func run&lt;O : ObserverType&gt;(_ observer: O, cancel: Cancelable) -&gt; (sink: Disposable, subscription: Disposable) where O.E == Element &#123;</span><br><span class="line">    //2.1  </span><br><span class="line">    let sink = AnonymousObservableSink(observer: observer, cancel: cancel)</span><br><span class="line">    //2.2</span><br><span class="line">    let subscription = sink.run(self)</span><br><span class="line">    //2.3</span><br><span class="line">    return (sink: sink, subscription: subscription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1步"><a href="#2-1步" class="headerlink" title="2.1步"></a>2.1步</h4><p>创建<strong>AnonymousObservableSink</strong>对象,我称它<strong>D1</strong>,它也是将<strong>B1</strong>对象和<strong>C1</strong>对象持有</p><h4 id="2-2步"><a href="#2-2步" class="headerlink" title="2.2步"></a>2.2步</h4><p>调用<strong>D1</strong>对象的<code>run</code>方法,将<strong>A1</strong>自身传入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func run(_ parent: Parent) -&gt; Disposable &#123;</span><br><span class="line">       return parent._subscribeHandler(AnyObserver(self))</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在该方法中,就是将<strong>A1</strong>对象的<strong>A2</strong>闭包 调用,将<strong>D1</strong>对象化为<code>AnyObserver</code>结构体作为<strong>A2</strong>参数传入~</p><p>然后我们看  <strong>D1</strong>对象 若何转换的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//结构体方法</span><br><span class="line">public init&lt;O : ObserverType&gt;(_ observer: O) where O.E == Element &#123;</span><br><span class="line">    self.observer = observer.on</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里结构体 将 <strong>D1</strong>持有的<strong>B1</strong>对象的on方法 作为属性持有~,将结构体成为<strong>E1</strong></p><p>再来看<strong>E1</strong>的<code>onNext....</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">extension ObserverType &#123;</span><br><span class="line">    //YSD</span><br><span class="line">    /// Convenience method equivalent to `on(.next(element: E))`</span><br><span class="line">    ///</span><br><span class="line">    /// - parameter element: Next element to send to observer(s)</span><br><span class="line">    public func onNext(_ element: E) &#123;</span><br><span class="line">        on(.next(element))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// Convenience method equivalent to `on(.completed)`</span><br><span class="line">    public func onCompleted() &#123;</span><br><span class="line">        on(.completed)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// Convenience method equivalent to `on(.error(Swift.Error))`</span><br><span class="line">    /// - parameter error: Swift.Error to send to observer(s)</span><br><span class="line">    public func onError(_ error: Swift.Error) &#123;</span><br><span class="line">        on(.error(error))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的其实是调用 <strong>B1</strong>的<code>on</code>方法~~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func on(_ event: Event&lt;E&gt;) &#123;</span><br><span class="line">    switch event &#123;                      </span><br><span class="line">    case .next:</span><br><span class="line">        if _isStopped == 0 &#123;            </span><br><span class="line">            onCore(event)</span><br><span class="line">        &#125;</span><br><span class="line">    case .error, .completed:</span><br><span class="line"></span><br><span class="line">        if AtomicCompareAndSwap(0, 1, &amp;_isStopped) &#123;</span><br><span class="line">            onCore(event)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的<strong>B1</strong>的<code>onCore</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override func onCore(_ event: Event&lt;Element&gt;) &#123;</span><br><span class="line">    return _eventHandler(event)         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是将 <strong>E1</strong>从<strong>A2</strong>接收的事件 传入<strong>B2</strong>中,最终实现内容的传递~~ 然后再将<strong>A1</strong>中释放资源的闭包返回~</p><h4 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h4><p>将<strong>D1</strong>和disposable闭包 作为元组返回~</p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p><strong>C1</strong>接收元组参数,调用<code>setSinkAndSubscription</code>方法~,然后将<strong>SinkDisposer</strong>对象返回,让用户选择是否释放~</p><h1 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h1><p>文字太抽象,画个图吧~ 画的有点丑(๑•ᴗ•๑)~</p><p><img src="/images/RXSwift源码浅析一/screenshot.png" alt="screenshot"></p><p>可以看到 A1 在这个过程中只持有了A2, 不会导致内存泄露~ 当然如果你dispose 使用不当 肯定有泄漏的~ 亲测(๑•ᴗ•๑)~</p><h1 id="细枝末节"><a href="#细枝末节" class="headerlink" title="细枝末节"></a>细枝末节</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>订阅2中的<code>if !CurrentThreadScheduler.isScheduleRequired</code></p><p>内容是这样的~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static fileprivate(set) var isScheduleRequired: Bool &#123;</span><br><span class="line">    get &#123;     </span><br><span class="line">        //获取该指示值</span><br><span class="line">        return pthread_getspecific(CurrentThreadScheduler.isScheduleRequiredKey) == nil</span><br><span class="line">    &#125;</span><br><span class="line">    set(isScheduleRequired) &#123;</span><br><span class="line">        </span><br><span class="line">        //设置</span><br><span class="line">        //http://www.jianshu.com/p/d52c1ebf808a</span><br><span class="line">        // 成功返回0            true设置no no设置为 true</span><br><span class="line">        if pthread_setspecific(CurrentThreadScheduler.isScheduleRequiredKey, isScheduleRequired ? nil : scheduleInProgressSentinel) != 0 &#123;</span><br><span class="line">            rxFatalError(&quot;pthread_setspecific failed&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static var isScheduleRequiredKey: pthread_key_t = &#123; () -&gt; pthread_key_t in</span><br><span class="line">    //YSD</span><br><span class="line">    //https://onevcat.com/2015/01/swift-pointer/</span><br><span class="line">    //可变指针 pthread_key_t类型 分配空间</span><br><span class="line">    let key = UnsafeMutablePointer&lt;pthread_key_t&gt;.allocate(capacity: 1)</span><br><span class="line">    defer &#123;</span><br><span class="line">        key.deallocate(capacity: 1)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //创建线程安全的变量</span><br><span class="line">    guard pthread_key_create(key, nil) == 0 else &#123;</span><br><span class="line">        rxFatalError(&quot;isScheduleRequired key creation failed&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return key.pointee</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>这里应该是为了保护,RXSwift在多线程操作下的数据安全~ 在本次事件流中只使用了get方法,并没使用set~,所以具体效果我不清楚~,以后碰到了 我在补充上吧~</p><h2 id="SinkDisposer"><a href="#SinkDisposer" class="headerlink" title="SinkDisposer"></a>SinkDisposer</h2><p>就是释放资源部分~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">   fileprivate enum DisposeState: UInt32 &#123;     </span><br><span class="line">       case disposed = 1</span><br><span class="line">       case sinkAndSubscriptionSet = 2</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Jeej, swift API consistency rules    </span><br><span class="line">   fileprivate enum DisposeStateInt32: Int32 &#123;</span><br><span class="line">       case disposed = 1</span><br><span class="line">       case sinkAndSubscriptionSet = 2</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   private var _state: AtomicInt = 0</span><br><span class="line">   private var _sink: Disposable? = nil</span><br><span class="line">   private var _subscription: Disposable? = nil</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">func setSinkAndSubscription(sink: Disposable, subscription: Disposable) &#123;</span><br><span class="line">       _sink = sink</span><br><span class="line">       _subscription = subscription</span><br><span class="line"></span><br><span class="line">       let previousState = AtomicOr(DisposeState.sinkAndSubscriptionSet.rawValue, &amp;_state)</span><br><span class="line">       if (previousState &amp; DisposeStateInt32.sinkAndSubscriptionSet.rawValue) != 0 &#123;</span><br><span class="line">           rxFatalError(&quot;Sink and subscription were already set&quot;)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (previousState &amp; DisposeStateInt32.disposed.rawValue) != 0 &#123;</span><br><span class="line">           sink.dispose()</span><br><span class="line">           subscription.dispose()</span><br><span class="line">           _sink = nil</span><br><span class="line">           _subscription = nil</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   func dispose() &#123;</span><br><span class="line">       let previousState = AtomicOr(DisposeState.disposed.rawValue, &amp;_state)</span><br><span class="line"></span><br><span class="line">       if (previousState &amp; DisposeStateInt32.disposed.rawValue) != 0 &#123;</span><br><span class="line">           return</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (previousState &amp; DisposeStateInt32.sinkAndSubscriptionSet.rawValue) != 0 &#123;</span><br><span class="line">           guard let sink = _sink else &#123;</span><br><span class="line">               rxFatalError(&quot;Sink not set&quot;)</span><br><span class="line">           &#125;</span><br><span class="line">           guard let subscription = _subscription else &#123;</span><br><span class="line">               rxFatalError(&quot;Subscription not set&quot;)</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           sink.dispose()</span><br><span class="line">           subscription.dispose()</span><br><span class="line"></span><br><span class="line">           _sink = nil</span><br><span class="line">           _subscription = nil</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>从输出崩溃提示哪里就可以得知~ 这里是为了防止dispose的多次调用~ 因为在整个事件流中,dipose闭包 可能是 产生Complete,Error或者用户手动调用的~ </p><p><code>AtomicOr</code>方法其实调用的是<code>OSAtomicOr32OrigBarrier(A,&amp;B)</code> 该函数会将两个变量 线程安全的 按位或运算返回结果, 并为后者赋值=前者~ B=A</p><blockquote><p>未调用dipose时 逻辑与运算  state = 2 previousState = 0 两个条件都不成立~ 所以此时是用户要手动dispose</p><p>之前调用过 也就是发生complete 或 Error(在上面的代码中也有保证,两者只发生一起~),则 state = 1当调用setSinkAndSubscription方法时 逻辑与运算 state = 2 previousState = 1 则第一个条件不成立 第二个成立~ 释放资源</p><p>当多次Complete时,则只会dipose一次~</p><p>当在外界多次调用时 则state = 2 previousState = 1 则第一个条件成立 崩溃~</p></blockquote><p>当然这里实现这种效果的方案有很多种~ RSSwift的方案比较有逼格吧~</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看完这些源码,我的感觉是RXSwift对 设计模式 贯彻的很彻底~ 在时间富裕的情况下自己写的项目要向他靠拢,增强项目的延展性,这样项目经理让加啥也不会太头疼了~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RXSwift源码浅析-一&quot;&gt;&lt;a href=&quot;#RXSwift源码浅析-一&quot; class=&quot;headerlink&quot; title=&quot;RXSwift源码浅析(一)&quot;&gt;&lt;/a&gt;RXSwift源码浅析(一)&lt;/h1&gt;&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; c
      
    
    </summary>
    
    
      <category term="第三方框架学习" scheme="http://yoursite.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES on iOS --- 光照进阶</title>
    <link href="http://yoursite.com/2017/12/06/OpenGL%20ES%20on%20iOS%20---%20%E5%85%89%E7%85%A7%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2017/12/06/OpenGL ES on iOS --- 光照进阶/</id>
    <published>2017-12-06T03:05:29.000Z</published>
    <updated>2017-12-13T12:58:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文记录我记录我学习 坐标体系和矩阵转换的过程,加深学习便于后续查询,可能有些描述不够准确,或者内容不够充实,还请多多指正,共同学习.</p><h1 id="光源分类"><a href="#光源分类" class="headerlink" title="光源分类"></a>光源分类</h1><p>在基础光照时,学习了光照对物体的作用,也就相当于物体的材质,这次主要说 现实生活中的光源</p><h2 id="平行光"><a href="#平行光" class="headerlink" title="平行光"></a>平行光</h2><p>当光源无限远时,从其发射过来的的光可以近似的看做平行光(例如太阳);这时 光线的方向都是一致的.<br><img src="/images/OpenGL ES on iOS --- 光照进阶/15125210847433.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">float ambientStrength = 0.3;    //环境因子</span><br><span class="line">   float specularStrength = 2.0;</span><br><span class="line">   float reflectance = 256.0;</span><br><span class="line"></span><br><span class="line">   //平行光方向</span><br><span class="line">   vec3 paraLightDir = normalize(vec3(-0.2,-1.0,-0.3));</span><br><span class="line"></span><br><span class="line">   //环境光</span><br><span class="line">   vec3 ambient = ambientStrength * texture(Texture,outTexCoord).rgb;</span><br><span class="line"></span><br><span class="line">   //漫反射</span><br><span class="line">   vec3 norm = normalize(outNormal);</span><br><span class="line">   vec3 lightDir = normalize(lightPo - FragPo);    //当前顶点 至 光源的的单位向量</span><br><span class="line">   float diff = max(dot(norm,paraLightDir),0.0);</span><br><span class="line">   vec3 diffuse = diff * lightColor*texture(Texture,outTexCoord).rgb;</span><br><span class="line"></span><br><span class="line">   //镜面反射</span><br><span class="line">   vec3 viewDir = normalize(viewPo - FragPo);</span><br><span class="line">   vec3 reflectDir = reflect(-paraLightDir,outNormal);</span><br><span class="line">   float spec = pow(max(dot(viewDir, reflectDir),0.0),reflectance);</span><br><span class="line">   vec3 specular = specularStrength * spec * texture(specularTexture,outTexCoord).rgb;</span><br><span class="line"></span><br><span class="line">   //光线衰弱</span><br><span class="line">   float constantPara = 1.0f;</span><br><span class="line">   float linearPara = 0.09f;</span><br><span class="line">   float quadraticPara = 0.032f;</span><br><span class="line">   float LFDistance = length(lightPo - FragPo);</span><br><span class="line">   float lightWeakPara = 1.0/(constantPara + linearPara * LFDistance + quadraticPara * (LFDistance*LFDistance));</span><br><span class="line"></span><br><span class="line">   vec3 res = ambient + diffuse + specular;</span><br><span class="line"></span><br><span class="line">   FragColor = vec4(res,1.0);</span><br></pre></td></tr></table></figure><h2 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h2><p>点光源就是比较正常的光源,光从光源四散发出,光线的向量就等于光源到物体的向量.<br><img src="/images/OpenGL ES on iOS --- 光照进阶/15125219854634.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">float ambientStrength = 0.3;    //环境因子</span><br><span class="line">float specularStrength = 2.0;</span><br><span class="line">float reflectance = 256.0;</span><br><span class="line"></span><br><span class="line">float constantPara = 1.0f;    //常亮</span><br><span class="line">float linearPara = 0.09f;     //线性部分因数</span><br><span class="line">float quadraticPara = 0.032f; //二次项部分因数</span><br><span class="line"></span><br><span class="line">//环境光</span><br><span class="line">vec3 ambient = ambientStrength * texture(Texture,outTexCoord).rgb;</span><br><span class="line"></span><br><span class="line">//漫反射</span><br><span class="line">vec3 norm = normalize(outNormal);</span><br><span class="line">vec3 lightDir = normalize(lightPo - FragPo);    //当前顶点 至 光源的的单位向量</span><br><span class="line"></span><br><span class="line">//点光源</span><br><span class="line">float diff = max(dot(norm,lightDir),0.0);   //光源与法线夹角</span><br><span class="line">vec3 diffuse = diff * lightColor*texture(Texture,outTexCoord).rgb;</span><br><span class="line"></span><br><span class="line">//镜面反射</span><br><span class="line">vec3 viewDir = normalize(viewPo - FragPo);</span><br><span class="line">vec3 reflectDir = reflect(-lightDir,outNormal);</span><br><span class="line"></span><br><span class="line">float spec = pow(max(dot(viewDir, reflectDir),0.0),reflectance);</span><br><span class="line">vec3 specular = specularStrength * spec * texture(specularTexture,outTexCoord).rgb;</span><br><span class="line"></span><br><span class="line">float LFDistance = length(lightPo - FragPo);</span><br><span class="line">float lightWeakPara = 1.0/(constantPara + linearPara * LFDistance + quadraticPara * (LFDistance*LFDistance));</span><br><span class="line"></span><br><span class="line">vec3 res = (ambient + diffuse + specular)*lightWeakPara;</span><br><span class="line"></span><br><span class="line">FragColor = vec4(res,1.0);</span><br></pre></td></tr></table></figure><h2 id="聚光源"><a href="#聚光源" class="headerlink" title="聚光源"></a>聚光源</h2><p>聚光源的效果就相当于 手电筒,好比朝向指定范围的点光源~<br><img src="/images/OpenGL ES on iOS --- 光照进阶/15125220581520.jpg" alt=""><br>在使用聚光源时,就需要指定 聚光朝向SpotDir,和切光角ϕ. 当光源指向点的向量和SpotDir的夹角大于ϕ时,则无法被光源照射到.</p><p>但是这样的明暗边界十分明显,效果不够真实</p><p><img src="/images/OpenGL ES on iOS --- 光照进阶/screenshot1.png" alt="初始版本"></p><p>这时,我们就需要将过渡边缘平滑,这时 我们就需要引入两个参数, 内锥角和外锥角. 外锥角就是切光角,而内锥角以内不需要平滑效果, 内锥角和外锥角之间需要平滑过度.<br>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/(一些复杂的计算操作 应该让CPU做,提高效率,不变的量也建议外部传输,避免重复计算)</span><br><span class="line">float inCutOff = cos(radians(10.0f));   //内锥角cos值</span><br><span class="line">float outCutOff = cos(radians(15.0f));  //外锥角cos值</span><br><span class="line">vec3 spotDir = vec3(-1.2f,-1.0f,-2.0f); //聚光朝向</span><br><span class="line"></span><br><span class="line">float theta = dot(lightDir,normalize(-spotDir));    //光源指向物体的向量 和 聚光朝向的 cos值</span><br><span class="line">float epsilon  = inCutOff - outCutOff;  //内外锥角cos差值</span><br><span class="line"></span><br><span class="line">//clamp(a,b,c);若b&lt;a&lt;c 则函数返回值为a 若不是,则返回值最小为b 最大为c</span><br><span class="line">// (theta - outCutOff)/epsilon 若theta的角度小于内锥角 则其值&gt;=1 若theta的角度大于外锥角 则其值&lt;=0 这样光线就在内外锥角之间平滑变化.</span><br><span class="line">float intensity = clamp((theta - outCutOff)/epsilon,0.0,1.0);</span><br></pre></td></tr></table></figure><p>结果:<br><img src="/images/OpenGL ES on iOS --- 光照进阶/screenshot.png" alt="结果"></p><h1 id="光线衰弱"><a href="#光线衰弱" class="headerlink" title="光线衰弱"></a>光线衰弱</h1><p>在现实情况中,光源发出的光线是会随着距离的增长而衰减的, 而且也不是线性衰减的,表现为在距离光源近的这段距离衰减的较快, 在距离光源较远的情况下衰减较慢.<br>通常使用这个公式来模拟光线衰减.</p><p><img src="/images/OpenGL ES on iOS --- 光照进阶/screenshot2.png" alt="衰减公式"></p><blockquote><p>常数项通常保持为1.0，它的主要作用是保证分母永远不会比1小，否则的话在某些距离上它反而会增加强度，这肯定不是我们想要的效果<br>一次项会与距离值相乘，以线性的方式减少强度<br>二次项会与距离的平方相乘，让光源以二次递减的方式减少强度。二次项在距离比较小的时候影响会比一次项小很多，但当距离值比较大的时候它就会比一次项更大了</p></blockquote><p><img src="/images/OpenGL ES on iOS --- 光照进阶/15125247574821.jpg" alt="效果展示"><br>在效果图中,在达到距离100时就近似没有光的效果了.</p><p><img src="/images/OpenGL ES on iOS --- 光照进阶/screenshot3.png" alt="参数距离表"><br>距离与参数的关联.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float LFDistance = length(lightPo - FragPo);</span><br><span class="line">float lightWeakPara = 1.0/(constantPara + linearPara * LFDistance + quadraticPara * (LFDistance*LFDistance));</span><br><span class="line"></span><br><span class="line">vec3 res = (ambient + diffuse + specular)*lightWeakPara;</span><br></pre></td></tr></table></figure><h1 id="光照贴图"><a href="#光照贴图" class="headerlink" title="光照贴图"></a>光照贴图</h1><p>在一张纹理图中,由于材质不同,所呈现的效果也会有所不同,如同下面这个箱子,金属边框和木头在相同光源下所呈现的1效果肯定有所不同.<br><img src="/images/OpenGL ES on iOS --- 光照进阶/15125252548879.jpg" alt="-w250"></p><p>这时为了在显示光照效果时将其区分开来,则需要引入光照贴图的概念~ 如下图<br><img src="/images/OpenGL ES on iOS --- 光照进阶/15125254567342.jpg" alt="-w250"><br>在该贴图中,对应木头部分为黑色vec3(0.0); 而在金属边框部分 则对应的为灰色, 这样在计算 漫反射或者镜面时,将其作为参考系数,则可以让其呈现不同的效果.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vec3 spe = texture(specularTexture,outTexCoord).rgb;   //获取镜面光照贴图</span><br><span class="line"> </span><br><span class="line">vec3 viewDir = normalize(viewPo - FragPo);</span><br><span class="line">vec3 reflectDir = reflect(-lightDir,outNormal);</span><br><span class="line"></span><br><span class="line">float spec = pow(max(dot(viewDir, reflectDir),0.0),spL.reflectance);</span><br><span class="line">vec3 specular = point_specularStrength * spec * spe;    //使用光照贴图纹理</span><br></pre></td></tr></table></figure><p><img src="/images/OpenGL ES on iOS --- 光照进阶/screenshot4.png" alt="镜面光照纹理效果"><br>是可以看出箱子铁框的镜面效果 比 木头的效果要强</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;本文记录我记录我学习 坐标体系和矩阵转换的过程,加深学习便于后续查询,可能有些描述不够准确,或者内容不够充实,还请多多指正,共同学习.&lt;/p
      
    
    </summary>
    
    
      <category term="Opengl ES" scheme="http://yoursite.com/tags/Opengl-ES/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES on iOS --- 基础光照</title>
    <link href="http://yoursite.com/2017/12/05/OpenGL%20ES%20on%20iOS%20---%20%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/"/>
    <id>http://yoursite.com/2017/12/05/OpenGL ES on iOS --- 基础光照/</id>
    <published>2017-12-05T01:18:17.000Z</published>
    <updated>2017-12-13T12:58:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文记录我记录我学习 坐标体系和矩阵转换的过程,加深学习便于后续查询,可能有些描述不够准确,或者内容不够充实,还请多多指正,共同学习.</p><h1 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h1><p>一个没有Alpha通道的颜色可以用一个3维向量来表示 例如 glm::vec3(1.0,1.0,1.0); 表示白色.</p><p>在现实世界中,一个物体的颜色是它反射的颜色导致的, 例如我们将纯红光 照射在纯绿物体上, 因为红光都被吸收,所以显示为黑色.</p><p>将吸收反射的过程用向量表示出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 lightColor(0.0f, 1.0f, 0.0f); //绿色光源向量</span><br><span class="line">glm::vec3 objColor(1.0f, 0.5f, 0.31f);  //物体色</span><br><span class="line">glm::vec3 result = lightColor * objColor; // 光源下颜色(0.0f, 0.5f, 0.0f);</span><br></pre></td></tr></table></figure><h1 id="冯氏光照模型"><a href="#冯氏光照模型" class="headerlink" title="冯氏光照模型"></a>冯氏光照模型</h1><p>冯氏光照模型的主要结构由3个分量组成 环境(Ambient) 漫反射(Diffuse) 镜面(Specular)<br><img src="/images/OpenGL ES on iOS --- 基础光照/15123749275555.jpg" alt=""></p><h2 id="环境光照"><a href="#环境光照" class="headerlink" title="环境光照"></a>环境光照</h2><p>在现实环境下 即使在黑暗的情况下,世界上通常也会有一些光亮(如 月光), 而且即使物体不朝光源的,也会因为 其他物体的反射,使阴面有光,这种情况下 就要使用 <strong>全局照明算法</strong> 这种算法开销大而且复杂,以后在研究 先实现简单的 环境光照</p><p>所以给物体一个环境光照量,让物体始终有一点颜色. 在着色器中表现如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    float ambientStrength = 0.1;        //至少有%10的光找到物体所有面</span><br><span class="line">    vec3 ambient = ambientStrength * lightColor;</span><br><span class="line"></span><br><span class="line">    vec3 result = ambient * objectColor;</span><br><span class="line">    FragColor = vec4(result, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漫反射光照"><a href="#漫反射光照" class="headerlink" title="漫反射光照"></a>漫反射光照</h2><p>模拟光源对物体的方向性影响(Directional Impact)。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮. 也就是<strong>光线</strong>和<strong>物体表面法线</strong>的夹角越小,光线对物体的影响就越大.<br><img src="/images/OpenGL ES on iOS --- 基础光照/15123768104392.jpg" alt=""></p><p>这样就可以利用夹角的cos值作为参考,来修改光线对物体的影响.</p><p>片段着色器重相关实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uniform vec3 lightColor;        //光源色</span><br><span class="line">uniform vec3 lightPo;           //光源位置</span><br><span class="line">uniform vec3 objectColor;       //物体色</span><br><span class="line">uniform vec3 viewPo;            //物体位置</span><br><span class="line"></span><br><span class="line">in vec3 outNormal;              //传入当前顶点平面的法向量</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vec3 norm = normalize(outNormal);   //确保法线为单位向量</span><br><span class="line">vec3 lightDir = normalize(lightPo - FragPo);  //顶点指向光源 单位向量  </span><br><span class="line"></span><br><span class="line">float diff = max(dot(norm,lightDir),0.0);   //得到两向量的cos值 小于0则则为0</span><br><span class="line">vec3 diffuse = diff * lightColor;           //得到漫反射收的光源向量</span><br></pre></td></tr></table></figure><h3 id="法向量变换"><a href="#法向量变换" class="headerlink" title="法向量变换"></a>法向量变换</h3><p>对于法向量,它是一个方向向量,不会因为物体的移动而发生变化,所以在对法向量 进行矩阵处理时,要消除矩阵中位移部分对其造成的影响. 因此位移使用3x3矩阵 或者 将 法向量的w分量设置为0.0; </p><p>另外,若矩阵对物体进行里不等比缩放时候,会导致法向量不在垂直于物体表面.<br><img src="/images/OpenGL ES on iOS --- 基础光照/15123784323220.jpg" alt=""></p><p>这种情况 则需要使用<strong>法线矩阵</strong> 来移除对法向量错误缩放的影响. 法线矩阵由<strong>逆矩阵</strong>和<strong>转置矩阵</strong> 组成.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::transpose(glm::inverse(model));    //法线矩阵的计算</span><br><span class="line"></span><br><span class="line">mat3(transpose(inverse(model))) * aNormal;  //着色器语言的使用 使用3x3矩阵 能够与 vec3法向量计算</span><br></pre></td></tr></table></figure><h2 id="镜面光照"><a href="#镜面光照" class="headerlink" title="镜面光照"></a>镜面光照</h2><p> 模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。镜面光照的计算依赖于 观察的视角, 若视线与光源在物体的反射线的夹角越小 则镜面光照效果越好.</p><p> 计算他 我们需要 观察者位置.镜面强度(镜面效果强弱)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float specularStrength = 0.5;   //镜面强度</span><br><span class="line">vec3 viewDir = normalize(viewPo - FragPo);  //顶点指向观察点的单位向量</span><br><span class="line">vec3 reflectDir = reflect(-lightDir,outNormal); //求得光线 在 顶点的反射线(传入光源指向顶点的向量)</span><br><span class="line"></span><br><span class="line">float spec = pow(max(dot(viewDir, reflectDir),0.0),256.0);</span><br><span class="line">// 求得夹角cos值 取256次幂 注意 pow(float,float)函数参数类型</span><br><span class="line"></span><br><span class="line">vec3 specular = specularStrength * spec * lightColor;</span><br></pre></td></tr></table></figure><p>256 表示高光的反光度, 反光度越高,发射光的能力越强,散射越少 高光点越小<br><img src="/images/OpenGL ES on iOS --- 基础光照/15124362663769.jpg" alt=""></p><p>最后综合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec3 res =(ambientStrength + diffuse + specular) * objectColor;</span><br></pre></td></tr></table></figure><p>效果图: 白色方块为白色光源<br><img src="/images/OpenGL ES on iOS --- 基础光照/%E6%95%88%E6%9E%9C%E5%9B%BE.gif" alt="效果图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;本文记录我记录我学习 坐标体系和矩阵转换的过程,加深学习便于后续查询,可能有些描述不够准确,或者内容不够充实,还请多多指正,共同学习.&lt;/p
      
    
    </summary>
    
    
      <category term="Opengl ES" scheme="http://yoursite.com/tags/Opengl-ES/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES on iOS --- 坐标系统与矩阵转换</title>
    <link href="http://yoursite.com/2017/12/01/OpenGL%20ES%20on%20iOS%20---%20%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2017/12/01/OpenGL ES on iOS --- 坐标系统与矩阵转换/</id>
    <published>2017-12-01T09:29:23.000Z</published>
    <updated>2017-12-13T12:58:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文记录我记录我学习 坐标体系和矩阵转换的过程,加深学习便于后续查询,可能有些描述不够准确,或者内容不够充实,还请多多指正,共同学习</p><h1 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h1><p>我们将物体坐标进行一系列变换,达到自己期望的位置,需要使用到矩阵.先说一下矩阵的公式.这里我是本着了解的心态去学习的,因为已经有趁手的数学工具了,把重要的学完~ 我会再来研究这里的.</p><h2 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h2><p>这是一个简单的矩阵相乘例子,<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/screenshot2.png" alt="例子"><br>这是矩阵乘法过程~<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/screenshot3.png" alt="矩阵乘法过程"></p><p>注意:</p><blockquote><p>1, 矩阵相乘不遵守交换律 即 A <em> B ≠ B </em> A<br>2, 只有当左侧矩阵列数 等于 右侧矩阵行数 两矩阵才能相乘.</p></blockquote><p>在我们对坐标进行缩放,位移,旋转 等变换时,我们多用4x4矩阵来进行~</p><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>我们把缩放变量表示为(S1,S2,S3)我们可以为任意向量(x,y,z)定义一个缩放矩阵：<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/screenshot1.png" alt="缩放矩阵"></p><h2 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h2><p>如果我们把位移向量表示为(Tx,Ty,Tz)，我们就能把位移矩阵定义为：<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/screenshot4.png" alt="位移矩阵"></p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>绕X轴旋转<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/screenshot5.png" alt="x轴旋转"><br>绕y轴旋转<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/screenshot6.png" alt="y轴旋转"><br>绕z轴旋转<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/screenshot7.png" alt="z轴旋转"></p><p>将旋转分为绕3个轴进行旋转,以达到自己希望的位置,见下面这个公式，(Rx,Ry,Rz)代表任意旋转轴：<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/screenshot8.png" alt="任意旋转"></p><p>这种处理方式,简单容易理解,但是 会出现一个问题<strong>万向节死锁</strong>.</p><p>举个栗子~ 加入在三维空间中有一个平行于X中的向量,然后将它绕Y轴旋转至它平行于Z轴,这时绕z轴的任何旋转都不会改变 向量的方向了. 在正常情况下,关于3个轴的旋转过程应该是可以任意组合的,最终旋转结果都是一致的,但是当出现了万向节死锁后, 就会导致各个轴旋转顺序 组合不同,而最终旋转结果不同~ 大家可以找根笔试一试~也可以看看这里:<a href="http://blog.csdn.net/andrewfan/article/details/60981437" target="_blank" rel="external">欧拉角与万向节死锁（图文版</a></p><p>那么如何解决呢~ 使用四元数 <a href="http://insaneguy.me/2015/03/25/rotation_matrix_and_quaternions/" target="_blank" rel="external">旋转矩阵与四元数</a> 因为复变函数早已还给老师~ 后续再研究补充~~</p><h2 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h2><p>在上面关于描述3D坐标的向量 是四维向量,多出一个分量w,w分量的用处是来创造3D视觉效果的,根据w分量的大小对物体进行拉伸,最后将w=1的截面进行展示,从而产生物体远近效果. 这篇文章我觉得介绍的比较详细 <a href="http://www.jianshu.com/p/7e701d7bfd79" target="_blank" rel="external">写给大家看的“透视除法” —— 齐次坐标和投影</a></p><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>我将不同变换的矩阵组合起来~ 将一个放大2倍的矩阵 和位移(1,2,3)的矩阵组合起来~,得到新的变换矩阵<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/screenshot9.png" alt="矩阵组合"></p><p>将得到的变换矩阵 进行验证<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/screenshot9.png" alt="矩阵验证"></p><p>因为矩阵相乘是不遵守<em>交换律</em>的,所以在矩阵组合时,顺序就十分重要, 建议 先缩放 –&gt; 再旋转 –&gt; 再位移. 并且矩阵的顺序是从右到左的  所以应该是<br>位移矩阵 <em> 旋转矩阵 </em> 缩放矩阵 = 所需矩阵</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>为什么我们要用矩阵来进行着一系列的变换呢? 据我了解 是因为这样做,将 旋转,位移,缩放加以统一.简化计算流程,提高计算机的计算效率.</p><p>最后总结:像这样利用矩阵进行位移,缩放,旋转 这一系列的变换叫做:<strong>仿射变换</strong></p><h1 id="坐标体系"><a href="#坐标体系" class="headerlink" title="坐标体系"></a>坐标体系</h1><p>OpenGL 顶点着色器 希望接受的的顶点 都是<strong>标准化设备坐标</strong>(Normalized Device Coordinate, NDC)的坐标,也就是(x,y,z)都是在 -1~1之间变换.在此之外的顶点丢弃,并且按照传入的顶点进行绘制.</p><p>将3D的物体坐标转换到理想的绘制效果需要进行一些列的转换过程.<br>局部空间(Local Space)/物体空间(Object Space) —&gt; 世界空间(World Space) —&gt; 观察空间(View Space)/视觉空间(Eye Space) —&gt;裁剪空间(Clip Space) —&gt; 屏幕空间(Screen Space)</p><p>OpenGL是不提供数学工具的~ 我们可以使用 <strong>GLM(OpenGL Mathematics)</strong> <a href="http://glm.g-truc.net/0.9.9/index.html" target="_blank" rel="external">GLM官网</a> 我用的是0.9.9版本~</p><p>示意图:<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/15120025806643.jpg" alt="坐标空间变换"></p><h2 id="局部空间"><a href="#局部空间" class="headerlink" title="局部空间"></a>局部空间</h2><p>局部空间: 就表示物体在自己本身坐标系里的坐标,比较像view的bounds属性.可以理解为建模时模型的坐标. </p><h2 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h2><p>世界空间: 表示物体需要展示世界里的坐标,比较像view的frame属性,好比我们的模型是个房子,将它放到小镇(世界)中, 这时它的坐标就是在世界空间的坐标.</p><p>将局部空间坐标转换为世界空间坐标需要进行一系列转换,就像在象棋棋盘上放棋子,我们需要将棋子旋转,位移…操作才能将棋子放到正确的位置上.</p><h2 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h2><p>在最终展示时,我们展示的是用户观察的界面, 我们需要将世界空间的坐标 转换为 以用户坐标观察视野产生的结果.</p><h2 id="裁剪空间"><a href="#裁剪空间" class="headerlink" title="裁剪空间"></a>裁剪空间</h2><p>在OpenGL 中所期望的坐标是 标准化设备坐标, 所以我们 需要将自己的坐标集进行转换,将需要显示的坐标 落在 -1.0~1.0之间. </p><p>如果只是图元(Primitive)，例如三角形，的一部分超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围,就像三角形的角被切了一刀变成四边形那样~</p><h3 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h3><p>在裁剪时,我们是将3D空间的物体 转换为 2D空间的平面图像, 这样的过程叫做投影, 像投影截取的显示的3D空间 <strong>平截头体</strong>,它就像一个容器,在这里面的所有坐标都不会被裁剪掉~</p><h4 id="正射投影"><a href="#正射投影" class="headerlink" title="正射投影"></a>正射投影</h4><p>在裁剪空间阶段,获得平截头体的方式, 就是通过 正射投影. 使用正射投影矩阵创天平截头体 需要指定 近平面宽高, 远平面宽高.<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/15120115864167.jpg" alt=""><br>通过正射投影矩阵,将3D空间的坐标 映射到2D平面中,但是这样产生的问题是 并没有远近缩放的效果,这时就需要 透视投影.</p><h4 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h4><p>透视投影,就是利用齐次坐标w 来生成远近效果的, 离观察者越远的顶点 w分量越大.在显示时,顶点坐标的每个分量都会除以w分量,进而使 远端的物体小,近端的物体大.</p><p>透视矩阵 会根据平截头体的顶点的远近,对顶点w分量进行修改</p><h2 id="组合-1"><a href="#组合-1" class="headerlink" title="组合"></a>组合</h2><p>若上面每一个步骤都产生一个变换矩阵的话,那么最终的顶点坐标应该是这个样子的<br>目标顶点 = 投影矩阵 <em> 观察矩阵 </em> 模型矩阵 *原始顶点</p><h2 id="标准化设备坐标"><a href="#标准化设备坐标" class="headerlink" title="标准化设备坐标"></a>标准化设备坐标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//此方法创建的窗口就是对应的OpenGL 的标准化设备窗口</span><br><span class="line">glViewport(0, 0, self.frame.size.width, self.frame.size.height);</span><br></pre></td></tr></table></figure><h2 id="模型矩阵"><a href="#模型矩阵" class="headerlink" title="模型矩阵"></a>模型矩阵</h2><p>模型矩阵 包含了 位移,缩放,旋转操作, 它将应用到物体的所有定点上. 该矩阵的目的就是将原来位于 世界空间(0,0,0)点的物体 移动到它应该出现的位置.</p><h2 id="观察矩阵"><a href="#观察矩阵" class="headerlink" title="观察矩阵"></a>观察矩阵</h2><p>观察矩阵就像是 3D世界里的摄像机,最终显示的画面 就是摄影机的位置 和 方向 观察的画面~ 观察矩阵的创建就需要 GLM 提供的LooK AT 函数:</p><p>tmat4x4<t, p=""> lookAt(tvec3<t, p=""> const &amp; eye, tvec3<t, p=""> const &amp; center, tvec3<t, p=""> const &amp; up)</t,></t,></t,></t,></p><p>该函数需要输入 3个 vec3变量,返回观察矩阵:</p><blockquote><p>参数1: 相机在世界坐标系的位置<br>参数2: 相机镜头指向的位置<br>参数3: 世界的上向量,上向量的方向 在显示时 是指向屏幕上方的向量  </p></blockquote><p>通过对这三个变量控制,就可以实现我们希望的效果,我在练习时 实现的是类似 游戏CS里 摄像头移动的方式</p><h2 id="投影矩阵"><a href="#投影矩阵" class="headerlink" title="投影矩阵"></a>投影矩阵</h2><p>glm::mat4 proj = glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f);</p><p>此函数其实是创建了一个 定义了 可视控件的 平头截体,此空间以外的东西都将被抛弃~<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/15120295944189.jpg" alt=""><br>参数:</p><blockquote><p>第一个参数定义了<strong>fov值</strong>,它表示了视野(Field of View),就相当于摄影机的摄影角度~~<br>第二个参数 为宽高比, 由视口的宽/高所得<br>第三和第四个参数 设置了平截头体的近和远平面。我们通常设置近距离为0.1f，而远距离设为100.0f。所有在近平面和远平面内且处于平截头体内的顶点都会被渲染.</p></blockquote><p>最后经过透视矩阵的处理,就产生了 物体 远小近大的效果了~</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>这里就捡与本文相关的说~ </p><h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#version 300 es</span><br><span class="line"></span><br><span class="line">layout(location = 0) in vec3 position;</span><br><span class="line">layout(location = 1) in vec3 color;</span><br><span class="line">layout(location = 2) in vec2 texCoord;  //纹理坐标</span><br><span class="line"></span><br><span class="line">//uniform mat4 transform;</span><br><span class="line"></span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line">out vec3 outColor;</span><br><span class="line">out vec2 outTexCoord;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gl_Position = projection*view*model*vec4(position,1.0);</span><br><span class="line">    outColor = color;</span><br><span class="line">    outTexCoord = texCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开启深度测试"><a href="#开启深度测试" class="headerlink" title="开启深度测试"></a>开启深度测试</h2><p>OpenGL存储它的所有深度信息于一个<strong>Z缓冲(Z-buffer)</strong>中，也被称为深度缓冲(Depth Buffer)。GLFW会自动为你生成这样一个缓冲（就像它也有一个颜色缓冲来存储输出图像的颜色）。深度值存储在每个片段里面（作为片段的z值），当片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为<strong>深度测试(Depth Testing)</strong>，它是由OpenGL自动完成的。</p><p>深度测试还有其他关于 自定以的函数,以后再说~~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int wi,he;</span><br><span class="line">//检索有关绑定缓冲区的对象的信息 ,这里获得了layer的宽高</span><br><span class="line">glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &amp;wi);</span><br><span class="line">glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &amp;he);</span><br><span class="line"></span><br><span class="line">glGenRenderbuffers(1, &amp;depthBuf);</span><br><span class="line">glBindRenderbuffer(GL_RENDERBUFFER, depthBuf);</span><br><span class="line">glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, wi, he);</span><br><span class="line"></span><br><span class="line">//还要记得开启深度测试</span><br><span class="line">  glEnable(GL_DEPTH_TEST);</span><br></pre></td></tr></table></figure><h2 id="模型矩阵-1"><a href="#模型矩阵-1" class="headerlink" title="模型矩阵"></a>模型矩阵</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cubePositions[] = &#123;</span><br><span class="line">      glm::vec3( 0.0f,  0.0f,  0.0f),</span><br><span class="line">      glm::vec3( 2.0f,  5.0f, -15.0f),</span><br><span class="line">      glm::vec3(-1.5f, -2.2f, -2.5f),</span><br><span class="line">      glm::vec3(-3.8f, -2.0f, -12.3f),</span><br><span class="line">      glm::vec3( 2.4f, -0.4f, -3.5f),</span><br><span class="line">      glm::vec3(-1.7f,  3.0f, -7.5f),</span><br><span class="line">      glm::vec3( 1.3f, -2.0f, -2.5f),</span><br><span class="line">      glm::vec3( 1.5f,  2.0f, -2.5f),</span><br><span class="line">      glm::vec3( 1.5f,  0.2f, -1.5f),</span><br><span class="line">      glm::vec3(-1.3f,  1.0f, -1.5f)</span><br><span class="line">  &#125;;</span><br><span class="line">  for(unsigned int i = 0; i &lt; 10; i++)</span><br><span class="line">  &#123;</span><br><span class="line">      //模型矩阵</span><br><span class="line">      glm::mat4 model;</span><br><span class="line">      model = glm::translate(model, cubePositions[i]);</span><br><span class="line">      float angle = 20.0f * i;</span><br><span class="line">      model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f));</span><br><span class="line">      glUniformMatrix4fv(glGetUniformLocation(program, &quot;model&quot;), 1, GL_FALSE, glm::value_ptr(model));</span><br><span class="line"></span><br><span class="line">      glDrawArrays(GL_TRIANGLES, 0, 36);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的模型矩阵 将物体 进行位移,旋转后 放在世界坐标系中合适的位置.</p><h2 id="观察矩阵-1"><a href="#观察矩阵-1" class="headerlink" title="观察矩阵"></a>观察矩阵</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">定义了 相机的初始位置 与 初始方向(这里讲方向保持为单位向量)</span><br><span class="line">glm::vec3 cameraLo = glm::vec3(10.0f,0.0f,0.0f);</span><br><span class="line">glm::vec3 cameraDir = glm::vec3(1.0f,0.0f,0.0f);</span><br><span class="line"></span><br><span class="line">.........其他代码.........</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::lookAt(cameraLo,cameraLo-cameraDir, glm::vec3(0.0, 1.0, 0.0));</span><br><span class="line"></span><br><span class="line">//将镜头观察点 保持为 镜头方向位置  向上方向 设置为y轴.</span><br><span class="line"></span><br><span class="line">glUniformMatrix4fv(glGetUniformLocation(program, &quot;view&quot;), 1, GL_FALSE, glm::value_ptr(view));</span><br></pre></td></tr></table></figure><p>在Display计时器中持续调用该方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-(void)move&#123;</span><br><span class="line">    if (_isAdvance) &#123;</span><br><span class="line">        // 使摄像机 向朝向方向移动~~</span><br><span class="line">        cameraLo -=(cameraDir*(speed/24));</span><br><span class="line">    &#125;</span><br><span class="line">    if (_isback) &#123;</span><br><span class="line">        cameraLo +=(cameraDir*(speed/24));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //改变摄像机朝向</span><br><span class="line">    if (_isLeft) &#123;</span><br><span class="line">        cameraDir = glm::normalize(glm::vec3(cameraDir[0],cameraDir[1],cameraDir[2]-rotateSpeed));</span><br><span class="line">    &#125;</span><br><span class="line">    if (_isRight) &#123;</span><br><span class="line">        cameraDir = glm::normalize(glm::vec3(cameraDir[0],cameraDir[1],cameraDir[2]+rotateSpeed));</span><br><span class="line">    &#125;</span><br><span class="line">    if (_isUp) &#123;</span><br><span class="line">        cameraDir = glm::normalize(glm::vec3(cameraDir[0],cameraDir[1]-rotateSpeed,cameraDir[2]));</span><br><span class="line">    &#125;</span><br><span class="line">    if (_isDown) &#123;</span><br><span class="line">        cameraDir = glm::normalize(glm::vec3(cameraDir[0],cameraDir[1]+rotateSpeed,cameraDir[2]));</span><br><span class="line">    &#125;</span><br><span class="line">    [self render];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/dearmiku/Opengl-" target="_blank" rel="external">demo地址</a></p><p>最终实现效果:<br><img src="/images/OpenGL ES on iOS --- 坐标系统与矩阵转换/Socket1.gif" alt="Socket1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;本文记录我记录我学习 坐标体系和矩阵转换的过程,加深学习便于后续查询,可能有些描述不够准确,或者内容不够充实,还请多多指正,共同学习&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Opengl ES" scheme="http://yoursite.com/tags/Opengl-ES/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES on iOS --- 2D纹理</title>
    <link href="http://yoursite.com/2017/11/29/OpenGL%20ES%20on%20iOS%20---%202D%E7%BA%B9%E7%90%86/"/>
    <id>http://yoursite.com/2017/11/29/OpenGL ES on iOS --- 2D纹理/</id>
    <published>2017-11-29T03:00:43.000Z</published>
    <updated>2017-12-13T12:58:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>纹理是用来丰富我们绘制物体细节的,它可以是一张2D图片(除了图像外,纹理也被用来存储大量数据,传递到着色器上),就像贴图一样贴在绘制的物体上.</p><h1 id="纹理属性"><a href="#纹理属性" class="headerlink" title="纹理属性"></a>纹理属性</h1><h2 id="纹理坐标"><a href="#纹理坐标" class="headerlink" title="纹理坐标"></a>纹理坐标</h2><p>为了将纹理映射到绘制的物体上,我们需要指定 某个顶点对应着 纹理的那个位置. 通过纹理坐标,标明顶点从纹理图像那一部分采样,之后在图形的其它片段进行片段插值.</p><p>纹理坐标系和顶点坐标系有所不同,顶点坐标系 (0,0)点位于窗口中心. 纹理坐标系 (0,0)点位于 纹理左下角.</p><p>顶点坐标系<br><img src="/images/OpenGL ES on iOS --- 2D纹理/15119166430264.jpg" alt="顶点坐标系"></p><p>纹理坐标系<br><img src="/images/OpenGL ES on iOS --- 2D纹理/15119169959085.jpg" alt="纹理坐标系"></p><h2 id="纹理环绕方式"><a href="#纹理环绕方式" class="headerlink" title="纹理环绕方式"></a>纹理环绕方式</h2><p>当我们将顶点位置设置到纹理坐标之外时,则需要设置纹理环绕方式 来显示纹理图案</p><table><thead><tr><th>环绕属性</th><th>效果</th></tr></thead><tbody><tr><td>GL_REPEAT</td><td>重复纹理图案(默认)</td></tr><tr><td>GL_MIRRORED_REPEAT</td><td>镜像重复纹理图案</td></tr><tr><td>GL_CLAMP_TO_EDGE</td><td>将纹理锁定在0~1之间,超出部分重复纹理边缘图案,产生拉伸效果</td></tr><tr><td>GL_CLAMP_TO_BORDER</td><td>超出部分为用户指定边缘颜色</td></tr></tbody></table><p><img src="/images/OpenGL ES on iOS --- 2D纹理/15119175487458.jpg" alt="环绕示意图"></p><h3 id="纹理环绕函数"><a href="#纹理环绕函数" class="headerlink" title="纹理环绕函数"></a>纹理环绕函数</h3><p>glTexParameteri (GLenum target, GLenum pname, GLint param);<br>参数: </p><blockquote><p>target: 指定纹理目标,若为2D纹理 则为 GL_TEXTURE_2D<br>pname: 对应的纹理坐标轴(这里 s,t,r 对应 x,y,z) GL_TEXTURE_WRAP_S ,GL_TEXTURE_WRAP_T<br>param: 环绕方式,填入上面的方式.</p></blockquote><p>对2D纹理时,必须对 s,t坐标轴都进行设置. 若是设置 GL_CLAMP_TO_BORDER 形式,则还需要额外设置 环绕颜色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float borderColor[] = &#123; 1.0f, 1.0f, 0.0f, 1.0f &#125;;</span><br><span class="line">glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br></pre></td></tr></table></figure><h2 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h2><p>纹理坐标是不依赖于 纹理大小和分辨率的, 1就表示纹理的边缘.但是物体和和纹理大小可能不一致,这就造成了对纹理的放大和拉伸.这时如何将纹理像素映射到纹理坐标上,就需要我们设置. 该属性就是 纹理过滤.</p><p>纹理过滤有很多种,下面是最重要的两种</p><h3 id="邻近过滤"><a href="#邻近过滤" class="headerlink" title="邻近过滤"></a>邻近过滤</h3><p>GL_NEAREST 是默认的纹理过滤方式,它会选择距离 纹理坐标最近的像素点作为样本颜色.当纹理被放大时,会有颗粒感<br><img src="/images/OpenGL ES on iOS --- 2D纹理/15119191609889.jpg" alt="临近过滤"></p><h3 id="线性过滤"><a href="#线性过滤" class="headerlink" title="线性过滤"></a>线性过滤</h3><p>GL_LINEAR, 会基于当前纹理坐标附近的像素点计算一个插值,也就是附近纹理的混合色,离得越近的像素点,颜色贡献越大,当纹理被放大时,会比临近过滤更平滑.<br><img src="/images/OpenGL ES on iOS --- 2D纹理/15119194640734.jpg" alt="线性过滤"><img src="/images/OpenGL ES on iOS --- 2D纹理/15119195201570.jpg" alt="临近过滤和线性过滤比较"></p><h3 id="过滤函数"><a href="#过滤函数" class="headerlink" title="过滤函数"></a>过滤函数</h3><p>我们需要对放大(Magnify)和缩小(Minify)的情况设置过滤效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure><h2 id="多级渐远纹理"><a href="#多级渐远纹理" class="headerlink" title="多级渐远纹理"></a>多级渐远纹理</h2><p>在3D世界,根据物体的远近不同,物体也存在缩放的效果,要显示不同的分辨率,若都使用相同的分辨率,一是会使物体产生不真实的效果,二是会造成内存的浪费. 在研究3D纹理时再说.~~</p><h1 id="纹理代码"><a href="#纹理代码" class="headerlink" title="纹理代码"></a>纹理代码</h1><p>首先是设置 上下文,着色器,程序对象…的方法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">context1 = [[EAGLContext alloc] initWithAPI:(kEAGLRenderingAPIOpenGLES3)];</span><br><span class="line">    BOOL isSetCOntextRight = [EAGLContext setCurrentContext:context1];</span><br><span class="line">    if (!isSetCOntextRight) &#123;</span><br><span class="line">        printf(&quot;设置Context失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSString* verStr = [[NSBundle mainBundle] pathForResource:@&quot;Texture2D_Vert.glsl&quot; ofType:nil];</span><br><span class="line">    NSString* fragStr = [[NSBundle mainBundle]pathForResource:@&quot;Texture2D_Frag.glsl&quot; ofType:nil];</span><br><span class="line"></span><br><span class="line">    program1 = createGLProgramFromFile(verStr.UTF8String, fragStr.UTF8String);</span><br><span class="line">    glUseProgram(program1);</span><br><span class="line"></span><br><span class="line">    //创建,绑定渲染缓存 并分配空间</span><br><span class="line">    glGenRenderbuffers(1, &amp;renderBuf1);</span><br><span class="line">    glBindRenderbuffer(GL_RENDERBUFFER, renderBuf1);</span><br><span class="line">    // 为 color renderbuffer 分配存储空间</span><br><span class="line">    [context1 renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer*)self.layer];</span><br><span class="line"></span><br><span class="line">    //创建,绑定帧缓存 并分配空间</span><br><span class="line">    glGenFramebuffers(1, &amp;frameBuf1);</span><br><span class="line">    // 设置为当前 framebuffer</span><br><span class="line">    glBindFramebuffer(GL_FRAMEBUFFER, frameBuf1);</span><br><span class="line">    // 将 _colorRenderBuffer 装配到 GL_COLOR_ATTACHMENT0 这个装配点上</span><br><span class="line">    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class="line">                              GL_RENDERBUFFER, renderBuf1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    glClearColor(1.0, 0.0, 0.0, 1.0);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    glViewport(0, 0, self.frame.size.width, self.frame.size.height);</span><br></pre></td></tr></table></figure><p>然后是 绘制物体的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">float verData[] = &#123;</span><br><span class="line">        // 位置              颜色                 纹理坐标</span><br><span class="line">        0.5f,0.5f,0.0f,     1.0f,0.0f,0.0f,     1.0f,1.0f,</span><br><span class="line">        0.5f,-0.5f,0.0f,    0.0f,1.0f,0.0f,     1.0f,0.0f,</span><br><span class="line">        -0.5f,-0.5f,0.0f,   0.0f,0.0f,1.0f,     0.0f,0.0f,</span><br><span class="line">        -0.5f,0.5f,0.0f,    1.0f,1.0f,0.0f,     0.0f,1.0f,</span><br><span class="line">    &#125;;</span><br><span class="line">    unsigned int indices[] = &#123;</span><br><span class="line">        0,1,3,</span><br><span class="line">        1,2,3</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    glGenVertexArrays(1, &amp;VAO1);</span><br><span class="line">    glGenBuffers(1, &amp;VBO1);</span><br><span class="line">    glGenBuffers(1, &amp;EBO1);</span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAO1);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO1);</span><br><span class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO1);</span><br><span class="line"></span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, sizeof(verData), verData, GL_STATIC_DRAW);</span><br><span class="line">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8*sizeof(float), (void*)0);</span><br><span class="line">    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8*sizeof(float), (void*)(3*sizeof(float)));</span><br><span class="line">    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8*sizeof(float), (void*)(6*sizeof(float)));</span><br><span class="line"></span><br><span class="line">    glEnableVertexAttribArray(0);</span><br><span class="line">    glEnableVertexAttribArray(1);</span><br><span class="line">    glEnableVertexAttribArray(2);</span><br></pre></td></tr></table></figure><h2 id="纹理设置"><a href="#纹理设置" class="headerlink" title="纹理设置~~"></a>纹理设置~~</h2><p>stbi_image 一个非常流行的单头文件图像加载库 <a href="https://github.com/nothings/stb/blob/master/stb_image.h" target="_blank" rel="external">stbi_image</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">//因为使用 stbi 函数导入的图片会颠倒,所以需要将其摆正</span><br><span class="line">stbi_set_flip_vertically_on_load(true);</span><br><span class="line"></span><br><span class="line">NSString* imPath = [[NSBundle mainBundle] pathForResource:@&quot;wall.jpg&quot; ofType:nil];</span><br><span class="line">int width,height,nrChannels;</span><br><span class="line"></span><br><span class="line">//加载图片</span><br><span class="line">unsigned char * imdata = stbi_load(imPath.UTF8String, &amp;width, &amp;height, &amp;nrChannels, 0);</span><br><span class="line"></span><br><span class="line">//创建 纹理</span><br><span class="line">unsigned int texture;</span><br><span class="line">glGenTextures(1, &amp;texture);</span><br><span class="line"></span><br><span class="line">//激活纹理单元0</span><br><span class="line">glActiveTexture(GL_TEXTURE0);</span><br><span class="line">//绑定纹理</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line">//将图像传入纹理</span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, imdata);</span><br><span class="line"></span><br><span class="line">//glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line"></span><br><span class="line">//设置纹理环绕和纹理过滤</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line"></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line">//将不用的图像释放</span><br><span class="line">stbi_image_free(imdata);</span><br><span class="line"></span><br><span class="line">//将纹理作为统一变量传入显存</span><br><span class="line">glUniform1i(glGetUniformLocation(program1, &quot;outTexture&quot;), 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//这里PNG格式 通过stbi_load 拉入时 会导致产生 BGRA格式(我也不大清楚原因,懂的朋友 告告我 先O(∩_∩)O谢谢了) ,这时 图片作为纹理显示时色彩会出错.所以将其转换一蛤~</span><br><span class="line">NSString* imPath1 = [[NSBundle mainBundle] pathForResource:@&quot;face.png&quot; ofType:nil];</span><br><span class="line">int width1,height1,nrChannels1;</span><br><span class="line">unsigned char * imdata1 = stbi_load(imPath1.UTF8String, &amp;width1, &amp;height1, &amp;nrChannels1, STBI_rgb_alpha);</span><br><span class="line">for (int i = 0; i&lt;width1*height1; i++ ) &#123;</span><br><span class="line">    char tR = imdata1[i*4+2];</span><br><span class="line">    imdata1[i*4+2] = imdata1[i*4];</span><br><span class="line">    imdata1[i*4] = tR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned int texture1;</span><br><span class="line"></span><br><span class="line">glGenTextures(1, &amp;texture1);</span><br><span class="line">glActiveTexture(GL_TEXTURE1);       //必须先写这个再绑定</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line"></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line"></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width1, height1, 0, GL_RGBA, GL_UNSIGNED_BYTE, imdata1);</span><br><span class="line">glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">stbi_image_free(imdata1);</span><br><span class="line"></span><br><span class="line">glUniform1i(glGetUniformLocation(program1, &quot;outTexture1&quot;), 1);</span><br><span class="line"></span><br><span class="line">//绘制显示</span><br><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</span><br><span class="line">[context1 presentRenderbuffer:GL_RENDERBUFFER];</span><br></pre></td></tr></table></figure><p>片段着色器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#version 300 es</span><br><span class="line"></span><br><span class="line">precision mediump float;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">in vec2 outTexCoord;</span><br><span class="line"></span><br><span class="line">uniform sampler2D outTexture;</span><br><span class="line">uniform sampler2D outTexture1;</span><br><span class="line"></span><br><span class="line">in vec3 outColor;</span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">FragColor = mix(texture(outTexture,outTexCoord),texture(outTexture1,outTexCoord),0.2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GLSL内建的mix函数需要接受两个值作为参数，并对它们根据第三个参数进行线性插值。如果第三个值是0.0，它会返回第一个输入；如果是1.0，会返回第二个输入值。0.2会返回80%的第一个输入颜色和20%的第二个输入颜色，即返回两个纹理的混合色。</p><h3 id="函数补充说明"><a href="#函数补充说明" class="headerlink" title="函数补充说明"></a>函数补充说明</h3><p>glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid* pixels);</p><blockquote><p>target 纹理目标 设置为GL_TEXTURE_2D意味着会生成与当前绑定的纹理对象在同一个目标上的纹理<br>level 为纹理指定多级渐远纹理的级别,0表示基本级别<br>internalformat 希望将纹理存储为何等格式<br>width height 图像宽高<br>border 设置为0 说是历史遗留问题<br>format 源图格式  type 数据格式<br>pixels 图像数据 </p></blockquote><h3 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h3><p>在代码中 使用 <code>glUniform1i</code>方法进行纹理传递 是因为 纹理单元 这个概念.<br>使用<code>glUniform1i</code>可以为纹理采样器分配一个位置值,通过把纹理单元赋值给采样器,就可以一次绑定多个纹理.</p><p>OpenGL至少保证有16个纹理单元供你使用，也就是说你可以激活从GL_TEXTURE0到GL_TEXTRUE15。它们都是按顺序定义的，所以我们也可以通过GL_TEXTURE0 + 8的方式获得GL_TEXTURE8，这在当我们需要循环一些纹理单元的时候会很有用。</p><p>需要注意的是 在绑定纹理时 <strong>先要激活纹理单元</strong>才可以</p><p>显示结果<br><img src="/images/OpenGL ES on iOS --- 2D纹理/Simulator%20Screen%20Shot%20-%20iPhone%20X%20-%202017-11-29%20at%2010.46.10.png" alt="GitHub" title="GitHub,Social Coding" width="375" height="667"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;纹理是用来丰富我们绘制物体细节的,它可以是一张2D图片(除了图像外,纹理也被用来存储大量数据,传递到着色器上),就像贴图一样贴在绘制的物体上
      
    
    </summary>
    
    
      <category term="Opengl ES" scheme="http://yoursite.com/tags/Opengl-ES/"/>
    
  </entry>
  
  <entry>
    <title>Opengl ES 3.0 on iOS--- 统一变量(Uniform)和统一变量块(UBO)</title>
    <link href="http://yoursite.com/2017/11/28/OpenGL%20ES%20on%20iOS%20---%20%E7%BB%9F%E4%B8%80%E5%8F%98%E9%87%8F(Uniform)%E5%92%8C%E7%BB%9F%E4%B8%80%E5%8F%98%E9%87%8F%E5%9D%97(UBO)/"/>
    <id>http://yoursite.com/2017/11/28/OpenGL ES on iOS --- 统一变量(Uniform)和统一变量块(UBO)/</id>
    <published>2017-11-28T02:46:18.000Z</published>
    <updated>2017-12-13T12:58:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。</p><blockquote><p>首先，uniform是<strong>全局</strong>的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。<br>第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</p></blockquote><h1 id="单独统一变量"><a href="#单独统一变量" class="headerlink" title="单独统一变量"></a>单独统一变量</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p><code>uniform vec3 color</code></p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//获取指定统一变量的location</span><br><span class="line">int vertexColorLocation = glGetUniformLocation(_program, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">//为vec3 的统一变量 赋值</span><br><span class="line">glUniform3f(vertexColorLocation, 0.0f, 1.0f, 0.0f);</span><br></pre></td></tr></table></figure><p>赋值函数是根据 统一变量类型的不同而调整的.其中函数名中包含数字（1、2、3、4）表示接受这个数字个用于更改uniform变量的值，i表示32位整形，f表示32位浮点型，ub表示8位无符号byte，ui表示32位无符号整形，v表示接受相应的指针类型(或者就是传入的是数组)。</p><blockquote><p><code>glUniform1f(GLint locaation,GLFloat x)</code> 表示 float类型<br><code>glUniform2f(GLint locaation,GLFloat x,GLFloat y)</code> 表示 二位向量 分量类型为float<br><code>glUniform1fv(GLint locaation,GLSize count,const GLfloat* value)</code> float类型指针<br><code>glUniformMatrix4x3(Glint location,GLsizei count,GLboolean transpose,const GLfloat* value)</code> 表示为 4x3矩阵. 参数: transpose 表示是否采用 行优先顺序(GL_TRUE)</p></blockquote><h1 id="UBO"><a href="#UBO" class="headerlink" title="UBO"></a>UBO</h1><p>UBO(Uniform Buffer Object)是用来存储着色语言中Uniform类型变量的<strong>缓冲区对象</strong>，使用UBO可以让uniform变量在不同的着色语言程序中实现共用，也可以在着色语言程序中实现uniform类型变量的设置与更新。</p><p>提到UBO就必须要提到着色语言GLSL中的Uniform Blocks，它将众多的Uniform类型的变量集中在一起进行统一的管理，对于需要大量Uniform类型变量的程序可以显著地提高性能。(有点像全局版的VBO)</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/images/OpenGL ES on iOS --UBO/15118303676115.jpg" alt="UBO示意图"></p><p>在显存中创建缓存对象(Buffer),在buffer中存储统一变量数据, 将Buffer与 指定的point绑定, 将统一变量缓冲区的索引 和 point绑定. 这样通过point 将变量 和 缓存 连接.</p><h2 id="设置UBO"><a href="#设置UBO" class="headerlink" title="设置UBO"></a>设置UBO</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//统一变量块</span><br><span class="line">layout (std140) uniform colorBlock&#123;</span><br><span class="line">    vec4 cc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">GLuint blockid,bufferid;</span><br><span class="line">GLint blocksize;</span><br><span class="line">GLint point = 1;</span><br><span class="line"></span><br><span class="line">// 统一变量数据</span><br><span class="line">GLfloat blockData[] = &#123;</span><br><span class="line">    1.0f,1.0f,1.0f,1.0f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//获取统一变量块索引</span><br><span class="line">blockid = glGetUniformBlockIndex(_program, &quot;colorBlock&quot;);</span><br><span class="line"></span><br><span class="line">//获取统一变量块大小</span><br><span class="line">glGetActiveUniformBlockiv(_program, blockid, GL_UNIFORM_BLOCK_DATA_SIZE, &amp;blocksize);</span><br><span class="line"></span><br><span class="line">//将变量索引 和 point 绑定</span><br><span class="line">glUniformBlockBinding(_program, blockid, point);</span><br><span class="line"></span><br><span class="line">//创建与绑定缓冲区</span><br><span class="line">glGenBuffers(1, &amp;bufferid);</span><br><span class="line">glBindBuffer(GL_UNIFORM_BUFFER, bufferid);</span><br><span class="line"></span><br><span class="line">//向缓冲区中赋值</span><br><span class="line">glBufferData(GL_UNIFORM_BUFFER, blocksize, blockData, GL_DYNAMIC_DRAW);</span><br><span class="line"></span><br><span class="line">//将UBO 和 point 绑定</span><br><span class="line">glBindBufferBase(GL_UNIFORM_BUFFER, point, bufferid);</span><br></pre></td></tr></table></figure><h2 id="修改UBO"><a href="#修改UBO" class="headerlink" title="修改UBO"></a>修改UBO</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GLfloat uploadData[] = &#123;</span><br><span class="line">    0.0f,0.0f,1.0f,1.0f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 绑定当然统一变量块的 buffer</span><br><span class="line">glBindBuffer(GL_UNIFORM_BUFFER, bufferid);</span><br><span class="line"></span><br><span class="line">//获取统一变量块 中 指定变量的 偏移量</span><br><span class="line">const GLchar *names[] = &#123;&quot;cc&quot;&#125;;</span><br><span class="line">GLuint indices[1];</span><br><span class="line">glGetUniformIndices(_program, 1, names, indices);</span><br><span class="line">GLint offset[1];</span><br><span class="line">glGetActiveUniformsiv(_program, 1, indices, GL_UNIFORM_OFFSET, offset);</span><br><span class="line">glBufferSubData(GL_UNIFORM_BUFFER, offset[0], blocksize, uploadData);</span><br></pre></td></tr></table></figure><h3 id="函数补充"><a href="#函数补充" class="headerlink" title="函数补充"></a>函数补充</h3><p>1, <code>glGetUniformIndices (GLuint program, GLsizei uniformCount, const GLchar* const *uniformNames, GLuint* uniformIndices)</code><br>该函数用于获取统一变量块中 变量们的索引 参数:</p><blockquote><p>program 程序对象<br>uniformCount 变量名称数组的元素数量<br>uniformNames 变量名称数组<br>uniformIndices 用于接受变量索引的数组</p></blockquote><p>2,<code>glGetActiveUniformsiv (GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params)</code><br>该函数用于 通过变量索引 查询变量信息. 参数:</p><blockquote><p>program 程序对象<br>uniformCount 变量数量<br>uniformIndices 变量索引数组<br>pname 表示要查询变量的那个属性 GL_UNIFORM_OFFSET(变量偏移量)  GL_UNIFORM_SIZE(变量大小) GL_UNIFORM_NAME_LENGTH(变量名长度) GL_UNIFORM_TYPE(变量类型)….<br>params 接受查询结果的数组</p></blockquote><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><h2 id="着色语言编译优化"><a href="#着色语言编译优化" class="headerlink" title="着色语言编译优化"></a>着色语言编译优化</h2><p>如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，导致最后编译出的版本中并不会包含它.</p><h2 id="UBO限定符"><a href="#UBO限定符" class="headerlink" title="UBO限定符"></a>UBO限定符</h2><p>在UBO中,针对不同的限定符 还存在不同的字节补齐的情况.所以获取偏移量,大小最好还是通过查询进行,避免自己计算出现错误.</p><p>这是 std140(标准统一变量块布局)限定符的内存分配情况:</p><p><img src="/images/OpenGL ES on iOS --UBO/screenshot.png" alt="std140"></p><p>其他的限定符 在我学了之后会补上~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。&lt;/p&gt;
&lt;blockquote&gt;
      
    
    </summary>
    
    
      <category term="Opengl ES" scheme="http://yoursite.com/tags/Opengl-ES/"/>
    
  </entry>
  
  <entry>
    <title>Opengl ES 3.0 on iOS -- EAGLContext</title>
    <link href="http://yoursite.com/2017/11/27/Opengl%20ES%203.0%20on%20iOS%20--%20EAGLContext/"/>
    <id>http://yoursite.com/2017/11/27/Opengl ES 3.0 on iOS -- EAGLContext/</id>
    <published>2017-11-27T06:44:17.000Z</published>
    <updated>2017-12-13T12:58:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>EAGLContext对象是管理OpenGL ES渲染上下文,若想使用OpenGL ES 进行绘制工作,则必须一个上下文对象.</p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (nullable instancetype) initWithAPI:(EAGLRenderingAPI) api;</span><br><span class="line">- (nullable instancetype) initWithAPI:(EAGLRenderingAPI) api sharegroup:(EAGLSharegroup*) sharegroup NS_DESIGNATED_INITIALIZER;</span><br></pre></td></tr></table></figure><p>参数:</p><blockquote><p>api 表示将要使用的OpenGL ES 版本. <code>kEAGLRenderingAPIOpenGLES3</code> 表示使用3.0</p><p>sharegroup 对象管理与一个或多个EAGLContext对象关联的OpenGL ES资源,若不指定或值为NULL则创建新的对象,当资源需要被共享时再使用它.</p></blockquote><h2 id="绑定上下文"><a href="#绑定上下文" class="headerlink" title="绑定上下文"></a>绑定上下文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)setCurrentContext:(nullable EAGLContext*) context;</span><br></pre></td></tr></table></figure><p>绑定一个<strong>全局</strong>的上下文对象. 注意: 1, 需要手动对该对象强引用,否则将会被释放. 2, 该对象线程不安全, 使用时应防止同时从多个线程访问同一个上下文对象</p><h2 id="分配渲染缓冲区"><a href="#分配渲染缓冲区" class="headerlink" title="分配渲染缓冲区"></a>分配渲染缓冲区</h2><p><code>- (BOOL)renderbufferStorage:(NSUInteger)target fromDrawable:(nullable id&lt;EAGLDrawable&gt;)drawable;</code><br>通过调用此方法为缓冲区分配共享的存储空间, 此方法是替代 原<code>glRenderbufferStorage</code>方法的.<br>参数:</p><blockquote><p>target :当前绑定的渲染缓冲区的OpenGL ES绑定点。 此参数的值必须是<strong>GL_RENDERBUFFER</strong>（或OpenGL ES 1.1上下文中的GL_RENDERBUFFER_OES）</p><p>drawable :管理渲染缓冲区的数据存储的对象。 在iOS中，此参数的值必须是<strong>CAEAGLLayer</strong>对象</p></blockquote><h2 id="显示缓冲区内容"><a href="#显示缓冲区内容" class="headerlink" title="显示缓冲区内容"></a>显示缓冲区内容</h2><p><code>- (BOOL)presentRenderbuffer:(NSUInteger)target;</code><br>将渲染缓冲区的内容展示在屏幕上.<br>参数: </p><blockquote><p>target : 当前绑定的渲染缓冲区的OpenGL ES绑定点。 此参数的值必须是<strong>GL_RENDERBUFFER</strong>（或OpenGL ES 1.1上下文中的GL_RENDERBUFFER_OES）。</p></blockquote><p>在典型的显示系统中,物理屏幕以固定的速率从帧缓冲区内存中更新,若我们直接绘制带帧缓冲区,那么用户在部分更新帧缓冲区时会看到伪像. 在OpenGL中采用双缓冲区, 分为 前缓冲区 和 后缓冲区.</p><p>所有的渲染都发生在后台缓冲区,它位于不可见于屏幕的内存区域,当所有渲染完成时,这个渲染将被 交换 到前台缓冲区用于显示, 然后原 前台缓冲区就下一帧的后台缓冲区</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;EAGLContext对象是管理OpenGL ES渲染上下文,若想使用OpenGL ES 进行绘制工作,则必须一个上下文对象.&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="Opengl ES" scheme="http://yoursite.com/tags/Opengl-ES/"/>
    
  </entry>
  
  <entry>
    <title>Opengl ES 3.0 on iOS--- HelloWord(绘制彩色矩形)</title>
    <link href="http://yoursite.com/2017/11/27/Opengl%20ES%203.0%20on%20iOS---%20HelloWord(%E7%BB%98%E5%88%B6%E5%BD%A9%E8%89%B2%E7%9F%A9%E5%BD%A2)/"/>
    <id>http://yoursite.com/2017/11/27/Opengl ES 3.0 on iOS--- HelloWord(绘制彩色矩形)/</id>
    <published>2017-11-27T06:43:38.000Z</published>
    <updated>2017-12-13T12:58:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文记录了我初学Opengl 绘制彩色矩形的过程,可能我对内容的描述不够准确,还请多多指正</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="配置图层"><a href="#配置图层" class="headerlink" title="配置图层"></a>配置图层</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+(Class)layerClass&#123;</span><br><span class="line">    return [CAEAGLLayer class];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将当前View的Layer替换成 <code>CAEAGLLayer</code>类,opengl的绘制内容也是在该View上显示的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置不透明度为YES,因为透明图层性能不好</span><br><span class="line">self.layer.opaque = YES;</span><br><span class="line">self.layer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:</span><br><span class="line">                                         [NSNumber numberWithBool:NO], kEAGLDrawablePropertyRetainedBacking, kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil];</span><br></pre></td></tr></table></figure><p>可以对<code>CAEAGLLayer</code>进行额外属性的配置:</p><blockquote><p>kEAGLDrawablePropertyRetainedBacking 传入布尔值,表示是否保持绘制状态,若设置为NO,则下次将重新绘制.<br>kEAGLDrawablePropertyColorFormat 设置layer的颜色缓冲区格式,EAGLContext对象 使用此格式来创建渲染缓冲区的存储.<br>kEAGLColorFormatRGB565 —&gt; 16bit RGB格式<br>kEAGLColorFormatRGBA8 —&gt; 32-bit RGBA格式</p></blockquote><h2 id="配置上下文"><a href="#配置上下文" class="headerlink" title="配置上下文"></a>配置上下文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];</span><br><span class="line">    if (!_context) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将当前上下文设置为我们创建的上下文</span><br><span class="line">    if (![EAGLContext setCurrentContext:_context]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置缓冲区-渲染缓冲和帧缓冲"><a href="#设置缓冲区-渲染缓冲和帧缓冲" class="headerlink" title="设置缓冲区(渲染缓冲和帧缓冲)"></a>设置缓冲区(渲染缓冲和帧缓冲)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//在缓冲区中返回n个渲染缓冲对象句柄,不保证这些句柄是连续的整数,但是肯定没有被使用.</span><br><span class="line">GLuint renderbuffer[1];</span><br><span class="line">glGenRenderbuffers(ARRAY_SIZE(renderbuffer), renderbuffer);</span><br><span class="line"></span><br><span class="line">//将缓冲区对象和句柄 绑定到指定的缓冲区目标.</span><br><span class="line">glBindRenderbuffer(GL_RENDERBUFFER, renderbuffer[0]);</span><br><span class="line"></span><br><span class="line">//检验是否创建绑定成功</span><br><span class="line">if (glIsRenderbuffer(renderbuffer[0]) == GL_TRUE) &#123;</span><br><span class="line">    NSLog(@&quot;成功生成渲染缓存&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//为缓冲区对象分配存储空间.</span><br><span class="line">[self.context renderbufferStorage:GL_RENDERBUFFER fromDrawable:layer];</span><br><span class="line"></span><br><span class="line">//设置帧缓冲区(Frame Buffer),和渲染缓冲区大致相同</span><br><span class="line">GLuint framebuffer[1];</span><br><span class="line">glGenFramebuffers(ARRAY_SIZE(framebuffer), framebuffer);</span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, framebuffer[0]);</span><br><span class="line">if (glIsFramebuffer(framebuffer[0]) == GL_TRUE) &#123;</span><br><span class="line">    NSLog(@&quot;成功绑定帧缓存&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将相关的buffer依附到 帧缓存上 </span><br><span class="line">glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, renderbuffer[0]);</span><br><span class="line"></span><br><span class="line">    //释放渲染缓存</span><br><span class="line">    //glDeleteRenderbuffers(ARRAY_SIZE(renderbuffer), renderbuffer);</span><br><span class="line">    //释放帧缓存</span><br><span class="line">    //glDeleteFramebuffers(ARRAY_SIZE(framebuffer), framebuffer);</span><br></pre></td></tr></table></figure><p>渲染缓存: 是OpenGL ES管理的一块高效内存区域,渲染缓存的数据只有关联一个帧缓存对象才有意义,并且需要保证图像缓存格式 必须与OpenGL ES要求的渲染格式相符.</p><p>帧缓存：它是屏幕所显示画面的一个直接映象，又称为位映射图(Bit Map)或光栅。帧缓存的每一存储单元对应屏幕上的一个像素，整个帧缓存对应一帧图像。</p><h3 id="函数解释"><a href="#函数解释" class="headerlink" title="函数解释"></a>函数解释</h3><p><code>glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, renderbuffer[0]);</code><br>参数:</p><blockquote><p>target: 指定的帧缓冲区目标 必须是 GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER, 或 GL_FRAMEBUFFER. (GL_FRAMEBUFFER = GL_DRAW_FRAMEBUFFER);<br>attachment: 帧缓存对象依附的目标 GL_COLOR_ATTACHMENT(0~i) —&gt; 第i个颜色缓存 0为默认值, GL_DEPTH_ATTACHMENT —&gt; 深度缓存, GL_STENCIL_ATTACHMENT —&gt; 模板缓存<br>renderbuffertarget :必须为 GL_RENDERBUFFER,指定的渲染缓存区目标<br>renderbuffer: 渲染缓冲区对象句柄.</p></blockquote><h2 id="准备着色器源码"><a href="#准备着色器源码" class="headerlink" title="准备着色器源码"></a>准备着色器源码</h2><p>OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的<strong>图形渲染管线</strong>.OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线</p><p><strong>着色器(Shader)</strong>是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。</p><p>着色器是使用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。</p><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#version 300 es //OpenGL ES 3.0</span><br><span class="line"></span><br><span class="line">//接受的输入变量</span><br><span class="line">layout(location = 0) in vec3 position;</span><br><span class="line">layout(location = 1) in vec3 color;</span><br><span class="line"></span><br><span class="line">//输出变量</span><br><span class="line">out vec3 outColor;</span><br><span class="line"></span><br><span class="line">//相当于C语言的main函数</span><br><span class="line">void main()</span><br><span class="line">&#123;   </span><br><span class="line">    //绘制图形</span><br><span class="line">    gl_Position = vec4(position[0],position[1],position[2], 1.0);</span><br><span class="line">    </span><br><span class="line">    outColor = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图形渲染管线的第一个部分是顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入.一个顶点(Vertex)是一个3D坐标的数据的集合。而顶点数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据.</p><h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#version 300 es</span><br><span class="line"></span><br><span class="line">precision mediump float;    //表示 数据精确度 这里设置的为中级</span><br><span class="line"></span><br><span class="line">in vec3 outColor;</span><br><span class="line"></span><br><span class="line">out vec4 FragColor; //输出的色彩</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = vec4(outColor.x,outColor.y,outColor.z, 1.0);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算<strong>最终像素的颜色</strong>。</p><p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做<strong>Alpha测试</strong>和<strong>混合(Blending)阶段</strong>。这个阶段检测片段的对应的深度（和模板(Stencil)）值，用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p><h2 id="创建着色器对象"><a href="#创建着色器对象" class="headerlink" title="创建着色器对象"></a>创建着色器对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">static GLuint createGLShader(const char *shaderText, GLenum shaderType)</span><br><span class="line">&#123;</span><br><span class="line">    //创建着色器,将根据传入的type参数 创建一个新的 顶点或片段着色器,返回值为新的着色器对象句柄</span><br><span class="line">    //GL_VERTEX_SHADER(顶点着色器)     GL_FRAGMENT_SHADER(片段着色器)</span><br><span class="line">    GLuint shader = glCreateShader(shaderType);</span><br><span class="line"></span><br><span class="line">    //为着色器对象 提供着色器源代码.</span><br><span class="line">    //参数: shader --&gt; 着色器对象句柄</span><br><span class="line">    //      count --&gt; 着色器源字符串数量</span><br><span class="line">    //      string --&gt; 字符串的数组指针</span><br><span class="line">    //      length ---&gt; 指向保存美工着色器字符串大小且元素数量为count的整数数组指针.如果length为NULL 着色器字符串将被认定为空.</span><br><span class="line">    glShaderSource(shader, 1, &amp;shaderText, NULL);</span><br><span class="line"></span><br><span class="line">    //调用该方法,将指定的着色器源代码 进行编译</span><br><span class="line">    //参数shader 为着色器句柄</span><br><span class="line">    glCompileShader(shader);</span><br><span class="line"></span><br><span class="line">    //调用该方法获取 着色器源代码编译是否成功,并获取其他相关信息</span><br><span class="line">    //第二个参数 pname 表示要查询什么信息</span><br><span class="line">    /*</span><br><span class="line">     GL_COMPILE_STATUS ---&gt; 是否编译成功 成功返回 GL_TRUE</span><br><span class="line">     GL_INFO_LOG_LENGTH ---&gt; 查询源码编译后长度</span><br><span class="line">     GL_SHADER_SOURCE_LENGTH ---&gt; 查询源码长度</span><br><span class="line">     GL_SHADER_TYPE ---&gt; 查询着色器类型()</span><br><span class="line">     GL_DELETE_STATUS ---&gt; 着色器是否被标记删除</span><br><span class="line">     */</span><br><span class="line">    int compiled = 0;</span><br><span class="line">    glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;compiled);</span><br><span class="line">    if (!compiled) &#123;</span><br><span class="line">        GLint infoLen = 0;</span><br><span class="line">        glGetShaderiv (shader, GL_INFO_LOG_LENGTH, &amp;infoLen);</span><br><span class="line">        if (infoLen &gt; 1) &#123;</span><br><span class="line">            char *infoLog = (char *)malloc(sizeof(char) * infoLen);</span><br><span class="line">            if (infoLog) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                //检索信息日志</span><br><span class="line">                //参数: shader 着色器对象句柄</span><br><span class="line">                //      maxLength 保存信息日志的缓冲区大小</span><br><span class="line">                //      length 写入信息日志长度 ,不需要知道可传NULL</span><br><span class="line">                //      infoLog 保存日志信息的指针</span><br><span class="line">                glGetShaderInfoLog (shader, infoLen, NULL, infoLog);</span><br><span class="line">                GLlog(&quot;Error compiling shader: %s\n&quot;, infoLog);</span><br><span class="line">                free(infoLog);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //删除着色器对象, 参数shader为要删除的着色器对象的句柄</span><br><span class="line">        //若一个着色器链接到一个程序对象,那么该方法不会立刻删除着色器,而是将着色器标记为删除,当着色器不在连接到任何程序对象时,它的内存将被释放.</span><br><span class="line">        glDeleteShader(shader);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return shader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建程序对象"><a href="#创建程序对象" class="headerlink" title="创建程序对象"></a>创建程序对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个程序对象,返回程序对象的句柄</span><br><span class="line">   GLuint program = glCreateProgram();</span><br><span class="line"></span><br><span class="line">   // 得到需要的着色器</span><br><span class="line">   GLuint vertShader = createGLShader(vertext, GL_VERTEX_SHADER);  //顶点着色器</span><br><span class="line">   GLuint fragShader = createGLShader(frag, GL_FRAGMENT_SHADER);   //片元着色器</span><br><span class="line">   </span><br><span class="line">   if (vertShader == 0 || fragShader == 0) &#123;</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //将程序对象和 着色器对象链接  //在ES 3.0中,每个程序对象 必须连接一个顶点着色器和片段着色器</span><br><span class="line">   //program程序对象句柄 shader着色器句柄</span><br><span class="line">   glAttachShader(program, vertShader);</span><br><span class="line">   glAttachShader(program, fragShader);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   //链接程序对象 生成可执行程序(在着色器已完成编译 且程序对象连接了着色器)</span><br><span class="line">   //链接程序会检查各种对象的数量,和各种条件.</span><br><span class="line">   //在链接阶段就是生成最终硬件指令的时候(和C语言一样)</span><br><span class="line">   glLinkProgram(program);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   //检查链接是否成功</span><br><span class="line">   GLint success;</span><br><span class="line">   glGetProgramiv(program, GL_LINK_STATUS, &amp;success);</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   if (!success) &#123;</span><br><span class="line">       GLint infoLen;</span><br><span class="line">       //使用 GL_INFO_LOG_LENGTH 表示获取信息日志</span><br><span class="line">       glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;infoLen);</span><br><span class="line">       if (infoLen &gt; 1) &#123;</span><br><span class="line">           GLchar *infoText = (GLchar *)malloc(sizeof(GLchar)*infoLen + 1);</span><br><span class="line">           if (infoText) &#123;</span><br><span class="line">               memset(infoText, 0x00, sizeof(GLchar)*infoLen + 1);</span><br><span class="line"></span><br><span class="line">               // 从信息日志中获取信息</span><br><span class="line">               glGetProgramInfoLog(program, infoLen, NULL, infoText);</span><br><span class="line">               GLlog(&quot;%s&quot;, infoText);</span><br><span class="line">               free(infoText);</span><br><span class="line"></span><br><span class="line">               //此函数用于校验当前的程序对象,校验结果可通过 glGetProgramiv函数检查,此函数只用于调试,因为他很慢.</span><br><span class="line">               //glValidateProgram(program);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       glDeleteShader(vertShader);</span><br><span class="line">       glDeleteShader(fragShader);</span><br><span class="line"></span><br><span class="line">       //删除程序对象</span><br><span class="line">       glDeleteProgram(program);</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   /*</span><br><span class="line">* 链接完着色器,生成可执行程序. 将着色器断开删除</span><br><span class="line">*/</span><br><span class="line">   //断开指定程序对象和片段着色器</span><br><span class="line">   glDetachShader(program, vertShader);</span><br><span class="line">   glDetachShader(program, fragShader);</span><br><span class="line"></span><br><span class="line">   //将着色器标记为删除</span><br><span class="line">   glDeleteShader(vertShader);</span><br><span class="line">   glDeleteShader(fragShader);</span><br></pre></td></tr></table></figure><p>程序对象就是一个容器对象,将着色器与之连接,最后链接生成最终的可执行程序.</p><h2 id="输入顶点数据"><a href="#输入顶点数据" class="headerlink" title="输入顶点数据"></a>输入顶点数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//三角形的三点坐标+颜色坐标</span><br><span class="line">static GLfloat vertices[] = &#123;</span><br><span class="line">    //点坐标                     //颜色</span><br><span class="line">    0.5f,  0.5f, 0.0f,          1.0f, 0.0f, 0.0f,</span><br><span class="line">    0.5f, -0.5f, 0.0f,          0.0f, 1.0f, 0.0f,</span><br><span class="line">    -0.5f, -0.5f, 0.0f,         0.0f, 0.0f, 1.0f,</span><br><span class="line">    -0.5f, 0.5f, 0.0f,          1.0f, 0.0f, 1.0f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static unsigned int indices[] = &#123;</span><br><span class="line">    0,1,3,</span><br><span class="line">    1,2,3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unsigned int VAO,VBO,EBO;</span><br><span class="line">//创建VAO对象,VBO对象,EBO对象</span><br><span class="line">glGenVertexArrays(1, &amp;VAO);</span><br><span class="line">glGenBuffers(1, &amp;VBO);</span><br><span class="line">glGenBuffers(1, &amp;EBO);</span><br><span class="line"></span><br><span class="line">//绑定VAO VBO EBO</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line"></span><br><span class="line">将顶点数据 和 索引数据 复制到缓冲区中</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">//设置顶点属性指针 输入数据</span><br><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6*sizeof(float), (void*)0);</span><br><span class="line">//激活 0号变量,为了性能,若不激活着色器无法接受数据</span><br><span class="line">glEnableVertexAttribArray(0);</span><br><span class="line"></span><br><span class="line">glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6*sizeof(float), (void*)(3*sizeof(float)));</span><br><span class="line">glEnableVertexAttribArray(1);</span><br><span class="line">glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6*sizeof(float), (void*)(3*sizeof(float)));</span><br><span class="line">glEnableVertexAttribArray(1);</span><br></pre></td></tr></table></figure><h3 id="VAO-VBO-EBO"><a href="#VAO-VBO-EBO" class="headerlink" title="VAO VBO EBO"></a>VAO VBO EBO</h3><p>不使用VAO VBO绘制代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static GLfloat vertices[] = &#123;</span><br><span class="line">    0.0f,  0.5f, 0.0f,</span><br><span class="line">    -0.5f, -0.5f, 0.0f,</span><br><span class="line">    0.5f, -0.5f, 0.0f</span><br><span class="line">&#125;;</span><br><span class="line">GLint posSlot = glGetAttribLocation(_program, &quot;position&quot;);</span><br><span class="line">glVertexAttribPointer(posSlot, 3, GL_FLOAT, GL_FALSE, 0, vertices);</span><br><span class="line">glEnableVertexAttribArray(posSlot);</span><br><span class="line"></span><br><span class="line">static GLfloat colors[] = &#123;</span><br><span class="line">    0.0f, 1.0f, 1.0f,</span><br><span class="line">    1.0f, 0.0f, 1.0f,</span><br><span class="line">    1.0f, 1.0f, 0.0f</span><br><span class="line">&#125;;</span><br><span class="line">GLint colorSlot = glGetAttribLocation(_program, &quot;color&quot;);</span><br><span class="line">glVertexAttribPointer(colorSlot, 3, GL_FLOAT, GL_FALSE, 0, colors);</span><br><span class="line">glEnableVertexAttribArray(colorSlot);</span><br></pre></td></tr></table></figure><h4 id="VBO"><a href="#VBO" class="headerlink" title="VBO"></a>VBO</h4><p>如上面的例子所示, 普通的顶点数组的传输，需要在绘制的时候频繁地从CPU到GPU传输顶点数据，这种做法效率低下.<br>为了加快显示速度，显卡增加了一个扩展 <strong>VBO</strong> (Vertex Buffer object)，即<strong>顶点缓存</strong>。它直接在 <strong>GPU 中开辟一个缓存区</strong>域来存储顶点数据，因为它是用来缓存储顶点数据，因此被称之为顶点缓存。使用顶点缓存能够大大较少了CPU到GPU 之间的数据拷贝开销，因此显著地提升了程序运行的效率。</p><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>1, 创建顶点缓存对象<br><code>void glGenBuffers (GLsizei n, GLuint* buffers);</code></p><blockquote><p>参数 n ： 表示需要创建顶点缓存对象的个数<br>参数 buffers ：用于存储创建好的顶点缓存对象句柄</p></blockquote><p>2, 将顶点缓存对象设置为当前数组缓存对象<br><code>void glBindBuffer (GLenum target, GLuint buffer);</code></p><blockquote><p>target ：指定绑定的目标，取值为 GL_ARRAY_BUFFER（用于顶点数据） 或 GL_ELEMENT_ARRAY_BUFFER（用于索引数据）<br>buffer ：顶点缓存对象句柄</p></blockquote><p>3, 为顶点缓存对象分配空间(这里就是将数据一次性 拷贝至显存中)<br><code>void glBufferData (GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage);</code></p><blockquote><p>target：指定绑定的目标，取值为 GL_ARRAY_BUFFER（用于顶点数据） 或 GL_ELEMENT_ARRAY_BUFFER（用于索引数据）.<br>size ：指定顶点缓存区的大小，以字节为单位计数；<br>data ：用于初始化顶点缓存区的数据，可以为 NULL，表示只分配空间，之后再由 glBufferSubData 进行初始化；<br>usage ：表示该缓存区域将会被如何使用，它的主要目的是用于对该缓存区域做何种程度的优化，比如经常修改的数据可能就会放在GPU缓存中达到快速操作的目的.</p></blockquote><p>usage:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GL_STATIC_DRAW 表示该缓存区不会被修改</span><br><span class="line">GL_DYNAMIC_DRAW 表示该缓存区会被周期性更改</span><br><span class="line">GL_STREAM_DRAW 表示该缓存区会被频繁更改</span><br></pre></td></tr></table></figure></p><p>4,更新顶点缓冲区数据<br><code>void glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data);</code></p><blockquote><p>offset: 表示需要更新的数据的起始偏移量；<br>size: 表示需要更新的数据的个数，也是以字节为计数单位；<br>data: 用于更新的数据；</p></blockquote><p>5,释放顶点缓存<br><code>void glDeleteBuffers (GLsizei n, const GLuint* buffers);</code></p><blockquote><p>n ： 表示顶点缓存对象的个数<br>buffers ：顶点缓存对象句柄</p></blockquote><h4 id="VAO"><a href="#VAO" class="headerlink" title="VAO"></a>VAO</h4><p>VAO的全名是 Vertex Array Object。它不用作存储数据，但它与顶点绘制相关。<br>它的定位是<strong>状态对象</strong>，记录存储状态信息。VAO记录的是一次绘制中做需要的信息，这包括数据在哪里、数据格式是什么等信息。VAO其实可以看成一个容器，可以包括多个VBO。 由于它进一步将VBO容于其中，所以绘制效率将在VBO的基础上更进一步。目前OpenGL ES3.0及以上才支持顶点数组对象。</p><p><img src="/images/OpenglES--绘制彩色矩形/15117525484339.jpg" alt="VBO和VAO关系"></p><h5 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h5><p>1, 创建顶点数组对象<br><code>glGenVertexArrays (GLsizei n, GLuint* arrays) ;</code></p><blockquote><p>n ： 表示顶点数组对象的个数<br>arrays ：顶点数组对象句柄</p></blockquote><p>2, 将顶点数组对象设置为当前顶点数组对象<br><code>glBindVertexArray (GLuint array) ;</code></p><blockquote><p>arrays ：顶点数组对象句柄</p></blockquote><p>3,释放顶点数组对象<br><code>glDeleteVertexArrays (GLsizei n, const GLuint* arrays);</code></p><blockquote><p>n ： 表示顶点数组对象的个数<br>arrays ：顶点数组对象句柄</p></blockquote><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>如代码中所写,在绑定VAO后,后续的VBO操作都会存储到当前绑定的VAO中.这样就将当前绘制状态记录下来了. 当下次还要绘制当前图形时, 只需再次绑定当前VAO, 进行后面的绘制操作即可.对于OpenGL ES2.0 使用VAO 则需要使用另外提供的API来实现.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GLvoid glGenVertexArraysOES(GLsizei n, GLuint *arrays)</span><br><span class="line">GLvoid glBindVertexArrayOES(GLuint array);</span><br><span class="line">GLvoid glDeleteVertexArraysOES(GLsizei n, const GLuint *arrays);; </span><br><span class="line">GLboolean glIsVertexArrayOES(GLuint array);</span><br></pre></td></tr></table></figure><h4 id="EBO"><a href="#EBO" class="headerlink" title="EBO"></a>EBO</h4><p>索引缓冲对象(Element Buffer Object，EBO，也叫Index Buffer Object，IBO),当绘制现有图形时,存在顶点数据复用时,可以使用EBO. 但是这是需要斟酌的,因为在使用EBO时,在显存中 又存储的索引数据,有可能并不比原来性能更好~</p><h5 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h5><p>1,创建EBO(和VBO类似)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int EBO;</span><br><span class="line">glGenBuffers(1, &amp;EBO);</span><br></pre></td></tr></table></figure><p>2,绑定EBO,将索引复制到缓冲里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>3, 使用<code>glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</code>替代<code>glDrawArrays</code></p><h3 id="函数补充"><a href="#函数补充" class="headerlink" title="函数补充"></a>函数补充</h3><p><code>glVertexAttribPointer (GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* ptr)</code></p><p>该函数用于将顶点属性传入顶点着色器<br>参数:</p><blockquote><p>index: 对应顶你个点着色器中变量的location<br>size :表示该顶点属性对应的分量数量.也就是接收者为几位向量 如写入3 则表示为<code>vec3</code> 接收者为3维向量. 必须是 1~4.<br>type :表明每个分量的类型 可用的符号常量有<code>GL_BYTE</code>, <code>GL_UNSIGNED_BYTE</code>, <code>GL_SHORT</code>,<code>GL_UNSIGNED_SHORT</code>, <code>GL_FIXED</code>, 和 <code>GL_FLOAT</code>，初始值为<code>GL_FLOAT</code>；<br>normalized: 是否对每个分量进行归一化处理, 也就是若type为float类型.<br>stride:指定连续顶点属性之间的偏移量,如果设置0,则表示各个分量是紧密排在一起,中间没有其他多余数据.<br>ptr 顶点数据指针</p></blockquote><p>此函数在有无VBO的情况下,使用有所差异~,在不适用VBO时,ptr确实是顶点数据指针.<br>当使用VBO时,顶点数据都已经拷贝至显存中,这里的ptr 就表示为缓冲区数据的便宜量了.</p><p>无EBO:<br><code>glVertexAttribPointer(colorSlot, 3, GL_FLOAT, GL_FALSE, 0, colors);</code></p><p>有EBO:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static GLfloat vertices[] = &#123;</span><br><span class="line">            //点坐标                     //颜色</span><br><span class="line">            0.5f,  0.5f, 0.0f,          1.0f, 0.0f, 0.0f,</span><br><span class="line">            0.5f, -0.5f, 0.0f,          0.0f, 1.0f, 0.0f,</span><br><span class="line">            -0.5f, -0.5f, 0.0f,         0.0f, 0.0f, 1.0f,</span><br><span class="line">            -0.5f, 0.5f, 0.0f,          1.0f, 0.0f, 1.0f</span><br><span class="line">        &#125;;</span><br><span class="line">.......(VBO与其他代码).......</span><br><span class="line"></span><br><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6*sizeof(float), (void*)0);</span><br><span class="line">glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6*sizeof(float), (void*)(3*sizeof(float)));</span><br></pre></td></tr></table></figure><p>在这里0号属性和1号属性紧密相连,且0号和1号的分量数都为3,以0号属性开头.<br>故: 第一个0号和第二个0号 中间有6个间距 stride = 6<em>sizeof(float).<br>1号在0号后面, 0号ptr为 `(void</em>)0<code>. 1号ptr为</code>(void<em> )(3</em>sizeof(float))`</p><h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><h3 id="使用-EBO"><a href="#使用-EBO" class="headerlink" title="使用 EBO:"></a>使用 EBO:</h3><p><code>glDrawElements(GL_TRIANGLE_STRIP, 6, GL_UNSIGNED_INT, 0);</code><br>参数:<br> model:指定呈现那种图元(将这些点绘制成怎样的形状). 可选项:</p><blockquote><p>GL_POINTS(点),<br>GL_LINE_STRIP(多端线),<br>GL_LINE_LOOP(线圈),<br>GL_LINES(线段),<br>GL_TRIANGLE_FAN, (三角形扇)<br>GL_TRIANGLES, (三角形)<br>count: 传入顶点数据的数量<br>type: 索引数组的元素属性 <code>GL_UNSIGNED_BYTE</code>, <code>GL_UNSIGNED_SHORT</code>, or <code>GL_UNSIGNED_INT</code>.<br>indices: 指向索引数组的指针, 当使用VBO时,则表示为偏移量,若为紧密相连时则传入0.</p></blockquote><h3 id="不使用EBO"><a href="#不使用EBO" class="headerlink" title="不使用EBO"></a>不使用EBO</h3><p><code>glDrawArrays(GL_TRIANGLES, 0, 3);</code><br>参数: model 和上面那个含义一样.<br>     first 表示顶点数据起始索引, 从头开始则为0.<br>     count 表示要传入顶点数据的数量.</p><h3 id="最后显示"><a href="#最后显示" class="headerlink" title="最后显示"></a>最后显示</h3><p><code>[_context presentRenderbuffer:GL_RENDERBUFFER];</code></p><h1 id="学习参考"><a href="#学习参考" class="headerlink" title="学习参考"></a>学习参考</h1><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/" target="_blank" rel="external">你好三角形</a><br><a href="http://www.jianshu.com/c/30e2e76bc140" target="_blank" rel="external">OpenGL 简书专题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;本文记录了我初学Opengl 绘制彩色矩形的过程,可能我对内容的描述不够准确,还请多多指正&lt;/p&gt;
&lt;h1 id=&quot;实现&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="Opengl ES" scheme="http://yoursite.com/tags/Opengl-ES/"/>
    
  </entry>
  
  <entry>
    <title>YYAsyncLayer 学习</title>
    <link href="http://yoursite.com/2017/11/23/YYAsyncLayer%20%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2017/11/23/YYAsyncLayer 学习/</id>
    <published>2017-11-23T05:27:19.000Z</published>
    <updated>2017-12-13T12:59:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="YYAsyncLayer-学习"><a href="#YYAsyncLayer-学习" class="headerlink" title="YYAsyncLayer 学习"></a>YYAsyncLayer 学习</h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>YYAsyncLayer是用于图层异步绘制的一个组件,将耗时操作(如文本布局计算)放在RunLoop空闲时去做,进而减少卡顿.</p><h1 id="组件内容"><a href="#组件内容" class="headerlink" title="组件内容"></a>组件内容</h1><p>YYAsyncLayer主要有3个类.</p><blockquote><p>1, <strong>YYTransaction</strong>,负责将 YYAsyncLayer委托的绘制任务在RunLoop空闲时执行.</p><p>2, <strong>YYSentine</strong>, 是一个线程安全的计数器,在进行队列分配和任务取消时作为参考使用</p><p>3, <strong>YYAsyncLayer</strong>, 将其替换为View的Layer类,实现异步绘制</p></blockquote><h2 id="YYTransaction"><a href="#YYTransaction" class="headerlink" title="YYTransaction"></a>YYTransaction</h2><p><code>+ (YYTransaction *)transactionWithTarget:(id)target selector:(SEL)selector;</code>方法创建委托对象.</p><p><code>- (void)commit;</code>方法将委托对象存储在一个全局Set中,在空闲时回调.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void YYTransactionSetup() &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        transactionSet = [NSMutableSet new];</span><br><span class="line">        CFRunLoopRef runloop = CFRunLoopGetMain();</span><br><span class="line">        CFRunLoopObserverRef observer;</span><br><span class="line"></span><br><span class="line">        observer = CFRunLoopObserverCreate(CFAllocatorGetDefault(),</span><br><span class="line">                                           kCFRunLoopBeforeWaiting | kCFRunLoopExit,</span><br><span class="line">                                           true,      // repeat</span><br><span class="line">                                           0xFFFFFF,  // after CATransaction(2000000)</span><br><span class="line">                                           YYRunLoopObserverCallBack, NULL);</span><br><span class="line">        CFRunLoopAddObserver(runloop, observer, kCFRunLoopCommonModes);</span><br><span class="line">        CFRelease(observer);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空闲回调block</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 因为该对象还要被存放至集合中,当子类实现了isEqual方法时,则同时也要实现 hash方法.</span><br><span class="line"></span><br><span class="line">- (NSUInteger)hash &#123;</span><br><span class="line">    long v1 = (long)((void *)_selector);</span><br><span class="line">    long v2 = (long)_target;</span><br><span class="line">    return v1 ^ v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isEqual:(id)object &#123;</span><br><span class="line">    if (self == object) return YES;</span><br><span class="line">    if (![object isMemberOfClass:self.class]) return NO;</span><br><span class="line">    YYTransaction *other = object;</span><br><span class="line">    return other.selector == _selector &amp;&amp; other.target == _target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里重载 isEqual方法,确保不会将具有相同target和selector的委托对象放入Set中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static NSMutableSet *transactionSet = nil;</span><br><span class="line"></span><br><span class="line">static void YYRunLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123;</span><br><span class="line">    if (transactionSet.count == 0) return;</span><br><span class="line">    NSSet *currentSet = transactionSet;</span><br><span class="line">    transactionSet = [NSMutableSet new];</span><br><span class="line">    [currentSet enumerateObjectsUsingBlock:^(YYTransaction *transaction, BOOL *stop) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line"></span><br><span class="line">        [transaction.target performSelector:transaction.selector];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建唯一的 <strong>主线程 RunLoop观察者</strong>,在RunLoop进入kCFRunLoopBeforeWaiting 或 退出时 将委托方法调用.</p><h2 id="YYSentine"><a href="#YYSentine" class="headerlink" title="YYSentine"></a>YYSentine</h2><p>YYSentine的实现比较简单,主要是对 <code>OSAtomicIncrement32()</code> 函数的封装, 改函数为一个线程安全的计数器, 它会会保证在 数自增后再对其访问, 在这个框架里他是用来 作为绘制任务是否被取消的参照物的~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;YYSentinel.h&quot;</span><br><span class="line">#import &lt;libkern/OSAtomic.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation YYSentinel &#123;</span><br><span class="line">    int32_t _value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int32_t)value &#123;</span><br><span class="line">    return _value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int32_t)increase &#123;</span><br><span class="line">    return OSAtomicIncrement32(&amp;_value);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="YYAsyncLayer"><a href="#YYAsyncLayer" class="headerlink" title="YYAsyncLayer"></a>YYAsyncLayer</h2><h3 id="队列准备"><a href="#队列准备" class="headerlink" title="队列准备"></a>队列准备</h3><figure class="highlight plain"><figcaption><span>dispatch_queue_t YYAsyncLayerGetDisplayQueue() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#ifdef YYDispatchQueuePool_h</span><br><span class="line">    return YYDispatchQueueGetForQOS(NSQualityOfServiceUserInitiated);</span><br><span class="line">#else</span><br><span class="line">#define MAX_QUEUE_COUNT 16</span><br><span class="line">    static int queueCount;</span><br><span class="line">    static dispatch_queue_t queues[MAX_QUEUE_COUNT];</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    static int32_t counter = 0;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">        //queueCount = 运行该进程的系统的处于激活状态的处理器数量,</span><br><span class="line">        queueCount = (int)[NSProcessInfo processInfo].activeProcessorCount;</span><br><span class="line">        //确保 0&lt;queueCount&lt;16</span><br><span class="line">        queueCount = queueCount &lt; 1 ? 1 : queueCount &gt; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount;</span><br><span class="line"></span><br><span class="line">        //创建指定数量的 串行队列 存放在队列数组中</span><br><span class="line">        if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0) &#123;</span><br><span class="line">            for (NSUInteger i = 0; i &lt; queueCount; i++) &#123;</span><br><span class="line">                dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, 0);</span><br><span class="line">                queues[i] = dispatch_queue_create(&quot;com.ibireme.yykit.render&quot;, attr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (NSUInteger i = 0; i &lt; queueCount; i++) &#123;</span><br><span class="line">                queues[i] = dispatch_queue_create(&quot;com.ibireme.yykit.render&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">                dispatch_set_target_queue(queues[i], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 此为线程安全的自增计数,每调用一次,+1</span><br><span class="line">    int32_t cur = OSAtomicIncrement32(&amp;counter);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;cur:%d counter:%d&quot;,cur,counter);</span><br><span class="line"></span><br><span class="line">    //返回合适的队列</span><br><span class="line">    if (cur &lt; 0) cur = -cur;</span><br><span class="line">    return queues[(cur) % queueCount];</span><br><span class="line">#undef MAX_QUEUE_COUNT</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备若干的串行队列~,将绘制任务分给不同的串行队列, 这里之所以 队列数 和 处理器数 匹配. 不创建过多无效队列.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 释放队列</span><br><span class="line">static dispatch_queue_t YYAsyncLayerGetReleaseQueue() &#123;</span><br><span class="line">#ifdef YYDispatchQueuePool_h</span><br><span class="line">    return YYDispatchQueueGetForQOS(NSQualityOfServiceDefault);</span><br><span class="line">#else</span><br><span class="line">    return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>低优先级的全局队列作为 对象的释放队列,</p><h3 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h3><p>YYAsyncLayer的代理方法需要返回一个 DisplayTask对象, 任务对象中包括3个block.分别为willDisplay , display , didDisplay.在绘制的不同阶段执行</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    static CGFloat scale; //global</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        scale = [UIScreen mainScreen].scale;</span><br><span class="line">    &#125;);</span><br><span class="line">    self.contentsScale = scale;</span><br><span class="line">    //默认异步,每个图层都配置一个计数器</span><br><span class="line">    _sentinel = [YYSentinel new];</span><br><span class="line">    _displaysAsynchronously = YES;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//dealloc时 取消绘制</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [_sentinel increase];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在再次绘制时,取消上次绘制任务</span><br><span class="line">- (void)setNeedsDisplay &#123;</span><br><span class="line">    [self _cancelAsyncDisplay];</span><br><span class="line">    [super setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line">- (void)display &#123;</span><br><span class="line">    //这个我看不懂~为啥要再赋值一遍</span><br><span class="line">    super.contents = super.contents;</span><br><span class="line">    [self _displayAsync:_displaysAsynchronously];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制方法"><a href="#绘制方法" class="headerlink" title="绘制方法"></a>绘制方法</h3><h4 id="没有绘制任务"><a href="#没有绘制任务" class="headerlink" title="没有绘制任务"></a>没有绘制任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!task.display) &#123;</span><br><span class="line">    if (task.willDisplay) task.willDisplay(self);</span><br><span class="line">    self.contents = nil;</span><br><span class="line">    if (task.didDisplay) task.didDisplay(self, YES);</span><br><span class="line">    ///执行完其他非空block后 返回</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异步绘制"><a href="#异步绘制" class="headerlink" title="异步绘制"></a>异步绘制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">if (task.willDisplay) task.willDisplay(self);</span><br><span class="line">  YYSentinel *sentinel = _sentinel;</span><br><span class="line"></span><br><span class="line">  int32_t value = sentinel.value;</span><br><span class="line"></span><br><span class="line">  //判断是否要取消的block, 在图层的dealloc方法,取消绘制方法中 和 同步绘制方法中 进行线程安全的自增操作. 在调用该block时 若block截取的变量value与对象中value中的值不一致时,则表明当前任务以被取消</span><br><span class="line">  BOOL (^isCancelled)(void) = ^BOOL() &#123;</span><br><span class="line">      return value != sentinel.value;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  CGSize size = self.bounds.size;</span><br><span class="line">  BOOL opaque = self.opaque;</span><br><span class="line">  CGFloat scale = self.contentsScale;</span><br><span class="line"></span><br><span class="line">  // 当图层宽度 或 高度小于 1时 (此时没有绘制意义)</span><br><span class="line">  if (size.width &lt; 1 || size.height &lt; 1) &#123;</span><br><span class="line">      CGImageRef image = (__bridge_retained CGImageRef)(self.contents);</span><br><span class="line">      self.contents = nil;</span><br><span class="line"></span><br><span class="line">      //当图层内容为图像时,讲释放操作留在 并行释放队列中进行</span><br><span class="line">      if (image) &#123;</span><br><span class="line">          dispatch_async(YYAsyncLayerGetReleaseQueue(), ^&#123;</span><br><span class="line">              CFRelease(image);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (task.didDisplay) task.didDisplay(self, YES);</span><br><span class="line">      return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ///为正常情况</span><br><span class="line">  dispatch_async(YYAsyncLayerGetDisplayQueue(), ^&#123;</span><br><span class="line">      //若发生取消操作,则取消绘制</span><br><span class="line">      if (isCancelled()) return;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      UIGraphicsBeginImageContextWithOptions(size, opaque, scale);</span><br><span class="line">      CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      task.display(context, size, isCancelled);</span><br><span class="line"></span><br><span class="line">      //若取消 则释放资源,取消绘制</span><br><span class="line">      if (isCancelled()) &#123;</span><br><span class="line">          UIGraphicsEndImageContext();</span><br><span class="line">          dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">              if (task.didDisplay) task.didDisplay(self, NO);</span><br><span class="line">          &#125;);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //将上下文转换为图片</span><br><span class="line">      UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">      UIGraphicsEndImageContext();</span><br><span class="line"></span><br><span class="line">      //若取消 则释放资源,取消绘制</span><br><span class="line">      if (isCancelled()) &#123;</span><br><span class="line">          dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">              if (task.didDisplay) task.didDisplay(self, NO);</span><br><span class="line">          &#125;);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ///主线程异步 进行最后的绘制操作</span><br><span class="line">      dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          if (isCancelled()) &#123;</span><br><span class="line">              if (task.didDisplay) task.didDisplay(self, NO);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              self.contents = (__bridge id)(image.CGImage);</span><br><span class="line">              if (task.didDisplay) task.didDisplay(self, YES);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>YYAsyncLayer 是通过创建异步创建图像Context在其绘制,最后再主线程异步添加图像 从而实现的异步绘制.同时,在绘制过程中 进行了多次进行取消判断,以免额外绘制.</p><h4 id="同步绘制"><a href="#同步绘制" class="headerlink" title="同步绘制"></a>同步绘制</h4><p>同步绘制就是直接绘制就好了~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[_sentinel increase];</span><br><span class="line">if (task.willDisplay) task.willDisplay(self);</span><br><span class="line">UIGraphicsBeginImageContextWithOptions(self.bounds.size, self.opaque, self.contentsScale);</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">task.display(context, self.bounds.size, ^&#123;return NO;&#125;);</span><br><span class="line">UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">self.contents = (__bridge id)(image.CGImage);</span><br><span class="line">if (task.didDisplay) task.didDisplay(self, YES);</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="替换当前View的Layer"><a href="#替换当前View的Layer" class="headerlink" title="替换当前View的Layer"></a>替换当前View的Layer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)layerClass &#123;</span><br><span class="line">    return YYAsyncLayer.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改需要属性时-进行重绘制"><a href="#修改需要属性时-进行重绘制" class="headerlink" title="修改需要属性时 进行重绘制"></a>修改需要属性时 进行重绘制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)setText:(NSString *)text &#123;</span><br><span class="line">    _text = text.copy;</span><br><span class="line">    [[YYTransaction transactionWithTarget:self selector:@selector(contentsNeedUpdated)] commit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFont:(UIFont *)font &#123;</span><br><span class="line">    _font = font;</span><br><span class="line">    [[YYTransaction transactionWithTarget:self selector:@selector(contentsNeedUpdated)] commit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)layoutSubviews &#123;</span><br><span class="line">    [super layoutSubviews];</span><br><span class="line">    [[YYTransaction transactionWithTarget:self selector:@selector(contentsNeedUpdated)] commit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)contentsNeedUpdated &#123;</span><br><span class="line">    [self.layer setNeedsDisplay];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现代理方法-完成绘制任务"><a href="#实现代理方法-完成绘制任务" class="headerlink" title="实现代理方法 完成绘制任务"></a>实现代理方法 完成绘制任务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (YYAsyncLayerDisplayTask *)newAsyncDisplayTask &#123;</span><br><span class="line"></span><br><span class="line">    NSString *text = _text;</span><br><span class="line">    UIFont *font = _font;</span><br><span class="line"></span><br><span class="line">    YYAsyncLayerDisplayTask *task = [YYAsyncLayerDisplayTask new];</span><br><span class="line">    task.willDisplay = ^(CALayer *layer) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    task.display = ^(CGContextRef context, CGSize size, BOOL(^isCancelled)(void)) &#123;</span><br><span class="line">        if (isCancelled()) return;</span><br><span class="line">        //在这里由于绘制文字会颠倒</span><br><span class="line">        [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            CGContextTranslateCTM(context, 0, self.bounds.size.height);</span><br><span class="line">            CGContextScaleCTM(context, 1.0, -1.0);</span><br><span class="line">        &#125;];</span><br><span class="line">        NSAttributedString* str = [[NSAttributedString alloc] initWithString:text attributes:@&#123;NSFontAttributeName:_font&#125;];</span><br><span class="line">        CGContextSetTextPosition(context, 0, font.pointSize);</span><br><span class="line">        CTLineRef line = CTLineCreateWithAttributedString((__bridge CFAttributedStringRef)str);</span><br><span class="line">        CTLineDraw(line, context);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    task.didDisplay = ^(CALayer *layer, BOOL finished) &#123;</span><br><span class="line">        if (finished) &#123;</span><br><span class="line">            // finished</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // cancelled</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>作为对照,添加UILabel进行对比试验,重写其 <code>-(void)drawRect:</code>方法打印输出比较.<br><img src="/images/YYAsyncLayer学习/效果.png" alt="运行结果"></p><p>由此可知: 同步绘制任务(la2) 在<code>viewDidAppear</code>前完成绘制, 而AsyncLayer则在这之后再开始绘制任务,切绘制方法在异步执行.</p><h1 id="原生API对比"><a href="#原生API对比" class="headerlink" title="原生API对比."></a>原生API对比.</h1><p>关于异步绘制,iOS6 为CALayer添加了新的API <code>drawsAsynchronously</code> 属性.当你设置 drawsAsynchronously = YES 后，-drawRect: 和 -drawInContext: 函数依然实在主线程调用的。但是所有的Core Graphics函数（包括UIKit的绘制API，最后其实还是Core Graphics的调用）不会做任何事情，而是所有的绘制命令会被在后台线程处理。</p><p>这种方式就是先记录绘制命令，然后在后台线程执行。为了实现这个过程，更多的事情不得不做，更多的内存开销。最后只是把一些工作从主线程移动出来。这个过程是需要权衡，测试的。</p><p>这个可能是代价最昂贵的的提高绘制性能的方法，也不会节省很多资源。</p><p>相比之下,AsyncLaye的性能会好一些, 但麻烦的是 绘制实现要自己写<del>~</del></p><h1 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h1><p>在我使用的版本(1.0)中 异步绘制的bitmap的scale为1.0 因为+(id)defaultValueForKey:(NSString *)key 方法,所以在使用时 注意修改~~~ 不然显示的画面会有模糊感</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;YYAsyncLayer-学习&quot;&gt;&lt;a href=&quot;#YYAsyncLayer-学习&quot; class=&quot;headerlink&quot; title=&quot;YYAsyncLayer 学习&quot;&gt;&lt;/a&gt;YYAsyncLayer 学习&lt;/h1&gt;&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="第三方框架学习" scheme="http://yoursite.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>iOS进程信息 -- NSProgressInfo</title>
    <link href="http://yoursite.com/2017/11/22/iOS%E8%BF%9B%E7%A8%8B%E6%B6%88%E6%81%AF%20--%20NSProgressInfo/"/>
    <id>http://yoursite.com/2017/11/22/iOS进程消息 -- NSProgressInfo/</id>
    <published>2017-11-22T07:26:16.000Z</published>
    <updated>2017-12-13T12:58:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS进程信息-–-NSProgressInfo"><a href="#iOS进程信息-–-NSProgressInfo" class="headerlink" title="iOS进程信息 – NSProgressInfo"></a>iOS进程信息 – NSProgressInfo</h1><p> NSProcessInfo *processInfo = [NSProcessInfo processInfo];  </p><pre><code>//获取运行该进程的参数  NSArray *arr = [processInfo arguments];  NSLog(@&quot;运行该程序的参数为：%@&quot;, arr);  //获取该进程的进程标示符  NSLog(@&quot;该程序的进程标示符(PID)为：%d&quot;, [processInfo processIdentifier]);  //获取该进程的进程名  NSLog(@&quot;该程序的进程名为：%@&quot;, [processInfo processName]);  //设置该进程的新进程名  [processInfo setProcessName:@&quot;test&quot;];  NSLog(@&quot;该程序的新进程名为：%@&quot;, [processInfo processName]);  //获取运行该进程的系统的环境变量  NSLog(@&quot;运行该进程的系统的所有环境变量为：%@&quot;, [processInfo environment]);  //获取运行该进程的主机名  NSLog(@&quot;运行该进程的主机名为：%@&quot;, [processInfo hostName]);  //获取运行该进程的操作系统  NSLog(@&quot;运行该进程所在的操作系统为：%ld&quot;, [processInfo operatingSystem]);  //获取运行该进程的操作系统的版本  NSLog(@&quot;运行该进程所在的操作系统名为：%@&quot;, [processInfo operatingSystemName]);  //获取运行该进程的操作系统的版本  NSLog(@&quot;运行该进程所在的操作系统的版本为：%@&quot;, [processInfo operatingSystemVersionString]);  //获取运行该进程的系统的物理内存  NSLog(@&quot;运行该进程的系统的物理内存为：%lld&quot;, [processInfo physicalMemory]);  //获取运行该进程的系统的处理器数量  NSLog(@&quot;运行该进程的系统的处理器数量为：%ld&quot;, [processInfo processorCount]);  //获取运行该进程的系统的处于激活状态的处理器数量  NSLog(@&quot;运行该进程的系统的处于激活状态的处理器数量为：%ld&quot;, [processInfo activeProcessorCount]);  //获取运行该进程的系统已运行的时间  NSLog(@&quot;运行该进程的系统的已运行时间为：%f&quot;, [processInfo systemUptime]);  </code></pre><p>}  </p><p>转载: <a href="http://justsee.iteye.com/blog/2264764" target="_blank" rel="external">NSProcessInfo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS进程信息-–-NSProgressInfo&quot;&gt;&lt;a href=&quot;#iOS进程信息-–-NSProgressInfo&quot; class=&quot;headerlink&quot; title=&quot;iOS进程信息 – NSProgressInfo&quot;&gt;&lt;/a&gt;iOS进程信息 – NSPr
      
    
    </summary>
    
    
      <category term="iOS基础" scheme="http://yoursite.com/tags/iOS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>iOS对象判等---hash函数</title>
    <link href="http://yoursite.com/2017/11/22/iOS%E5%AF%B9%E8%B1%A1%E5%88%A4%E7%AD%89---hash%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/11/22/iOS对象判等---hash函数/</id>
    <published>2017-11-22T07:03:16.000Z</published>
    <updated>2017-12-13T12:58:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS对象判等—hash函数"><a href="#iOS对象判等—hash函数" class="headerlink" title="iOS对象判等—hash函数"></a>iOS对象判等—hash函数</h1><p>要比较相等，我们需要实现 isEqual: 方法。我们希望 isEqual: 方法仅在所有属性都相等的时候返回真。Mike Ash 的 Implement Equality and Hashing 和 NSHipster 的 Equality 为我们很好地阐述了如何实现。首先，我们需要写一个 isEqual: 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isEqual:(id)obj</span><br><span class="line">&#123;</span><br><span class="line">    if(![obj isKindOfClass:[Person class]]) return NO;</span><br><span class="line"></span><br><span class="line">    Person* other = (Person*)obj;</span><br><span class="line"></span><br><span class="line">    BOOL nameIsEqual = self.name == other.name || [self.name isEqual:other.name];</span><br><span class="line">    BOOL birthDateIsEqual = self.birthDate == other.birthDate || [self.birthDate isEqual:other.birthDate];</span><br><span class="line">    BOOL numberOfKidsIsEqual = self.numberOfKids == other.numberOfKids;</span><br><span class="line">    return nameIsEqual &amp;&amp; birthDateIsEqual &amp;&amp; numberOfKidsIsEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，我们先检查输入和自身是否是同样的类。如果不是的话，那肯定就不相等了。然后对每一个对象属性，判断其指针是否相等。|| 操作符的操作看起来好像是不必要的，但是如果我们需要处理两个属性都是 nil 的情形的话，它能够正确地返回 YES。比较像 NSUInteger 这样的标量是否相等时，则只需要使用 == 就可以了。</p><p>还有一件事情值得一提：这里我们将不同的属性比较的结果分开存储到了它们自己的 BOOL 中。在实践中，可能将它们放到一个大的判断语句中会更好，因为如果这么做的话你就可以避免一些不必要的取值和比较了。比如在上面的例子中，如果 name 已经不相等了的话，我们就没有必要再检查其他的属性了。将所有判断合并到一个 if 语句中我们可以自动地得到这样的优化。</p><p>接下来，按照文档所说，我们还需要实现一个 hash 函数。苹果如是说：</p><blockquote><p>如果两个对象是相等的，那么它们必须有同样的 hash 值。如果你在一个子类里定义了 isEqual: 方法，并且打算将这个子类的实例放到集合类中的话，那么你一定要确保你也在你的子类里定义了 hash 方法，这是非常重要的。</p></blockquote><p>首先，我们来看看如果不实现 hash 方法的话，下面的代码会发生什么；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person* p1 = [[Person alloc] initWithName:name birthDate:start numberOfKids:0];</span><br><span class="line">Person* p2 = [[Person alloc] initWithName:name birthDate:start numberOfKids:0];</span><br><span class="line">NSDictionary* dict = @&#123;p1: @&quot;one&quot;, p2: @&quot;two&quot;&#125;;</span><br><span class="line">NSLog(@&quot;%@&quot;, dict);</span><br></pre></td></tr></table></figure><p>第一次运行上面的代码是，一切都很正常，字典中有两个条目。但是第二次运行的时候却只剩一个了。事情变得不可预测，所以我们还是按照文档说的来做吧。</p><p>作为字典的键,NSSet的元素这种需要判断不重复的情况.</p><p>可能你还记得你在计算机科学课程中学到过，编写一个好的 hash 函数是一件不太容易的事情。好的 hash 函数需要兼备确定性和均布性。确定性需要保证对于同样的输入总是能生成同样的 hash 值。均布性需要保证输出的结果要在输出范围内均匀地对应输入。你的输出分布越均匀，就意味着当你将这些对象用在集合中时，性能会越好。</p><p>首先我们得搞清楚到底发生了什么。让我们来看看没有实现 hash 函数时候的情况下，使用 Person 对象作为字典的键时的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary* dictionary = [NSMutableDictionary dictionary];</span><br><span class="line"></span><br><span class="line">NSDate* start = [NSDate date];</span><br><span class="line">for (int i = 0; i &lt; 50000; i++) &#123;</span><br><span class="line">    NSString* name = randomString();</span><br><span class="line">    Person* p = [[Person alloc] initWithName:name birthDate:[NSDate date] numberOfKids:i++];</span><br><span class="line">    [dictionary setObject:@&quot;value&quot; forKey:p];</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;%f&quot;, [[NSDate date] timeIntervalSinceDate:start]);</span><br></pre></td></tr></table></figure><p>这在我的机子上花了 29 秒时间来执行。作为对比，当我们实现一个基本的 hash 方法的时候，同样的代码只花了 0.4 秒。这并不是精确的性能测试，但是却足以告诉我们实现一个正确的 hash 函数的重要性。对于 Person 这个类来说，我们可以从这样一个 hash 函数开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)hash</span><br><span class="line">&#123;</span><br><span class="line">    return self.name.hash ^ self.birthDate.hash ^ self.numberOfKids;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将从我们的属性中取出三个 hash 值，然后将它们做 XOR (异或) 操作。在这里，这个方法对我们的目标来说已经足够好了，因为对于短字符串 (以前这个上限是 96 个字符，不过现在不是这样了，参见 CFString.c 中 hash 的部分) 来说，NSString 的 hash 函数表现很好。对于更正式的 hash 算法，hash 函数应该依赖于你所拥有的数据。这在 Mike Ash 的文章和其他一些地方有所涉及。</p><p>在 hash 文档中，有下面这样一段话：</p><blockquote><p>如果一个被插入集合类的可变对象是依据其 hash 值来决定其在集合中的位置的话，这个对象的 hash 函数所返回的值在该对象存在于集合中时是不允许改变的。因此，要么使用一个和对象内部 状态无关的 hash 函数，要么确保在对象处于集合中时其内部状态不发生改变。比如说，一个可 变字典可以被放到一个 hash table 中，但是只要这个字典还在 hash table 中时，你就不能 更改它。(注意，要知道一个给定对象是不是存在于某个集合中是一件很困难的事情。)</p></blockquote><p>这也是你需要确保对象的不可变性的另一个重要原因。只要确保了这一点，你就不必再担心这个问题了。</p><p>转载截取 : <a href="https://objccn.io/issue-7-2/" target="_blank" rel="external">值对象</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS对象判等—hash函数&quot;&gt;&lt;a href=&quot;#iOS对象判等—hash函数&quot; class=&quot;headerlink&quot; title=&quot;iOS对象判等—hash函数&quot;&gt;&lt;/a&gt;iOS对象判等—hash函数&lt;/h1&gt;&lt;p&gt;要比较相等，我们需要实现 isEqual: 
      
    
    </summary>
    
    
      <category term="iOS基础" scheme="http://yoursite.com/tags/iOS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 2.0</title>
    <link href="http://yoursite.com/2017/11/22/HTTP%202.0/"/>
    <id>http://yoursite.com/2017/11/22/HTTP 2.0/</id>
    <published>2017-11-22T01:04:12.000Z</published>
    <updated>2017-12-13T12:58:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h1><h2 id="HTTP-1-0-缺点"><a href="#HTTP-1-0-缺点" class="headerlink" title="HTTP 1.0 缺点"></a>HTTP 1.0 缺点</h2><p>在http 1.0 时,每进行一次请求时,都会建立一次TCP连接,开销很大</p><h2 id="HTTP-1-1-缺点"><a href="#HTTP-1-1-缺点" class="headerlink" title="HTTP 1.1 缺点"></a>HTTP 1.1 缺点</h2><h3 id="HTTP-Pipelining-http管线技术"><a href="#HTTP-Pipelining-http管线技术" class="headerlink" title="HTTP Pipelining(http管线技术)"></a>HTTP Pipelining(http管线技术)</h3><p>在http1.1中默认是启用该技术的,即消息头中:Connection:keep-alive.</p><p>HTTP Pipelining其实是把多个HTTP请求放到<strong>一个TCP连接</strong>中一一发送，而在发送过程中不需要等待服务器对前一个请求的响应；只不过，客户端还是要<strong>按照发送请求的顺序</strong>来接收响应。这样就像在串行队列中执行任务一样,若前一个任务十分耗时,则会导致后续的响应卡顿.这就是所谓的线头卡顿(Head of line blocking).</p><h3 id="请求数量"><a href="#请求数量" class="headerlink" title="请求数量"></a>请求数量</h3><p>浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞</p><h3 id="数据大小"><a href="#数据大小" class="headerlink" title="数据大小"></a>数据大小</h3><p>HTTP1.1的格式为文本格式,难以优化. 大量相似http请求时,会发送大量一样的消息头,导致流量浪费.(跟json 与 protocolBuf)</p><h3 id="服务端无法主动推送资源至服务端"><a href="#服务端无法主动推送资源至服务端" class="headerlink" title="服务端无法主动推送资源至服务端"></a>服务端无法主动推送资源至服务端</h3><h2 id="HTTP-2-0-1"><a href="#HTTP-2-0-1" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>HTTP 2.0 使用新的<strong>二进制格式</strong>：基本的协议单位是帧，每个帧都有不同的类型和用途，规范中定义了10种不同的帧。例如，报头(HEADERS)和数据(DATA)帧组成了基本的HTTP 请求和响应；其他帧例如 设置(SETTINGS),窗口更新(WINDOW_UPDATE), 和推送承诺(PUSH_PROMISE)是用来实现HTTP/2的其他功能。那些请求和响应的帧数据通过流来进行数据交换。新的二进制格式是流量控制、优先级、server push等功能的基础.<br><img src="images/HTTP 2.0/15112529987865.jpg" alt=""></p><h3 id="单一连接-多路复用"><a href="#单一连接-多路复用" class="headerlink" title="单一连接,多路复用"></a>单一连接,多路复用</h3><p>http2.0 允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。可以理解为在单一的TCP链接中,并发请求响应.<br><img src="images/HTTP 2.0/15112560081647.jpg" alt=""></p><p>在TCP链接时,并不是一开始就到达最大传输速度,因为若带宽不足,一开始高速则会导致阻塞.而是随着时间推移逐渐提速,最后达到适合的速度.这叫做TCP的慢启动. 而这对于HTTP这种突发性,短时性的链接会十分低效.</p><h3 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h3><p>http2.0是用了专门为头部压缩而设计的算法,减少冗余数据的传输.</p><h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p>服务端推送是一种在客户端请求之前发送数据的机制,在HTTP 2.0中,服务端可以对客户端的一个请求发送多个响应.这样可以在客户端下次请求时直接返回推送的缓存.</p><h3 id="同类协议"><a href="#同类协议" class="headerlink" title="同类协议"></a>同类协议</h3><p>SPDY的特性基本和Http 2.0相同,因为http2.0就是收spdy的启发设计的. 主要不同在于对传输数据使用gzip进行压缩.</p><h3 id="iOS端使用"><a href="#iOS端使用" class="headerlink" title="iOS端使用"></a>iOS端使用</h3><p>在iOS下,NSURLSession适配了http2.0的,所以我们可以无感的使用他,而不需要做额外的适配,主要是服务器的配置.</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h2><p><a href="http://www.jianshu.com/p/d3959e5acfac" target="_blank" rel="external">iOS HTTP/2 Server Push 探索</a><br><a href="https://ye11ow.gitbooks.io/http2-explained/content/part3.html" target="_blank" rel="external">http2.0讲解</a><br><a href="">关于 iOS HTTP2.0 的一次学习实践</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTP-2-0&quot;&gt;&lt;a href=&quot;#HTTP-2-0&quot; class=&quot;headerlink&quot; title=&quot;HTTP 2.0&quot;&gt;&lt;/a&gt;HTTP 2.0&lt;/h1&gt;&lt;h2 id=&quot;HTTP-1-0-缺点&quot;&gt;&lt;a href=&quot;#HTTP-1-0-缺点&quot; class
      
    
    </summary>
    
    
      <category term="iOS网络" scheme="http://yoursite.com/tags/iOS%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
